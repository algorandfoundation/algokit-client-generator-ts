import { DocumentParts, inline, NewLine } from '../output/writer'
import { paramsFactory } from './params-factory'
import { appClient } from './app-client'
import { deployTypes } from './deploy-types'
import { utilityTypes } from './utility-types'
import { imports } from './imports'
import { createGeneratorContext, GeneratorOptions } from './generator-context'
import { appTypes } from './app-types'
import { callComposerType } from './call-composer-types'
import { Arc56Contract, ProgramSourceInfo, StructField } from '@algorandfoundation/algokit-utils/abi'
import { appFactory } from './app-factory'
import { Sanitizer } from '../util/sanitization'

function convertStructs(s: StructField[], sanitizer: Sanitizer): StructField[] {
  return s.map(
    ({ name, type }) =>
      ({
        name: sanitizer.makeSafePropertyIdentifier(name),
        type: typeof type === 'string' ? type : convertStructs(type, sanitizer),
      }) satisfies StructField,
  )
}

function shrinkAppSpec(app: Arc56Contract, options: GeneratorOptions): Arc56Contract {
  const strippedAppSpec = structuredClone(app)

  // Only keep the source info if it is needed for error mapping
  const shrinkSourceInfo = (sourceInfo: ProgramSourceInfo['sourceInfo']) => {
    return sourceInfo
      .filter((entry) => entry.errorMessage)
      .map((entry) => ({
        pc: entry.pc,
        errorMessage: entry.errorMessage,
        // Keep minimal context for error mapping if available
        ...(entry.teal !== undefined && { teal: entry.teal }),
      }))
  }

  // Keep only source info entries that can be used for approval and clear program error mapping
  if (strippedAppSpec.sourceInfo?.approval?.sourceInfo && strippedAppSpec.sourceInfo.approval.sourceInfo.length > 0) {
    strippedAppSpec.sourceInfo.approval.sourceInfo = shrinkSourceInfo(strippedAppSpec.sourceInfo.approval.sourceInfo)
  }

  if (strippedAppSpec.sourceInfo?.clear?.sourceInfo && strippedAppSpec.sourceInfo.clear.sourceInfo.length > 0) {
    strippedAppSpec.sourceInfo.clear.sourceInfo = shrinkSourceInfo(strippedAppSpec.sourceInfo.clear.sourceInfo)
  }

  if (strippedAppSpec.compilerInfo) {
    delete strippedAppSpec.compilerInfo
  }

  // These are used for deploying but not for calling deployed apps
  if (options.mode === 'minimal') {
    if (strippedAppSpec.source) {
      delete strippedAppSpec.source
    }
    if (strippedAppSpec.byteCode) {
      delete strippedAppSpec.byteCode
    }
    if (strippedAppSpec.templateVariables) {
      delete strippedAppSpec.templateVariables
    }
    if (strippedAppSpec.scratchVariables) {
      delete strippedAppSpec.scratchVariables
    }
  }
  return strippedAppSpec
}

export function* generate(app: Arc56Contract, options?: Partial<GeneratorOptions>): DocumentParts {
  const resolvedOptions: GeneratorOptions = {
    // Set defaults
    preserveNames: false,
    mode: 'full',
    ...options,
  }
  const reduceAppSpec = shrinkAppSpec(app, resolvedOptions)

  const ctx = createGeneratorContext(reduceAppSpec, resolvedOptions)
  yield `/* eslint-disable */`
  yield `/**`
  yield ` * This file was automatically generated by @algorandfoundation/algokit-client-generator.`
  yield ` * DO NOT MODIFY IT BY HAND.`
  yield ` * requires: @algorandfoundation/algokit-utils: ^10`
  yield ` */`

  yield* imports()
  // Change the structs definition to sanitize property names according to the defined rules
  // for instance, this may (unless you passed in --preserve-names) convert properties like my_prop to myProp
  reduceAppSpec.structs = Object.fromEntries(
    Object.keys(reduceAppSpec.structs).map((key) => [key, convertStructs(reduceAppSpec.structs[key], ctx.sanitizer)]),
  )
  yield "/* Don't format the app spec json */"
  yield '/* prettier-ignore */'
  yield* inline('export const APP_SPEC: Arc56Contract = ', JSON.stringify(reduceAppSpec), ' as unknown as Arc56Contract')
  yield NewLine

  yield* utilityTypes()
  yield NewLine
  yield* appTypes(ctx)

  if (ctx.mode === 'full') {
    yield* deployTypes(ctx)
  }
  yield NewLine

  // Write a call factory
  yield* paramsFactory(ctx)
  yield NewLine
  // Write a factory in full mode
  if (ctx.mode === 'full') {
    yield* appFactory(ctx)
  }
  // Write a client
  yield* appClient(ctx)

  yield* callComposerType(ctx)
}

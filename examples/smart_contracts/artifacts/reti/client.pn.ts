/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^10
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, ABIStructType, Arc56Contract, getStructValueFromTupleValue } from '@algorandfoundation/algokit-utils/abi'
import { OnApplicationComplete, TransactionSigner, Transaction } from '@algorandfoundation/algokit-utils/transact'
import { SimulateResponse } from '@algorandfoundation/algokit-utils/algod-client'
import { Address, encodeAddress } from '@algorandfoundation/algokit-utils'
import {
  AppClientMethodCallParams,
  AppClientCompilationParams,
  AppClientDeployParams,
  CallOnComplete,
  AppClient as _AppClient,
  AppClientParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  AppClientBareCallParams,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { SendParams, SendTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import {
  AppFactoryCreateMethodCallParams,
  AppFactoryAppClientParams,
  AppFactoryDeployParams,
  AppFactoryParams,
  AppFactory as _AppFactory,
  AppFactoryResolveAppClientByCreatorAndNameParams,
  CreateSchema,
} from '@algorandfoundation/algokit-utils/types/app-factory'
import {
  TransactionComposer,
  TransactionComposerConfig,
  SkipSignaturesSimulateOptions,
  RawSimulateOptions,
  SimulateOptions,
  AppMethodCallTransactionArgument,
} from '@algorandfoundation/algokit-utils/types/composer'

/* Don't format the app spec json */
/* prettier-ignore */
export const APP_SPEC: Arc56Contract = {"name":"ValidatorRegistry","desc":"","methods":[{"name":"createApplication","args":[],"returns":{"type":"void"},"actions":{"create":["NoOp"],"call":[]}},{"name":"initStakingContract","args":[{"name":"approvalProgramSize","type":"uint64"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"loadStakingContractData","args":[{"name":"offset","type":"uint64"},{"name":"data","type":"byte[]"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"finalizeStakingContract","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"gas","desc":"gas is a dummy no-op call that can be used to pool-up resource references and opcode cost","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getMbrAmounts","desc":"Returns the MBR amounts needed for various actions:\n[\n addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract\n addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator\n poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself\n addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)\n]","readonly":true,"args":[],"returns":{"type":"(uint64,uint64,uint64,uint64)","struct":"MbrAmounts"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getProtocolConstraints","desc":"Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.","readonly":true,"args":[],"returns":{"type":"(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)","struct":"Constraints"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getNumValidators","desc":"Returns the current number of validators","readonly":true,"args":[],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getValidatorConfig","readonly":true,"args":[{"name":"validatorId","type":"uint64"}],"returns":{"type":"(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)","struct":"ValidatorConfig"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getValidatorState","readonly":true,"args":[{"name":"validatorId","type":"uint64"}],"returns":{"type":"(uint16,uint64,uint64,uint64)","struct":"ValidatorCurState"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getValidatorOwnerAndManager","readonly":true,"args":[{"name":"validatorId","type":"uint64"}],"returns":{"type":"(address,address)"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getPools","desc":"Return list of all pools for this validator.","readonly":true,"args":[{"name":"validatorId","type":"uint64","desc":"PoolInfo[] - array of pools\nNot callable from other contracts because 1K return but can be called w/ simulate which bumps log returns"}],"returns":{"type":"(uint64,uint16,uint64)[]"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getPoolAppId","desc":"getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or\nwant to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1\n(which contains reward tokens if being used) so that the amount available can be determined.","readonly":true,"args":[{"name":"validatorId","type":"uint64"},{"name":"poolId","type":"uint64"}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getPoolInfo","readonly":true,"args":[{"name":"poolKey","type":"(uint64,uint64,uint64)","struct":"ValidatorPoolKey"}],"returns":{"type":"(uint64,uint16,uint64)","struct":"PoolInfo"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getCurMaxStakePerPool","desc":"Calculate the maximum stake per pool for a given validator.\nNormally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so\nas pools are added the max allowed per pool can reduce.","readonly":true,"args":[{"name":"validatorId","type":"uint64","desc":"The id of the validator."}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]}},{"name":"doesStakerNeedToPayMBR","desc":"Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount","readonly":true,"args":[{"name":"staker","type":"address"}],"returns":{"type":"bool"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getStakedPoolsForAccount","desc":"Retrieves the staked pools for an account.","readonly":true,"args":[{"name":"staker","type":"address","desc":"The account to retrieve staked pools for.\n ValidatorPoolKey[] - The array of staked pools for the account."}],"returns":{"type":"(uint64,uint64,uint64)[]"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getTokenPayoutRatio","desc":"Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token\npayouts across pools can be based on a stable snaphost of stake.","readonly":true,"args":[{"name":"validatorId","type":"uint64","desc":"The id of the validator.\n PoolTokenPayoutRatio - The token payout ratio for the validator."}],"returns":{"type":"(uint64[24],uint64)","struct":"PoolTokenPayoutRatio"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getNodePoolAssignments","readonly":true,"args":[{"name":"validatorId","type":"uint64"}],"returns":{"type":"((uint64[3])[8])","struct":"NodePoolAssignmentConfig"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getNFDRegistryID","readonly":true,"args":[],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]}},{"name":"addValidator","desc":"Adds a new validator\nRequires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.","args":[{"name":"mbrPayment","type":"pay","desc":"payment from caller which covers mbr increase of new validator storage"},{"name":"nfdName","type":"string","desc":"(Optional) Name of nfd (used as double-check against id specified in config)"},{"name":"config","type":"(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)","desc":"ValidatorConfig struct","struct":"ValidatorConfig"}],"returns":{"type":"uint64","desc":"uint64 validator id"},"events":[{"name":"retiOP_addedValidator","args":[{"name":"id","type":"uint64"},{"name":"owner","type":"address"},{"name":"manager","type":"address"}],"desc":"Logs the addition of a new validator to the system, its initial owner and manager"}],"actions":{"create":[],"call":["NoOp"]}},{"name":"changeValidatorManager","desc":"Changes the Validator manager for a specific Validator id.\n[ ONLY OWNER CAN CHANGE ]","args":[{"name":"validatorId","type":"uint64","desc":"The id of the validator to change the manager for."},{"name":"manager","type":"address","desc":"The new manager address."}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"changeValidatorSunsetInfo","desc":"Updates the sunset information for a given validator.\n[ ONLY OWNER CAN CHANGE ]","args":[{"name":"validatorId","type":"uint64","desc":"The id of the validator to update."},{"name":"sunsettingOn","type":"uint64","desc":"The new sunset timestamp."},{"name":"sunsettingTo","type":"uint64","desc":"The new sunset to validator id."}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"changeValidatorNFD","desc":"Changes the NFD for a validator in the validatorList contract.\n[ ONLY OWNER CAN CHANGE ]","args":[{"name":"validatorId","type":"uint64","desc":"The id of the validator to update."},{"name":"nfdAppID","type":"uint64","desc":"The application id of the NFD to assign to the validator."},{"name":"nfdName","type":"string","desc":"The name of the NFD (which must match)"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"changeValidatorCommissionAddress","desc":"Change the commission address that validator rewards are sent to.\n     [ ONLY OWNER CAN CHANGE ]","args":[{"name":"validatorId","type":"uint64"},{"name":"commissionAddress","type":"address"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"changeValidatorRewardInfo","desc":"Allow the additional rewards (gating entry, additional token rewards) information be changed at will.\n[ ONLY OWNER CAN CHANGE ]","args":[{"name":"validatorId","type":"uint64"},{"name":"EntryGatingType","type":"uint8"},{"name":"EntryGatingAddress","type":"address"},{"name":"EntryGatingAssets","type":"uint64[4]"},{"name":"GatingAssetMinBalance","type":"uint64"},{"name":"RewardPerPayout","type":"uint64"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"addPool","desc":"Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.\nThe caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.\n\n\n[ ONLY OWNER OR MANAGER CAN call ]","args":[{"name":"mbrPayment","type":"pay","desc":"payment from caller which covers mbr increase of adding a new pool"},{"name":"validatorId","type":"uint64","desc":"is id of validator to pool to (must be owner or manager)"},{"name":"nodeNum","type":"uint64","desc":"is node number to add to"}],"returns":{"type":"(uint64,uint64,uint64)","desc":"ValidatorPoolKey pool key to created pool","struct":"ValidatorPoolKey"},"events":[{"name":"retiOP_validatorAddedPool","args":[{"name":"id","type":"uint64"},{"name":"num","type":"uint16"},{"name":"poolAppId","type":"uint64"}],"desc":"Logs the addition of a new pool to a particular validator ID"}],"actions":{"create":[],"call":["NoOp"]}},{"name":"addStake","desc":"Adds stake to a validator pool.","args":[{"name":"stakedAmountPayment","type":"pay","desc":"payment coming from staker to place into a pool"},{"name":"validatorId","type":"uint64","desc":"The id of the validator."},{"name":"valueToVerify","type":"uint64","desc":"only if validator has gating to enter - this is asset id or nfd id that corresponds to gating.\nTxn sender is factored in as well if that is part of gating.\n*"}],"returns":{"type":"(uint64,uint64,uint64)","desc":"ValidatorPoolKey - The key of the validator pool.","struct":"ValidatorPoolKey"},"events":[{"name":"retiOP_stakeAdded","args":[{"name":"id","type":"uint64"},{"name":"poolNum","type":"uint16"},{"name":"poolAppId","type":"uint64"},{"name":"staker","type":"address"},{"name":"amountStaked","type":"uint64"}],"desc":"Logs how much stake was added by a staker to a particular staking pool"}],"actions":{"create":[],"call":["NoOp"]}},{"name":"setTokenPayoutRatio","desc":"setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios\nof stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40\nin pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by\npool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.\nIt would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of\ntheir 'current' stake which changes as part of the payouts themselves (and people could be changing stake\nduring the epoch updates across pools)\n\n\nMultiple pools will call us via pool 1 (pool2-pool1-validator, etc.) so don't assert on pool1 calling multiple\ntimes in same epoch.  Just return.","args":[{"name":"validatorId","type":"uint64","desc":"validator id (and thus pool) calling us.  Verified so that sender MUST be pool 1 of this validator."}],"returns":{"type":"(uint64[24],uint64)","desc":"PoolTokenPayoutRatio - the finished ratio data","struct":"PoolTokenPayoutRatio"},"actions":{"create":[],"call":["NoOp"]}},{"name":"stakeUpdatedViaRewards","desc":"stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total\nstake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.\nThe calling App id is validated against our pool list as well.","args":[{"name":"poolKey","type":"(uint64,uint64,uint64)","desc":"ValidatorPoolKey type","struct":"ValidatorPoolKey"},{"name":"algoToAdd","type":"uint64","desc":"amount this validator's total stake increased via rewards"},{"name":"rewardTokenAmountReserved","type":"uint64","desc":"amount this validator's total stake increased via rewards (that should be"},{"name":"validatorCommission","type":"uint64","desc":"the commission amount the validator was paid, if any"},{"name":"saturatedBurnToFeeSink","type":"uint64","desc":"if the pool was in saturated state, the amount sent back to the fee sink.\nseen as 'accounted for/pending spent')"}],"returns":{"type":"void"},"events":[{"name":"retiOP_epochRewardUpdate","args":[{"name":"id","type":"uint64"},{"name":"poolNum","type":"uint16"},{"name":"poolAppId","type":"uint64"},{"name":"validatorCommission","type":"uint64"},{"name":"saturatedBurnToFeeSink","type":"uint64"},{"name":"algoAdded","type":"uint64"},{"name":"rewardTokenHeldBack","type":"uint64"}],"desc":"Logs how much algo was detected as being added to a staking pool as part of epoch reward calculations.\nCommission amount to validator, excess burned if pool is saturated, and the amount of tokens held back are logged as well."}],"actions":{"create":[],"call":["NoOp"]}},{"name":"stakeRemoved","desc":"stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed\nfrom the specified pool.  This is used to update the stats we have in our PoolInfo storage.\nIf any amount of rewardRemoved is specified, then that amount of reward is sent to the use\nThe calling App id is validated against our pool list as well.","args":[{"name":"poolKey","type":"(uint64,uint64,uint64)","desc":"calling us from which stake was removed","struct":"ValidatorPoolKey"},{"name":"staker","type":"address"},{"name":"amountRemoved","type":"uint64","desc":"algo amount removed"},{"name":"rewardRemoved","type":"uint64","desc":"if applicable, amount of token reward removed (by pool 1 caller) or TO remove and pay out (via pool 1 from different pool caller)"},{"name":"stakerRemoved","type":"bool"}],"returns":{"type":"void"},"events":[{"name":"retiOP_stakeRemoved","args":[{"name":"id","type":"uint64"},{"name":"poolNum","type":"uint16"},{"name":"poolAppId","type":"uint64"},{"name":"staker","type":"address"},{"name":"amountUnstaked","type":"uint64"},{"name":"rewardTokensReceived","type":"uint64"},{"name":"rewardTokenAssetId","type":"uint64"}],"desc":"Logs how much stake was removed by a staker from a particular staking pool"}],"actions":{"create":[],"call":["NoOp"]}},{"name":"findPoolForStaker","desc":"Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.\nFirst checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds\nto new pool if necessary.","readonly":true,"args":[{"name":"validatorId","type":"uint64","desc":"The id of the validator."},{"name":"staker","type":"address","desc":"The address of the staker."},{"name":"amountToStake","type":"uint64","desc":"The amount to stake."}],"returns":{"type":"((uint64,uint64,uint64),bool,bool)","desc":"ValidatorPoolKey, boolean, boolean - The pool for the staker, true/false on whether the staker is 'new'\nto this VALIDATOR, and true/false if staker is new to the protocol."},"actions":{"create":[],"call":["NoOp"]}},{"name":"movePoolToNode","desc":"Find the specified pool (in any node number) and move it to the specified node.\nThe pool account is forced offline if moved so prior node will still run for 320 rounds but\nnew key goes online on new node soon after (320 rounds after it goes online)\nNo-op if success, asserts if not found or can't move  (no space in target)\n[ ONLY OWNER OR MANAGER CAN CHANGE ]","args":[{"name":"validatorId","type":"uint64","desc":"The id of the validator."},{"name":"poolAppId","type":"uint64"},{"name":"nodeNum","type":"uint64"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"emptyTokenRewards","desc":"Sends the reward tokens held in pool 1 to specified receiver.\nThis is intended to be used by the owner when they want to get reward tokens 'back' which they sent to\nthe first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will\nNOT be sent as they must be held back for stakers to later claim.\n[ ONLY OWNER CAN CALL]","args":[{"name":"validatorId","type":"uint64","desc":"The id of the validator."},{"name":"receiver","type":"address","desc":"the account to send the tokens to (must already be opted-in to the reward token)"}],"returns":{"type":"uint64","desc":"uint64 the amount of reward token sent"},"actions":{"create":[],"call":["NoOp"]}}],"events":[{"name":"retiOP_addedValidator","args":[{"name":"id","type":"uint64"},{"name":"owner","type":"address"},{"name":"manager","type":"address"}],"desc":"Logs the addition of a new validator to the system, its initial owner and manager"},{"name":"retiOP_validatorAddedPool","args":[{"name":"id","type":"uint64"},{"name":"num","type":"uint16"},{"name":"poolAppId","type":"uint64"}],"desc":"Logs the addition of a new pool to a particular validator ID"},{"name":"retiOP_stakeAdded","args":[{"name":"id","type":"uint64"},{"name":"poolNum","type":"uint16"},{"name":"poolAppId","type":"uint64"},{"name":"staker","type":"address"},{"name":"amountStaked","type":"uint64"}],"desc":"Logs how much stake was added by a staker to a particular staking pool"},{"name":"retiOP_epochRewardUpdate","args":[{"name":"id","type":"uint64"},{"name":"poolNum","type":"uint16"},{"name":"poolAppId","type":"uint64"},{"name":"validatorCommission","type":"uint64"},{"name":"saturatedBurnToFeeSink","type":"uint64"},{"name":"algoAdded","type":"uint64"},{"name":"rewardTokenHeldBack","type":"uint64"}],"desc":"Logs how much algo was detected as being added to a staking pool as part of epoch reward calculations.\nCommission amount to validator, excess burned if pool is saturated, and the amount of tokens held back are logged as well."},{"name":"retiOP_stakeRemoved","args":[{"name":"id","type":"uint64"},{"name":"poolNum","type":"uint16"},{"name":"poolAppId","type":"uint64"},{"name":"staker","type":"address"},{"name":"amountUnstaked","type":"uint64"},{"name":"rewardTokensReceived","type":"uint64"},{"name":"rewardTokenAssetId","type":"uint64"}],"desc":"Logs how much stake was removed by a staker from a particular staking pool"}],"arcs":[4,56],"structs":{"ValidatorInfo":[{"name":"config","type":[{"name":"id","type":"uint64"},{"name":"owner","type":"address"},{"name":"manager","type":"address"},{"name":"nfdForInfo","type":"uint64"},{"name":"entryGatingType","type":"uint8"},{"name":"entryGatingAddress","type":"address"},{"name":"entryGatingAssets","type":"uint64[4]"},{"name":"gatingAssetMinBalance","type":"uint64"},{"name":"rewardTokenId","type":"uint64"},{"name":"rewardPerPayout","type":"uint64"},{"name":"epochRoundLength","type":"uint32"},{"name":"percentToValidator","type":"uint32"},{"name":"validatorCommissionAddress","type":"address"},{"name":"minEntryStake","type":"uint64"},{"name":"maxAlgoPerPool","type":"uint64"},{"name":"poolsPerNode","type":"uint8"},{"name":"sunsettingOn","type":"uint64"},{"name":"sunsettingTo","type":"uint64"}]},{"name":"state","type":[{"name":"numPools","type":"uint16"},{"name":"totalStakers","type":"uint64"},{"name":"totalAlgoStaked","type":"uint64"},{"name":"rewardTokenHeldBack","type":"uint64"}]},{"name":"pools","type":"(uint64,uint16,uint64)[24]"},{"name":"tokenPayoutRatio","type":[{"name":"poolPctOfWhole","type":"uint64[24]"},{"name":"updatedForPayout","type":"uint64"}]},{"name":"nodePoolAssignments","type":[{"name":"nodes","type":"(uint64[3])[8]"}]}],"MbrAmounts":[{"name":"addValidatorMbr","type":"uint64"},{"name":"addPoolMbr","type":"uint64"},{"name":"poolInitMbr","type":"uint64"},{"name":"addStakerMbr","type":"uint64"}],"Constraints":[{"name":"epochPayoutRoundsMin","type":"uint64"},{"name":"epochPayoutRoundsMax","type":"uint64"},{"name":"minPctToValidatorWFourDecimals","type":"uint64"},{"name":"maxPctToValidatorWFourDecimals","type":"uint64"},{"name":"minEntryStake","type":"uint64"},{"name":"maxAlgoPerPool","type":"uint64"},{"name":"maxAlgoPerValidator","type":"uint64"},{"name":"amtConsideredSaturated","type":"uint64"},{"name":"maxNodes","type":"uint64"},{"name":"maxPoolsPerNode","type":"uint64"},{"name":"maxStakersPerPool","type":"uint64"}],"ValidatorConfig":[{"name":"id","type":"uint64"},{"name":"owner","type":"address"},{"name":"manager","type":"address"},{"name":"nfdForInfo","type":"uint64"},{"name":"entryGatingType","type":"uint8"},{"name":"entryGatingAddress","type":"address"},{"name":"entryGatingAssets","type":"uint64[4]"},{"name":"gatingAssetMinBalance","type":"uint64"},{"name":"rewardTokenId","type":"uint64"},{"name":"rewardPerPayout","type":"uint64"},{"name":"epochRoundLength","type":"uint32"},{"name":"percentToValidator","type":"uint32"},{"name":"validatorCommissionAddress","type":"address"},{"name":"minEntryStake","type":"uint64"},{"name":"maxAlgoPerPool","type":"uint64"},{"name":"poolsPerNode","type":"uint8"},{"name":"sunsettingOn","type":"uint64"},{"name":"sunsettingTo","type":"uint64"}],"ValidatorCurState":[{"name":"numPools","type":"uint16"},{"name":"totalStakers","type":"uint64"},{"name":"totalAlgoStaked","type":"uint64"},{"name":"rewardTokenHeldBack","type":"uint64"}],"PoolInfo":[{"name":"poolAppId","type":"uint64"},{"name":"totalStakers","type":"uint16"},{"name":"totalAlgoStaked","type":"uint64"}],"ValidatorPoolKey":[{"name":"id","type":"uint64"},{"name":"poolId","type":"uint64"},{"name":"poolAppId","type":"uint64"}],"PoolTokenPayoutRatio":[{"name":"poolPctOfWhole","type":"uint64[24]"},{"name":"updatedForPayout","type":"uint64"}],"NodePoolAssignmentConfig":[{"name":"nodes","type":"(uint64[3])[8]"}]},"state":{"schema":{"global":{"bytes":1,"ints":3},"local":{"bytes":0,"ints":0}},"keys":{"global":{"stakingPoolInitialized":{"key":"aW5pdA==","keyType":"AVMBytes","valueType":"bool"},"numValidators":{"key":"bnVtVg==","keyType":"AVMBytes","valueType":"uint64"},"numStakers":{"key":"bnVtU3Rha2Vycw==","keyType":"AVMBytes","valueType":"uint64"},"totalAlgoStaked":{"key":"c3Rha2Vk","keyType":"AVMBytes","valueType":"uint64"}},"local":{},"box":{"stakingPoolApprovalProgram":{"key":"cG9vbFRlbXBsYXRlQXBwcm92YWxCeXRlcw==","keyType":"AVMBytes","valueType":"AVMBytes"}}},"maps":{"global":{},"local":{},"box":{"validatorList":{"keyType":"uint64","valueType":"ValidatorInfo","prefix":"dg=="},"stakerPoolSet":{"keyType":"address","valueType":"(uint64,uint64,uint64)[6]","prefix":"c3Bz"}}}},"bareActions":{"create":[],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[36],"errorMessage":"The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?","teal":25},{"pc":[554],"errorMessage":"pool id must be between 1 and number of pools for this validator","teal":582},{"pc":[586],"errorMessage":"argument 0 (poolKey) for getPoolInfo must be a (uint64,uint64,uint64)","teal":618},{"pc":[723],"errorMessage":"argument 0 (staker) for doesStakerNeedToPayMBR must be a address","teal":771},{"pc":[758],"errorMessage":"argument 0 (staker) for getStakedPoolsForAccount must be a address","teal":815},{"pc":[805],"errorMessage":"box value does not exist: this.stakerPoolSet(staker).value","teal":877},{"pc":[915],"errorMessage":"the specified validator id doesn't exist","teal":1015},{"pc":[953],"errorMessage":"argument 0 (config) for addValidator must be a (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)","teal":1064},{"pc":[969],"errorMessage":"argument 2 (mbrPayment) for addValidator must be a pay transaction","teal":1080},{"pc":[994],"errorMessage":"transaction verification failed: {\"txn\":\"mbrPayment\",\"field\":\"receiver\",\"expected\":\"this.app.address\"}","teal":1119},{"pc":[1007],"errorMessage":"transaction verification failed: {\"txn\":\"mbrPayment\",\"field\":\"amount\",\"expected\":\"this.getMbrAmounts().addValidatorMbr\"}","teal":1130},{"pc":[1018],"errorMessage":"fee must be 10 ALGO or more to prevent spamming of validators","teal":1140},{"pc":[1084],"errorMessage":"provided NFD must be valid","teal":1208},{"pc":[1096],"errorMessage":"global state value does not exist: AppID.fromUint64(config.nfdForInfo).globalState('i.owner.a')","teal":1223},{"pc":[1098],"errorMessage":"If specifying NFD, account adding validator must be owner","teal":1227},{"pc":[1134],"errorMessage":"provided NFD App id for gating must be valid NFD","teal":1263},{"pc":[1171],"errorMessage":"argument 0 (manager) for changeValidatorManager must be a address","teal":1298},{"pc":[1194],"errorMessage":"needs to at least be valid address","teal":1331},{"pc":[1293],"errorMessage":"provided NFD must be valid","teal":1446},{"pc":[1301],"errorMessage":"global state value does not exist: AppID.fromUint64(nfdAppID).globalState('i.owner.a')","teal":1459},{"pc":[1303],"errorMessage":"If specifying NFD, account adding validator must be owner","teal":1463},{"pc":[1326],"errorMessage":"argument 0 (commissionAddress) for changeValidatorCommissionAddress must be a address","teal":1488},{"pc":[1380],"errorMessage":"argument 2 (EntryGatingAssets) for changeValidatorRewardInfo must be a uint64[4]","teal":1548},{"pc":[1389],"errorMessage":"argument 3 (EntryGatingAddress) for changeValidatorRewardInfo must be a address","teal":1558},{"pc":[1397],"errorMessage":"argument 4 (EntryGatingType) for changeValidatorRewardInfo must be a uint8","teal":1568},{"pc":[1430],"errorMessage":"invalid Entry gating type","teal":1609},{"pc":[1471],"errorMessage":"provided NFD App id for gating must be valid NFD","teal":1654},{"pc":[1558],"errorMessage":"argument 2 (mbrPayment) for addPool must be a pay transaction","teal":1740},{"pc":[1583],"errorMessage":"transaction verification failed: {\"txn\":\"mbrPayment\",\"field\":\"receiver\",\"expected\":\"this.app.address\"}","teal":1780},{"pc":[1596],"errorMessage":"transaction verification failed: {\"txn\":\"mbrPayment\",\"field\":\"amount\",\"expected\":\"this.getMbrAmounts().addPoolMbr\"}","teal":1791},{"pc":[1605],"errorMessage":"specified validator id isn't valid","teal":1804},{"pc":[1628],"errorMessage":"already at max pool size","teal":1829},{"pc":[1658],"errorMessage":"box value does not exist: this.stakingPoolApprovalProgram.size","teal":1884},{"pc":[1794],"errorMessage":"numPools as uint16 overflowed 16 bits","teal":2011},{"pc":[1839],"errorMessage":"argument 2 (stakedAmountPayment) for addStake must be a pay transaction","teal":2061},{"pc":[1861],"errorMessage":"specified validator id isn't valid","teal":2097},{"pc":[1894],"errorMessage":"can't stake with a validator that is past its sunsetting time","teal":2134},{"pc":[1906],"errorMessage":"transaction verification failed: {\"txn\":\"stakedAmountPayment\",\"field\":\"sender\",\"expected\":\"staker\"}","teal":2154},{"pc":[1914],"errorMessage":"transaction verification failed: {\"txn\":\"stakedAmountPayment\",\"field\":\"receiver\",\"expected\":\"this.app.address\"}","teal":2163},{"pc":[1983],"errorMessage":"total staked for all of a validators pools may not exceed hard cap","teal":2234},{"pc":[2033],"errorMessage":"No pool available with free stake.  Validator needs to add another pool","teal":2278},{"pc":[2093],"errorMessage":"poolKey.poolId as uint16 overflowed 16 bits","teal":2331},{"pc":[2236],"errorMessage":"global state value does not exist: AppID.fromUint64(pool1AppID).globalState('lastPayout')","teal":2480},{"pc":[2400],"errorMessage":"wideRatio failed","teal":2631},{"pc":[2470],"errorMessage":"argument 4 (poolKey) for stakeUpdatedViaRewards must be a (uint64,uint64,uint64)","teal":2705},{"pc":[2658],"errorMessage":"poolKey.poolId as uint16 overflowed 16 bits","teal":2871},{"pc":[2697],"errorMessage":"argument 0 (stakerRemoved) for stakeRemoved must be a bool","teal":2905},{"pc":[2716],"errorMessage":"argument 3 (staker) for stakeRemoved must be a address","teal":2925},{"pc":[2724],"errorMessage":"argument 4 (poolKey) for stakeRemoved must be a (uint64,uint64,uint64)","teal":2935},{"pc":[2782],"errorMessage":"should only be called if algo or reward was removed","teal":3005},{"pc":[2919],"errorMessage":"rewardRemoved can't be set if validator doesn't have reward token!","teal":3120},{"pc":[2939],"errorMessage":"reward being removed must be covered by hold back amount","teal":3142},{"pc":[3050],"errorMessage":"poolKey.poolId as uint16 overflowed 16 bits","teal":3251},{"pc":[3104],"errorMessage":"poolKey.poolId as uint16 overflowed 16 bits","teal":3301},{"pc":[3317],"errorMessage":"argument 1 (staker) for findPoolForStaker must be a address","teal":3491},{"pc":[3363],"errorMessage":"box value does not exist: this.stakerPoolSet(staker).value","teal":3558},{"pc":[3539],"errorMessage":"must stake at least the minimum for this pool","teal":3742},{"pc":[3728],"errorMessage":"node number out of allowable range","teal":3940},{"pc":[3781],"errorMessage":"can't move to same node","teal":4000},{"pc":[3855],"errorMessage":"couldn't find pool app id in nodes to move","teal":4080},{"pc":[3866],"errorMessage":"argument 0 (receiver) for emptyTokenRewards must be a address","teal":4096},{"pc":[3922],"errorMessage":"this validator doesn't have a reward token defined","teal":4166},{"pc":[3996],"errorMessage":"balance of remaining reward tokens should match the held back amount","teal":4243},{"pc":[4021],"errorMessage":"can only be called by validator owner","teal":4277},{"pc":[4060],"errorMessage":"can only be called by owner or manager of validator","teal":4316},{"pc":[4077],"errorMessage":"the specified validator id isn't valid","teal":4340},{"pc":[4086],"errorMessage":"pool id not in valid range","teal":4351},{"pc":[4124],"errorMessage":"pool id outside of range of pools created for this validator","teal":4384},{"pc":[4162],"errorMessage":"The passed in app id doesn't match the passed in ids","teal":4418},{"pc":[4202],"errorMessage":"global state value does not exist: AppID.fromUint64(poolKey.poolAppId).globalState('validatorId')","teal":4443},{"pc":[4226],"errorMessage":"global state value does not exist: AppID.fromUint64(poolKey.poolAppId).globalState('poolId')","teal":4459},{"pc":[4274],"errorMessage":"global state value does not exist: AppID.fromUint64(validatorConfig.nfdForInfo).globalState('i.owner.a')","teal":4517},{"pc":[4356],"errorMessage":"sender must be owner to add new validator","teal":4595},{"pc":[4379],"errorMessage":"gating type not valid","teal":4618},{"pc":[4402],"errorMessage":"epoch length not in allowable range","teal":4641},{"pc":[4425],"errorMessage":"commission percentage not valid","teal":4664},{"pc":[4445],"errorMessage":"validatorCommissionAddress must be set if percent to validator is not 0","teal":4688},{"pc":[4455],"errorMessage":"staking pool must have minimum entry of 1 algo","teal":4700},{"pc":[4478],"errorMessage":"number of pools per node must be be between 1 and the maximum allowed number","teal":4723},{"pc":[4499],"errorMessage":"sunsettingOn must be later than now if set","teal":4745},{"pc":[4633],"errorMessage":"global state value does not exist: AppID.fromUint64(poolAppId).globalState('numStakers')","teal":4894},{"pc":[4641],"errorMessage":"global state value does not exist: AppID.fromUint64(poolAppId).globalState('staked')","teal":4904},{"pc":[4834],"errorMessage":"box value does not exist: this.stakerPoolSet(staker).value","teal":5077},{"pc":[4913],"errorMessage":"No empty slot available in the staker pool set","teal":5171},{"pc":[4950],"errorMessage":"box value does not exist: this.stakerPoolSet(staker).value","teal":5227},{"pc":[5088],"errorMessage":"No matching slot found when told to remove a pool from the stakers set","teal":5352},{"pc":[5156],"errorMessage":"node number not in valid range","teal":5423},{"pc":[5230],"errorMessage":"no available space in specified node for this pool","teal":5504},{"pc":[5343],"errorMessage":"must have required minimum balance of validator defined token to add stake","teal":5640},{"pc":[5362],"errorMessage":"specified asset must be created by creator that the validator defined as a requirement to stake","teal":5665},{"pc":[5432],"errorMessage":"specified asset must be identical to the asset id defined as a requirement to stake","teal":5736},{"pc":[5455],"errorMessage":"specified asset must be created by creator that is one of the linked addresses in an nfd","teal":5762},{"pc":[5473],"errorMessage":"provided NFD must be valid","teal":5785},{"pc":[5479],"errorMessage":"global state value does not exist: AppID.fromUint64(userOfferedNFDAppID).globalState('i.owner.a')","teal":5798},{"pc":[5495],"errorMessage":"provided nfd for entry isn't owned or linked to the staker","teal":5810},{"pc":[5514],"errorMessage":"global state value does not exist: AppID.fromUint64(userOfferedNFDAppID).globalState('i.parentAppID')","teal":5823},{"pc":[5523],"errorMessage":"specified nfd must be a segment of the nfd the validator specified as a requirement","teal":5831},{"pc":[5540],"errorMessage":"global state value does not exist: AppID.fromUint64(nfdAppID).globalState('i.name')","teal":5858},{"pc":[5733],"errorMessage":"wideRatio failed","teal":6056},{"pc":[5760],"errorMessage":"wideRatio failed","teal":6091},{"pc":[5885],"errorMessage":"this contract does not implement the given ABI method for create NoOp","teal":6219},{"pc":[6155],"errorMessage":"this contract does not implement the given ABI method for call NoOp","teal":6259}],"pcOffsetMethod":"cblocks"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDExCmludGNibG9jayAwIDEgOCAyNCAxOCAyNjggMzIgNiAzIDI0MiAyIDEwIDI1MiAyNjAgNzAwIDQgMTAwMDAwIDkwMCAxNiAyMDAgNDAgNzIgMTkyIDI0NCAxMDAwMDAwIDQwOTYgNSAyMjYgVE1QTF9uZmRSZWdpc3RyeUFwcElkIDMwMCA0MzIgODkyIDEwMDAgMjg1MDAgNTAwMDAgMTEgODAgMTQ1IDE1MyAyMDkKYnl0ZWNibG9jayAweDc2IDB4IDB4MTUxZjdjNzUgMHg3MzcwNzMgMHg3Mzc0NjE2YjY1NjQgMHgwMCAweDZlNzU2ZDUzNzQ2MTZiNjU3MjczIDB4MDAwMDAwMDAwMDAwMDAwMCAweDBhODEwMSAweDcwNmY2ZjZjNTQ2NTZkNzA2YzYxNzQ2NTQxNzA3MDcyNmY3NjYxNmM0Mjc5NzQ2NTczIDB4NjkyZTZmNzc2ZTY1NzIyZTYxIDB4NmU3NTZkNTYgMHg2OTZlNjk3NCAweDYzZjNmMjhiIDB4MTJmNGJkNGIKCi8vIFRoaXMgVEVBTCB3YXMgZ2VuZXJhdGVkIGJ5IFRFQUxTY3JpcHQgdjAuMTA1LjQKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludGMgNyAvLyA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CgkvLyBleGVjdXRlIGNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkCgljYWxsc3ViIGNyZWF0ZUFwcGxpY2F0aW9uCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpOiB2b2lkCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODIKCS8vIHRoaXMuc3Rha2luZ1Bvb2xJbml0aWFsaXplZC52YWx1ZSA9IGZhbHNlCglieXRlYyAxMiAvLyAgImluaXQiCglpbnRjIDAgLy8gMAoJYnl0ZWMgNSAvLyAweDAwCglpbnRjIDAgLy8gMAoJdW5jb3ZlciAyCglzZXRiaXQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODMKCS8vIHRoaXMubnVtVmFsaWRhdG9ycy52YWx1ZSA9IDAKCWJ5dGVjIDExIC8vICAibnVtViIKCWludGMgMCAvLyAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg0CgkvLyB0aGlzLm51bVN0YWtlcnMudmFsdWUgPSAwCglieXRlYyA2IC8vICAibnVtU3Rha2VycyIKCWludGMgMCAvLyAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg1CgkvLyB0aGlzLnRvdGFsQWxnb1N0YWtlZC52YWx1ZSA9IDAKCWJ5dGVjIDQgLy8gICJzdGFrZWQiCglpbnRjIDAgLy8gMAoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gaW5pdFN0YWtpbmdDb250cmFjdCh1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2luaXRTdGFraW5nQ29udHJhY3Q6CgkvLyBhcHByb3ZhbFByb2dyYW1TaXplOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGluaXRTdGFraW5nQ29udHJhY3QodWludDY0KXZvaWQKCWNhbGxzdWIgaW5pdFN0YWtpbmdDb250cmFjdAoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gaW5pdFN0YWtpbmdDb250cmFjdChhcHByb3ZhbFByb2dyYW1TaXplOiB1aW50NjQpOiB2b2lkCmluaXRTdGFraW5nQ29udHJhY3Q6Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MAoJLy8gdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5jcmVhdGUoYXBwcm92YWxQcm9ncmFtU2l6ZSkKCWJ5dGVjIDkgLy8gICJwb29sVGVtcGxhdGVBcHByb3ZhbEJ5dGVzIgoJZnJhbWVfZGlnIC0xIC8vIGFwcHJvdmFsUHJvZ3JhbVNpemU6IHVpbnQ2NAoJYm94X2NyZWF0ZQoJcG9wCglyZXRzdWIKCi8vIGxvYWRTdGFraW5nQ29udHJhY3REYXRhKHVpbnQ2NCxieXRlW10pdm9pZAoqYWJpX3JvdXRlX2xvYWRTdGFraW5nQ29udHJhY3REYXRhOgoJLy8gZGF0YTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIG9mZnNldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBsb2FkU3Rha2luZ0NvbnRyYWN0RGF0YSh1aW50NjQsYnl0ZVtdKXZvaWQKCWNhbGxzdWIgbG9hZFN0YWtpbmdDb250cmFjdERhdGEKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGxvYWRTdGFraW5nQ29udHJhY3REYXRhKG9mZnNldDogdWludDY0LCBkYXRhOiBieXRlcyk6IHZvaWQKbG9hZFN0YWtpbmdDb250cmFjdERhdGE6Cglwcm90byAyIDAKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5NAoJLy8gYXNzZXJ0KCF0aGlzLnN0YWtpbmdQb29sSW5pdGlhbGl6ZWQudmFsdWUpCglieXRlYyAxMiAvLyAgImluaXQiCglhcHBfZ2xvYmFsX2dldAoJaW50YyAwIC8vIDAKCWdldGJpdAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTUKCS8vIHRoaXMuc3Rha2luZ1Bvb2xBcHByb3ZhbFByb2dyYW0ucmVwbGFjZShvZmZzZXQsIGRhdGEpCglieXRlYyA5IC8vICAicG9vbFRlbXBsYXRlQXBwcm92YWxCeXRlcyIKCWZyYW1lX2RpZyAtMSAvLyBvZmZzZXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIGRhdGE6IGJ5dGVzCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBmaW5hbGl6ZVN0YWtpbmdDb250cmFjdCgpdm9pZAoqYWJpX3JvdXRlX2ZpbmFsaXplU3Rha2luZ0NvbnRyYWN0OgoJLy8gZXhlY3V0ZSBmaW5hbGl6ZVN0YWtpbmdDb250cmFjdCgpdm9pZAoJY2FsbHN1YiBmaW5hbGl6ZVN0YWtpbmdDb250cmFjdAoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZmluYWxpemVTdGFraW5nQ29udHJhY3QoKTogdm9pZApmaW5hbGl6ZVN0YWtpbmdDb250cmFjdDoKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk5CgkvLyB0aGlzLnN0YWtpbmdQb29sSW5pdGlhbGl6ZWQudmFsdWUgPSB0cnVlCglieXRlYyAxMiAvLyAgImluaXQiCglpbnRjIDEgLy8gMQoJYnl0ZWMgNSAvLyAweDAwCglpbnRjIDAgLy8gMAoJdW5jb3ZlciAyCglzZXRiaXQKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdhcygpdm9pZAoqYWJpX3JvdXRlX2dhczoKCS8vIGV4ZWN1dGUgZ2FzKCl2b2lkCgljYWxsc3ViIGdhcwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2FzKCk6IHZvaWQKLy8KLy8gZ2FzIGlzIGEgZHVtbXkgbm8tb3AgY2FsbCB0aGF0IGNhbiBiZSB1c2VkIHRvIHBvb2wtdXAgcmVzb3VyY2UgcmVmZXJlbmNlcyBhbmQgb3Bjb2RlIGNvc3QKZ2FzOgoJcHJvdG8gMCAwCglyZXRzdWIKCi8vIGdldE1ickFtb3VudHMoKSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCiphYmlfcm91dGVfZ2V0TWJyQW1vdW50czoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBnZXRNYnJBbW91bnRzKCkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJY2FsbHN1YiBnZXRNYnJBbW91bnRzCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0TWJyQW1vdW50cygpOiBNYnJBbW91bnRzCi8vCi8vIFJldHVybnMgdGhlIE1CUiBhbW91bnRzIG5lZWRlZCBmb3IgdmFyaW91cyBhY3Rpb25zOgovLyBbCi8vIGFkZFZhbGlkYXRvck1icjogdWludDY0IC0gbWJyIG5lZWRlZCB0byBhZGQgYSBuZXcgdmFsaWRhdG9yIC0gcGFpZCB0byB2YWxpZGF0b3IgY29udHJhY3QKLy8gYWRkUG9vbE1icjogdWludDY0IC0gbWJyIG5lZWRlZCB0byBhZGQgYSBuZXcgcG9vbCAtIHBhaWQgdG8gdmFsaWRhdG9yCi8vIHBvb2xJbml0TWJyOiB1aW50NjQgLSBtYnIgbmVlZGVkIHRvIGluaXRTdG9yYWdlKCkgb2YgcG9vbCAtIHBhaWQgdG8gcG9vbCBpdHNlbGYKLy8gYWRkU3Rha2VyTWJyOiB1aW50NjQgLSBtYnIgc3Rha2VyIG5lZWRzIHRvIGFkZCB0byBmaXJzdCBzdGFraW5nIHBheW1lbnQgKHN0YXlzIHcvIHZhbGlkYXRvcikKLy8gXQpnZXRNYnJBbW91bnRzOgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIwCgkvLyByZXR1cm4gewoJLy8gICAgICAgICAgICAgYWRkVmFsaWRhdG9yTWJyOiB0aGlzLmNvc3RGb3JCb3hTdG9yYWdlKDEgLyogdiBwcmVmaXggKi8gKyBsZW48VmFsaWRhdG9ySWRUeXBlPigpICsgbGVuPFZhbGlkYXRvckluZm8+KCkpLAoJLy8gICAgICAgICAgICAgYWRkUG9vbE1icjogdGhpcy5taW5CYWxhbmNlRm9yQWNjb3VudCgKCS8vICAgICAgICAgICAgICAgICAxLAoJLy8gICAgICAgICAgICAgICAgIC8vIHdlIGNvdWxkIGNhbGN1bGF0ZSB0aGlzIGRpcmVjdGx5IGJ5IHJlZmVyZW5jaW5nIHRoZSBzaXplIG9mIHN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtIGJ1dCBpdCB3b3VsZAoJLy8gICAgICAgICAgICAgICAgIC8vIG1lYW4gb3VyIGNhbGxlcnMgd291bGQgaGF2ZSB0byByZWZlcmVuY2UgdGhlIGJveCBBTkQgYnV5IHVwIGkvbyAtIHNvIGp1c3QgZ28gbWF4IG9uIGV4dHJhIHBhZ2VzCgkvLyAgICAgICAgICAgICAgICAgMywKCS8vICAgICAgICAgICAgICAgICAwLAoJLy8gICAgICAgICAgICAgICAgIDAsCgkvLyAgICAgICAgICAgICAgICAgMCwKCS8vICAgICAgICAgICAgICAgICBTdGFraW5nUG9vbC5zY2hlbWEuZ2xvYmFsLm51bVVpbnQsCgkvLyAgICAgICAgICAgICAgICAgU3Rha2luZ1Bvb2wuc2NoZW1hLmdsb2JhbC5udW1CeXRlU2xpY2UsCgkvLyAgICAgICAgICAgICApLAoJLy8gICAgICAgICAgICAgcG9vbEluaXRNYnI6CgkvLyAgICAgICAgICAgICAgICAgQUxHT1JBTkRfQUNDT1VOVF9NSU5fQkFMQU5DRSArCgkvLyAgICAgICAgICAgICAgICAgdGhpcy5jb3N0Rm9yQm94U3RvcmFnZSg3IC8qICdzdGFrZXJzJyBuYW1lICovICsgbGVuPFN0YWtlZEluZm8+KCkgKiBNQVhfU1RBS0VSU19QRVJfUE9PTCksCgkvLyAgICAgICAgICAgICBhZGRTdGFrZXJNYnI6CgkvLyAgICAgICAgICAgICAgICAgLy8gaG93IG11Y2ggdG8gY2hhcmdlIGZvciBmaXJzdCB0aW1lIGEgc3Rha2VyIGFkZHMgc3Rha2UgLSBzaW5jZSB3ZSBhZGQgYSB0cmFja2luZyBib3ggcGVyIHN0YWtlcgoJLy8gICAgICAgICAgICAgICAgIHRoaXMuY29zdEZvckJveFN0b3JhZ2UoCgkvLyAgICAgICAgICAgICAgICAgICAgIDMgLyogJ3NwcycgcHJlZml4ICovICsgbGVuPEFkZHJlc3M+KCkgKyBsZW48VmFsaWRhdG9yUG9vbEtleT4oKSAqIE1BWF9QT09MU19QRVJfU1RBS0VSLAoJLy8gICAgICAgICAgICAgICAgICksIC8vIHNpemUgb2Yga2V5ICsgYWxsIHZhbHVlcwoJLy8gICAgICAgICB9CglwdXNoaW50IDExMDEKCWNhbGxzdWIgY29zdEZvckJveFN0b3JhZ2UKCWl0b2IKCWludGMgOCAvLyAzCglpbnRjIDM1IC8vIDExCglpbnRjIDAgLy8gMAoJZHVwbiAyCglpbnRjIDggLy8gMwoJaW50YyAxIC8vIDEKCWNhbGxzdWIgbWluQmFsYW5jZUZvckFjY291bnQKCWl0b2IKCWNvbmNhdAoJaW50YyAxNiAvLyAxMDAwMDAKCXB1c2hpbnQgMTI4MDcKCWNhbGxzdWIgY29zdEZvckJveFN0b3JhZ2UKCSsKCWl0b2IKCWNvbmNhdAoJcHVzaGludCAxNzkKCWNhbGxzdWIgY29zdEZvckJveFN0b3JhZ2UKCWl0b2IKCWNvbmNhdAoJcmV0c3ViCgovLyBnZXRQcm90b2NvbENvbnN0cmFpbnRzKCkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKKmFiaV9yb3V0ZV9nZXRQcm90b2NvbENvbnN0cmFpbnRzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGdldFByb3RvY29sQ29uc3RyYWludHMoKSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJY2FsbHN1YiBnZXRQcm90b2NvbENvbnN0cmFpbnRzCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0UHJvdG9jb2xDb25zdHJhaW50cygpOiBDb25zdHJhaW50cwovLwovLyBSZXR1cm5zIHRoZSBwcm90b2NvbCBjb25zdHJhaW50cyBzbyB0aGF0IFVJcyBjYW4gbGltaXQgd2hhdCB1c2VycyBzcGVjaWZ5IGZvciB2YWxpZGF0b3IgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzLgpnZXRQcm90b2NvbENvbnN0cmFpbnRzOgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTQ5CgkvLyByZXR1cm4gewoJLy8gICAgICAgICAgICAgZXBvY2hQYXlvdXRSb3VuZHNNaW46IE1JTl9FUE9DSF9MRU5HVEgsCgkvLyAgICAgICAgICAgICBlcG9jaFBheW91dFJvdW5kc01heDogTUFYX0VQT0NIX0xFTkdUSCwKCS8vICAgICAgICAgICAgIG1pblBjdFRvVmFsaWRhdG9yV0ZvdXJEZWNpbWFsczogTUlOX1BDVF9UT19WQUxJREFUT1IsCgkvLyAgICAgICAgICAgICBtYXhQY3RUb1ZhbGlkYXRvcldGb3VyRGVjaW1hbHM6IE1BWF9QQ1RfVE9fVkFMSURBVE9SLAoJLy8gICAgICAgICAgICAgbWluRW50cnlTdGFrZTogTUlOX0FMR09fU1RBS0VfUEVSX1BPT0wsCgkvLyAgICAgICAgICAgICBtYXhBbGdvUGVyUG9vbDogdGhpcy5tYXhBbGdvQWxsb3dlZFBlclBvb2woKSwKCS8vICAgICAgICAgICAgIG1heEFsZ29QZXJWYWxpZGF0b3I6IHRoaXMubWF4QWxsb3dlZFN0YWtlKCksCgkvLyAgICAgICAgICAgICBhbXRDb25zaWRlcmVkU2F0dXJhdGVkOiB0aGlzLmFsZ29TYXR1cmF0aW9uTGV2ZWwoKSwKCS8vICAgICAgICAgICAgIG1heE5vZGVzOiBNQVhfTk9ERVMsCgkvLyAgICAgICAgICAgICBtYXhQb29sc1Blck5vZGU6IE1BWF9QT09MU19QRVJfTk9ERSwKCS8vICAgICAgICAgICAgIG1heFN0YWtlcnNQZXJQb29sOiBNQVhfU1RBS0VSU19QRVJfUE9PTCwKCS8vICAgICAgICAgfQoJcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwZjQyNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmNDI0MDAwMDAwMDAwMDAwZjQyNDAKCWNhbGxzdWIgbWF4QWxnb0FsbG93ZWRQZXJQb29sCglpdG9iCgljb25jYXQKCWNhbGxzdWIgbWF4QWxsb3dlZFN0YWtlCglpdG9iCgljb25jYXQKCWNhbGxzdWIgYWxnb1NhdHVyYXRpb25MZXZlbAoJaXRvYgoJY29uY2F0CglwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDAwMDA4Cgljb25jYXQKCXB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDMKCWNvbmNhdAoJcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDBjOAoJY29uY2F0CglyZXRzdWIKCi8vIGdldE51bVZhbGlkYXRvcnMoKXVpbnQ2NAoqYWJpX3JvdXRlX2dldE51bVZhbGlkYXRvcnM6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgZ2V0TnVtVmFsaWRhdG9ycygpdWludDY0CgljYWxsc3ViIGdldE51bVZhbGlkYXRvcnMKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBnZXROdW1WYWxpZGF0b3JzKCk6IHVpbnQ2NAovLwovLyBSZXR1cm5zIHRoZSBjdXJyZW50IG51bWJlciBvZiB2YWxpZGF0b3JzCmdldE51bVZhbGlkYXRvcnM6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxNjkKCS8vIHJldHVybiB0aGlzLm51bVZhbGlkYXRvcnMudmFsdWUKCWJ5dGVjIDExIC8vICAibnVtViIKCWFwcF9nbG9iYWxfZ2V0CglyZXRzdWIKCi8vIGdldFZhbGlkYXRvckNvbmZpZyh1aW50NjQpKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCiphYmlfcm91dGVfZ2V0VmFsaWRhdG9yQ29uZmlnOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBnZXRWYWxpZGF0b3JDb25maWcodWludDY0KSh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoJY2FsbHN1YiBnZXRWYWxpZGF0b3JDb25maWcKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBnZXRWYWxpZGF0b3JDb25maWcodmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSk6IFZhbGlkYXRvckNvbmZpZwpnZXRWYWxpZGF0b3JDb25maWc6Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxNzQKCS8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZwoJaW50YyAwIC8vIDAKCWludGMgOSAvLyAyNDIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCXJldHN1YgoKLy8gZ2V0VmFsaWRhdG9yU3RhdGUodWludDY0KSh1aW50MTYsdWludDY0LHVpbnQ2NCx1aW50NjQpCiphYmlfcm91dGVfZ2V0VmFsaWRhdG9yU3RhdGU6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIHZhbGlkYXRvcklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGdldFZhbGlkYXRvclN0YXRlKHVpbnQ2NCkodWludDE2LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJY2FsbHN1YiBnZXRWYWxpZGF0b3JTdGF0ZQoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldFZhbGlkYXRvclN0YXRlKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUpOiBWYWxpZGF0b3JDdXJTdGF0ZQpnZXRWYWxpZGF0b3JTdGF0ZToKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE3OQoJLy8gcmV0dXJuIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuc3RhdGUKCWludGMgOSAvLyAgaGVhZE9mZnNldAoJcHVzaGludCAyNgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJcmV0c3ViCgovLyBnZXRWYWxpZGF0b3JPd25lckFuZE1hbmFnZXIodWludDY0KShhZGRyZXNzLGFkZHJlc3MpCiphYmlfcm91dGVfZ2V0VmFsaWRhdG9yT3duZXJBbmRNYW5hZ2VyOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBnZXRWYWxpZGF0b3JPd25lckFuZE1hbmFnZXIodWludDY0KShhZGRyZXNzLGFkZHJlc3MpCgljYWxsc3ViIGdldFZhbGlkYXRvck93bmVyQW5kTWFuYWdlcgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldFZhbGlkYXRvck93bmVyQW5kTWFuYWdlcih2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlKTogW0FkZHJlc3MsIEFkZHJlc3NdCmdldFZhbGlkYXRvck93bmVyQW5kTWFuYWdlcjoKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE4NAoJLy8gcmV0dXJuIFsKCS8vICAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm93bmVyLAoJLy8gICAgICAgICAgICAgdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcubWFuYWdlciwKCS8vICAgICAgICAgXQoJaW50YyAyIC8vIDgKCWludGMgNiAvLyAzMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJaW50YyAyMCAvLyA0MAoJaW50YyA2IC8vIDMyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0Cgljb25jYXQKCXJldHN1YgoKLy8gZ2V0UG9vbHModWludDY0KSh1aW50NjQsdWludDE2LHVpbnQ2NClbXQoqYWJpX3JvdXRlX2dldFBvb2xzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBnZXRQb29scyh1aW50NjQpKHVpbnQ2NCx1aW50MTYsdWludDY0KVtdCgljYWxsc3ViIGdldFBvb2xzCglkdXAKCWxlbgoJaW50YyA0IC8vIDE4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0UG9vbHModmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSk6IFBvb2xJbmZvW10KLy8KLy8gUmV0dXJuIGxpc3Qgb2YgYWxsIHBvb2xzIGZvciB0aGlzIHZhbGlkYXRvci4KLy8gQHBhcmFtIHt1aW50NjR9IHZhbGlkYXRvcklkCi8vIEByZXR1cm4ge1Bvb2xJbmZvW119IC0gYXJyYXkgb2YgcG9vbHMKLy8gTm90IGNhbGxhYmxlIGZyb20gb3RoZXIgY29udHJhY3RzIGJlY2F1c2UgPjFLIHJldHVybiBidXQgY2FuIGJlIGNhbGxlZCB3LyBzaW11bGF0ZSB3aGljaCBidW1wcyBsb2cgcmV0dXJucwpnZXRQb29sczoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXBuIDIKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxOTgKCS8vIHJldERhdGE6IFBvb2xJbmZvW10gPSBbXQoJYnl0ZWMgMSAvLyAweAoJZnJhbWVfYnVyeSAwIC8vIHJldERhdGE6IFBvb2xJbmZvW10KCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxOTkKCS8vIHBvb2xTZXQgPSBjbG9uZSh0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnBvb2xzKQoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglpbnRjIDMwIC8vIDQzMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJZnJhbWVfYnVyeSAxIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDE2LHVpbnQ2NClbMjRdCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjAwCgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IHBvb2xTZXQubGVuZ3RoOyBpICs9IDEpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoKKmZvcl8wOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjAwCgkvLyBpIDwgcG9vbFNldC5sZW5ndGgKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDI0Cgk8CglieiAqZm9yXzBfZW5kCgoJLy8gKmlmMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIwMQoJLy8gcG9vbFNldFtpXS5wb29sQXBwSWQgPT09IDAKCWZyYW1lX2RpZyAxIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDE2LHVpbnQ2NClbMjRdCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDAgLy8gMAoJKwoJaW50YyAyIC8vIDgKCWV4dHJhY3QzCglidG9pCglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjBfZW5kCgoJLy8gKmlmMF9jb25zZXF1ZW50CgliICpmb3JfMF9lbmQKCippZjBfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjA1CgkvLyByZXREYXRhLnB1c2gocG9vbFNldFtpXSkKCWZyYW1lX2RpZyAwIC8vIHJldERhdGE6IFBvb2xJbmZvW10KCWZyYW1lX2RpZyAxIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDE2LHVpbnQ2NClbMjRdCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDQgLy8gMTgKCWV4dHJhY3QzCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyByZXREYXRhOiBQb29sSW5mb1tdCgoqZm9yXzBfY29udGludWU6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMDAKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzAKCipmb3JfMF9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMDcKCS8vIHJldHVybiByZXREYXRhCglmcmFtZV9kaWcgMCAvLyByZXREYXRhOiBQb29sSW5mb1tdCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMgoJcmV0c3ViCgovLyBnZXRQb29sQXBwSWQodWludDY0LHVpbnQ2NCl1aW50NjQKKmFiaV9yb3V0ZV9nZXRQb29sQXBwSWQ6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIHBvb2xJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgZ2V0UG9vbEFwcElkKHVpbnQ2NCx1aW50NjQpdWludDY0CgljYWxsc3ViIGdldFBvb2xBcHBJZAoJaXRvYgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldFBvb2xBcHBJZCh2YWxpZGF0b3JJZDogdWludDY0LCBwb29sSWQ6IHVpbnQ2NCk6IHVpbnQ2NAovLwovLyBnZXRQb29sQXBwSWQgaXMgdXNlZnVsIGZvciBjYWxsZXJzIHRvIGRldGVybWluZSBhcHAgdG8gY2FsbCBmb3IgcmVtb3Zpbmcgc3Rha2UgaWYgdGhleSBkb24ndCBoYXZlIHN0YWtpbmcgb3IKLy8gd2FudCB0byBnZXQgc3Rha2VyIGxpc3QgZm9yIGFuIGFjY291bnQuICBUaGUgc3Rha2luZyBwb29sIGFsc28gdXNlcyBpdCB0byBnZXQgdGhlIGFwcCBpZCBvZiBzdGFraW5nIHBvb2wgMQovLyAod2hpY2ggY29udGFpbnMgcmV3YXJkIHRva2VucyBpZiBiZWluZyB1c2VkKSBzbyB0aGF0IHRoZSBhbW91bnQgYXZhaWxhYmxlIGNhbiBiZSBkZXRlcm1pbmVkLgpnZXRQb29sQXBwSWQ6Cglwcm90byAyIDEKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMTcKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIHBvb2xJZCAhPT0gMCAmJiBwb29sSWQgPD0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29scy5sZW5ndGgsCgkvLyAgICAgICAgICAgICAncG9vbCBpZCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgbnVtYmVyIG9mIHBvb2xzIGZvciB0aGlzIHZhbGlkYXRvcicsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAtMiAvLyBwb29sSWQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCSE9CglkdXAKCWJ6ICpza2lwX2FuZDAKCWZyYW1lX2RpZyAtMiAvLyBwb29sSWQ6IHVpbnQ2NAoJaW50YyAzIC8vIDI0Cgk8PQoJJiYKCipza2lwX2FuZDA6CgkvLyBwb29sIGlkIG11c3QgYmUgYmV0d2VlbiAxIGFuZCBudW1iZXIgb2YgcG9vbHMgZm9yIHRoaXMgdmFsaWRhdG9yCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMjEKCS8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnBvb2xzW3Bvb2xJZCAtIDFdLnBvb2xBcHBJZAoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTIgLy8gcG9vbElkOiB1aW50NjQKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAwIC8vIDAKCSsKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogdWludDY0CglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglyZXRzdWIKCi8vIGdldFBvb2xJbmZvKCh1aW50NjQsdWludDY0LHVpbnQ2NCkpKHVpbnQ2NCx1aW50MTYsdWludDY0KQoqYWJpX3JvdXRlX2dldFBvb2xJbmZvOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyBwb29sS2V5OiAodWludDY0LHVpbnQ2NCx1aW50NjQpCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50YyAzIC8vIDI0Cgk9PQoKCS8vIGFyZ3VtZW50IDAgKHBvb2xLZXkpIGZvciBnZXRQb29sSW5mbyBtdXN0IGJlIGEgKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBnZXRQb29sSW5mbygodWludDY0LHVpbnQ2NCx1aW50NjQpKSh1aW50NjQsdWludDE2LHVpbnQ2NCkKCWNhbGxzdWIgZ2V0UG9vbEluZm8KCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBnZXRQb29sSW5mbyhwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5KTogUG9vbEluZm8KZ2V0UG9vbEluZm86Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMjYKCS8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXQoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyA0IC8vIDE4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJcmV0c3ViCgovLyBnZXRDdXJNYXhTdGFrZVBlclBvb2wodWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX2dldEN1ck1heFN0YWtlUGVyUG9vbDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgZ2V0Q3VyTWF4U3Rha2VQZXJQb29sKHVpbnQ2NCl1aW50NjQKCWNhbGxzdWIgZ2V0Q3VyTWF4U3Rha2VQZXJQb29sCglpdG9iCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0Q3VyTWF4U3Rha2VQZXJQb29sKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUpOiB1aW50NjQKLy8KLy8gQ2FsY3VsYXRlIHRoZSBtYXhpbXVtIHN0YWtlIHBlciBwb29sIGZvciBhIGdpdmVuIHZhbGlkYXRvci4KLy8gTm9ybWFsbHkgdGhpcyB3b3VsZCBiZSBtYXhBbGdvUGVyUG9vbCwgYnV0IGl0IHNob3VsZCBhbHNvIG5ldmVyIGdvIGFib3ZlIE1heEFsbG93ZWRTdGFrZSAvIG51bVBvb2xzIHNvCi8vIGFzIHBvb2xzIGFyZSBhZGRlZCB0aGUgbWF4IGFsbG93ZWQgcGVyIHBvb2wgY2FuIHJlZHVjZS4KLy8KLy8gQHBhcmFtIHtWYWxpZGF0b3JJZFR5cGV9IHZhbGlkYXRvcklkIC0gVGhlIGlkIG9mIHRoZSB2YWxpZGF0b3IuCmdldEN1ck1heFN0YWtlUGVyUG9vbDoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXBuIDIKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMzgKCS8vIG51bVBvb2xzID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5zdGF0ZS5udW1Qb29scyBhcyB1aW50NjQKCWludGMgOSAvLyAyNDIKCWludGMgMTAgLy8gMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAwIC8vIG51bVBvb2xzOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMzkKCS8vIGhhcmRNYXhEaXZpZGVkQmV0d2VlblBvb2xzID0gdGhpcy5tYXhBbGxvd2VkU3Rha2UoKSAvIG51bVBvb2xzCgljYWxsc3ViIG1heEFsbG93ZWRTdGFrZQoJZnJhbWVfZGlnIDAgLy8gbnVtUG9vbHM6IHVpbnQ2NAoJLwoJZnJhbWVfYnVyeSAxIC8vIGhhcmRNYXhEaXZpZGVkQmV0d2VlblBvb2xzOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNDAKCS8vIG1heFBlclBvb2w6IHVpbnQ2NCA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1heEFsZ29QZXJQb29sCglwdXNoaW50IDIxNwoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgMiAvLyBtYXhQZXJQb29sOiB1aW50NjQKCgkvLyAqaWYxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjQxCgkvLyBtYXhQZXJQb29sID09PSAwCglmcmFtZV9kaWcgMiAvLyBtYXhQZXJQb29sOiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmMV9lbmQKCgkvLyAqaWYxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI0MgoJLy8gbWF4UGVyUG9vbCA9IHRoaXMubWF4QWxnb0FsbG93ZWRQZXJQb29sKCkKCWNhbGxzdWIgbWF4QWxnb0FsbG93ZWRQZXJQb29sCglmcmFtZV9idXJ5IDIgLy8gbWF4UGVyUG9vbDogdWludDY0CgoqaWYxX2VuZDoKCS8vICppZjJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNDQKCS8vIGhhcmRNYXhEaXZpZGVkQmV0d2VlblBvb2xzIDwgbWF4UGVyUG9vbAoJZnJhbWVfZGlnIDEgLy8gaGFyZE1heERpdmlkZWRCZXR3ZWVuUG9vbHM6IHVpbnQ2NAoJZnJhbWVfZGlnIDIgLy8gbWF4UGVyUG9vbDogdWludDY0Cgk8CglieiAqaWYyX2VuZAoKCS8vICppZjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjQ1CgkvLyBtYXhQZXJQb29sID0gaGFyZE1heERpdmlkZWRCZXR3ZWVuUG9vbHMKCWZyYW1lX2RpZyAxIC8vIGhhcmRNYXhEaXZpZGVkQmV0d2VlblBvb2xzOiB1aW50NjQKCWZyYW1lX2J1cnkgMiAvLyBtYXhQZXJQb29sOiB1aW50NjQKCippZjJfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjQ3CgkvLyByZXR1cm4gbWF4UGVyUG9vbAoJZnJhbWVfZGlnIDIgLy8gbWF4UGVyUG9vbDogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMgoJcmV0c3ViCgovLyBkb2VzU3Rha2VyTmVlZFRvUGF5TUJSKGFkZHJlc3MpYm9vbAoqYWJpX3JvdXRlX2RvZXNTdGFrZXJOZWVkVG9QYXlNQlI6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIHN0YWtlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgNiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChzdGFrZXIpIGZvciBkb2VzU3Rha2VyTmVlZFRvUGF5TUJSIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIGRvZXNTdGFrZXJOZWVkVG9QYXlNQlIoYWRkcmVzcylib29sCgljYWxsc3ViIGRvZXNTdGFrZXJOZWVkVG9QYXlNQlIKCWJ5dGVjIDUgLy8gMHgwMAoJaW50YyAwIC8vIDAKCXVuY292ZXIgMgoJc2V0Yml0Cgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZG9lc1N0YWtlck5lZWRUb1BheU1CUihzdGFrZXI6IEFkZHJlc3MpOiBib29sZWFuCi8vCi8vIEhlbHBlciBjYWxsZXJzIGNhbiBjYWxsIHcvIHNpbXVsYXRlIHRvIGRldGVybWluZSBpZiAnQWRkU3Rha2VyJyBNQlIgc2hvdWxkIGJlIGluY2x1ZGVkIHcvIHN0YWtpbmcgYW1vdW50Ci8vIEBwYXJhbSBzdGFrZXIKZG9lc1N0YWtlck5lZWRUb1BheU1CUjoKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI1NgoJLy8gcmV0dXJuICF0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS5leGlzdHMKCWJ5dGVjIDMgLy8gICJzcHMiCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VyOiBBZGRyZXNzCgljb25jYXQKCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJcmV0c3ViCgovLyBnZXRTdGFrZWRQb29sc0ZvckFjY291bnQoYWRkcmVzcykodWludDY0LHVpbnQ2NCx1aW50NjQpW10KKmFiaV9yb3V0ZV9nZXRTdGFrZWRQb29sc0ZvckFjY291bnQ6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIHN0YWtlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgNiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChzdGFrZXIpIGZvciBnZXRTdGFrZWRQb29sc0ZvckFjY291bnQgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGV4ZWN1dGUgZ2V0U3Rha2VkUG9vbHNGb3JBY2NvdW50KGFkZHJlc3MpKHVpbnQ2NCx1aW50NjQsdWludDY0KVtdCgljYWxsc3ViIGdldFN0YWtlZFBvb2xzRm9yQWNjb3VudAoJZHVwCglsZW4KCWludGMgMyAvLyAyNAoJLwoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldFN0YWtlZFBvb2xzRm9yQWNjb3VudChzdGFrZXI6IEFkZHJlc3MpOiBWYWxpZGF0b3JQb29sS2V5W10KLy8KLy8gUmV0cmlldmVzIHRoZSBzdGFrZWQgcG9vbHMgZm9yIGFuIGFjY291bnQuCi8vCi8vIEBwYXJhbSB7QWRkcmVzc30gc3Rha2VyIC0gVGhlIGFjY291bnQgdG8gcmV0cmlldmUgc3Rha2VkIHBvb2xzIGZvci4KLy8gQHJldHVybiB7VmFsaWRhdG9yUG9vbEtleVtdfSAtIFRoZSBhcnJheSBvZiBzdGFrZWQgcG9vbHMgZm9yIHRoZSBhY2NvdW50LgpnZXRTdGFrZWRQb29sc0ZvckFjY291bnQ6Cglwcm90byAxIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiAyCgoJLy8gKmlmM19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI2NwoJLy8gIXRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLmV4aXN0cwoJYnl0ZWMgMyAvLyAgInNwcyIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglieiAqaWYzX2VuZAoKCS8vICppZjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjY4CgkvLyByZXR1cm4gW10KCWJ5dGVjIDEgLy8gMHgKCWIgKmdldFN0YWtlZFBvb2xzRm9yQWNjb3VudCpyZXR1cm4KCippZjNfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjcwCgkvLyByZXREYXRhOiBWYWxpZGF0b3JQb29sS2V5W10gPSBbXQoJYnl0ZWMgMSAvLyAweAoJZnJhbWVfYnVyeSAwIC8vIHJldERhdGE6IFZhbGlkYXRvclBvb2xLZXlbXQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI3MQoJLy8gcG9vbFNldCA9IGNsb25lKHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlKQoJYnl0ZWMgMyAvLyAgInNwcyIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUKCWFzc2VydAoJZnJhbWVfYnVyeSAxIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNzIKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgcG9vbFNldC5sZW5ndGg7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDIgLy8gaTogdWludDY0CgoqZm9yXzE6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNzIKCS8vIGkgPCBwb29sU2V0Lmxlbmd0aAoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDcgLy8gNgoJPAoJYnogKmZvcl8xX2VuZAoKCS8vICppZjRfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNzMKCS8vIHBvb2xTZXRbaV0uaWQgIT09IDAKCWZyYW1lX2RpZyAxIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMCAvLyAwCgkrCglpbnRjIDIgLy8gOAoJZXh0cmFjdDMKCWJ0b2kKCWludGMgMCAvLyAwCgkhPQoJYnogKmlmNF9lbmQKCgkvLyAqaWY0X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI3NAoJLy8gcmV0RGF0YS5wdXNoKHBvb2xTZXRbaV0pCglmcmFtZV9kaWcgMCAvLyByZXREYXRhOiBWYWxpZGF0b3JQb29sS2V5W10KCWZyYW1lX2RpZyAxIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMyAvLyAyNAoJZXh0cmFjdDMKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIHJldERhdGE6IFZhbGlkYXRvclBvb2xLZXlbXQoKKmlmNF9lbmQ6CgoqZm9yXzFfY29udGludWU6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNzIKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzEKCipmb3JfMV9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNzcKCS8vIHJldHVybiByZXREYXRhCglmcmFtZV9kaWcgMCAvLyByZXREYXRhOiBWYWxpZGF0b3JQb29sS2V5W10KCipnZXRTdGFrZWRQb29sc0ZvckFjY291bnQqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMgoJcmV0c3ViCgovLyBnZXRUb2tlblBheW91dFJhdGlvKHVpbnQ2NCkodWludDY0WzI0XSx1aW50NjQpCiphYmlfcm91dGVfZ2V0VG9rZW5QYXlvdXRSYXRpbzoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgZ2V0VG9rZW5QYXlvdXRSYXRpbyh1aW50NjQpKHVpbnQ2NFsyNF0sdWludDY0KQoJY2FsbHN1YiBnZXRUb2tlblBheW91dFJhdGlvCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0VG9rZW5QYXlvdXRSYXRpbyh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlKTogUG9vbFRva2VuUGF5b3V0UmF0aW8KLy8KLy8gUmV0cmlldmVzIHRoZSB0b2tlbiBwYXlvdXQgcmF0aW8gZm9yIGEgZ2l2ZW4gdmFsaWRhdG9yIC0gcmV0dXJuaW5nIHRoZSBwb29sIHJhdGlvcyBvZiB3aG9sZSBzbyB0aGF0IHRva2VuCi8vIHBheW91dHMgYWNyb3NzIHBvb2xzIGNhbiBiZSBiYXNlZCBvbiBhIHN0YWJsZSBzbmFwaG9zdCBvZiBzdGFrZS4KLy8KLy8gQHBhcmFtIHtWYWxpZGF0b3JJZFR5cGV9IHZhbGlkYXRvcklkIC0gVGhlIGlkIG9mIHRoZSB2YWxpZGF0b3IuCi8vIEByZXR1cm4ge1Bvb2xUb2tlblBheW91dFJhdGlvfSAtIFRoZSB0b2tlbiBwYXlvdXQgcmF0aW8gZm9yIHRoZSB2YWxpZGF0b3IuCmdldFRva2VuUGF5b3V0UmF0aW86Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyODkKCS8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnRva2VuUGF5b3V0UmF0aW8KCWludGMgMTQgLy8gIGhlYWRPZmZzZXQKCWludGMgMTkgLy8gMjAwCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglyZXRzdWIKCi8vIGdldE5vZGVQb29sQXNzaWdubWVudHModWludDY0KSgodWludDY0WzNdKVs4XSkKKmFiaV9yb3V0ZV9nZXROb2RlUG9vbEFzc2lnbm1lbnRzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBnZXROb2RlUG9vbEFzc2lnbm1lbnRzKHVpbnQ2NCkoKHVpbnQ2NFszXSlbOF0pCgljYWxsc3ViIGdldE5vZGVQb29sQXNzaWdubWVudHMKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBnZXROb2RlUG9vbEFzc2lnbm1lbnRzKHZhbGlkYXRvcklkOiB1aW50NjQpOiBOb2RlUG9vbEFzc2lnbm1lbnRDb25maWcKZ2V0Tm9kZVBvb2xBc3NpZ25tZW50czoKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI5NAoJLy8gYXNzZXJ0KHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkuZXhpc3RzLCAidGhlIHNwZWNpZmllZCB2YWxpZGF0b3IgaWQgZG9lc24ndCBleGlzdCIpCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogdWludDY0CglpdG9iCgljb25jYXQKCWJveF9sZW4KCXN3YXAKCXBvcAoKCS8vIHRoZSBzcGVjaWZpZWQgdmFsaWRhdG9yIGlkIGRvZXNuJ3QgZXhpc3QKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI5NgoJLy8gcmV0dXJuIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUubm9kZVBvb2xBc3NpZ25tZW50cwoJaW50YyAxNyAvLyAgaGVhZE9mZnNldAoJaW50YyAyMiAvLyAxOTIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCXJldHN1YgoKLy8gZ2V0TkZEUmVnaXN0cnlJRCgpdWludDY0CiphYmlfcm91dGVfZ2V0TkZEUmVnaXN0cnlJRDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBnZXRORkRSZWdpc3RyeUlEKCl1aW50NjQKCWNhbGxzdWIgZ2V0TkZEUmVnaXN0cnlJRAoJaXRvYgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldE5GRFJlZ2lzdHJ5SUQoKTogdWludDY0CmdldE5GRFJlZ2lzdHJ5SUQ6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMDEKCS8vIHJldHVybiB0aGlzLm5mZFJlZ2lzdHJ5QXBwSWQKCWludGMgMjggLy8gVE1QTF9uZmRSZWdpc3RyeUFwcElkCglyZXRzdWIKCi8vIGFkZFZhbGlkYXRvcihwYXksc3RyaW5nLCh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KSl1aW50NjQKKmFiaV9yb3V0ZV9hZGRWYWxpZGF0b3I6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIGNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyA5IC8vIDI0MgoJPT0KCgkvLyBhcmd1bWVudCAwIChjb25maWcpIGZvciBhZGRWYWxpZGF0b3IgbXVzdCBiZSBhICh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoJYXNzZXJ0CgoJLy8gbmZkTmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIG1iclBheW1lbnQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludGMgMSAvLyAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnRjIDEgLy8gIHBheQoJPT0KCgkvLyBhcmd1bWVudCAyIChtYnJQYXltZW50KSBmb3IgYWRkVmFsaWRhdG9yIG11c3QgYmUgYSBwYXkgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGV4ZWN1dGUgYWRkVmFsaWRhdG9yKHBheSxzdHJpbmcsKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpKXVpbnQ2NAoJY2FsbHN1YiBhZGRWYWxpZGF0b3IKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBhZGRWYWxpZGF0b3IobWJyUGF5bWVudDogUGF5VHhuLCBuZmROYW1lOiBzdHJpbmcsIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnKTogdWludDY0Ci8vCi8vIEFkZHMgYSBuZXcgdmFsaWRhdG9yCi8vIFJlcXVpcmVzIGF0IGxlYXN0IDEwIEFMR08gYXMgdGhlICdmZWUnIGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gaGVscCBkaXNzdWFkZSBzcGFtbWVkIHZhbGlkYXRvciBhZGRzLgovLwovLyBAcGFyYW0ge1BheVR4bn0gbWJyUGF5bWVudCBwYXltZW50IGZyb20gY2FsbGVyIHdoaWNoIGNvdmVycyBtYnIgaW5jcmVhc2Ugb2YgbmV3IHZhbGlkYXRvciBzdG9yYWdlCi8vIEBwYXJhbSB7c3RyaW5nfSBuZmROYW1lIChPcHRpb25hbCkgTmFtZSBvZiBuZmQgKHVzZWQgYXMgZG91YmxlLWNoZWNrIGFnYWluc3QgaWQgc3BlY2lmaWVkIGluIGNvbmZpZykKLy8gQHBhcmFtIHtWYWxpZGF0b3JDb25maWd9IGNvbmZpZyBWYWxpZGF0b3JDb25maWcgc3RydWN0Ci8vIEByZXR1cm5zIHt1aW50NjR9IHZhbGlkYXRvciBpZAphZGRWYWxpZGF0b3I6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMxMwoJLy8gdGhpcy52YWxpZGF0ZUNvbmZpZyhjb25maWcpCglmcmFtZV9kaWcgLTMgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWNhbGxzdWIgdmFsaWRhdGVDb25maWcKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMTUKCS8vIHZlcmlmeVBheVR4bihtYnJQYXltZW50LCB7IHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLCBhbW91bnQ6IHRoaXMuZ2V0TWJyQW1vdW50cygpLmFkZFZhbGlkYXRvck1iciB9KQoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gbWJyUGF5bWVudDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJtYnJQYXltZW50IiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gbWJyUGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWNhbGxzdWIgZ2V0TWJyQW1vdW50cwoJZXh0cmFjdCAwIDgKCWJ0b2kKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJtYnJQYXltZW50IiwiZmllbGQiOiJhbW91bnQiLCJleHBlY3RlZCI6InRoaXMuZ2V0TWJyQW1vdW50cygpLmFkZFZhbGlkYXRvck1iciJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMTcKCS8vIGFzc2VydChtYnJQYXltZW50LmZlZSA+IDEwICogMTAwMDAwMCwgJ2ZlZSBtdXN0IGJlIDEwIEFMR08gb3IgbW9yZSB0byBwcmV2ZW50IHNwYW1taW5nIG9mIHZhbGlkYXRvcnMnKQoJZnJhbWVfZGlnIC0xIC8vIG1iclBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgRmVlCglwdXNoaW50IDEwMDAwMDAwCgk+CgoJLy8gZmVlIG11c3QgYmUgMTAgQUxHTyBvciBtb3JlIHRvIHByZXZlbnQgc3BhbW1pbmcgb2YgdmFsaWRhdG9ycwoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzIwCgkvLyB2YWxpZGF0b3JJZCA9IHRoaXMubnVtVmFsaWRhdG9ycy52YWx1ZSArIDEKCWJ5dGVjIDExIC8vICAibnVtViIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAwIC8vIHZhbGlkYXRvcklkOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMjEKCS8vIHRoaXMubnVtVmFsaWRhdG9ycy52YWx1ZSA9IHZhbGlkYXRvcklkCglieXRlYyAxMSAvLyAgIm51bVYiCglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JJZDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMyMwoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS5jcmVhdGUoKQoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JJZDogdWludDY0CglpdG9iCgljb25jYXQKCXB1c2hpbnQgMTA5MgoJYm94X2NyZWF0ZQoJcG9wCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzI0CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZyA9IGNvbmZpZwoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAtMyAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JJZDogdWludDY0CglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzI1CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5pZCA9IHZhbGlkYXRvcklkCglpbnRjIDAgLy8gMAoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJaXRvYgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JJZDogdWludDY0CglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gKmlmNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMyOAoJLy8gY29uZmlnLm5mZEZvckluZm8gIT09IDAKCWZyYW1lX2RpZyAtMyAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCA3MiA4CglidG9pCglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjVfZW5kCgoJLy8gKmlmNV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMzAKCS8vIGFzc2VydCh0aGlzLmlzTkZEQXBwSURWYWxpZChjb25maWcubmZkRm9ySW5mbyksICdwcm92aWRlZCBORkQgbXVzdCBiZSB2YWxpZCcpCglmcmFtZV9kaWcgLTMgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgNzIgOAoJYnRvaQoJY2FsbHN1YiBpc05GREFwcElEVmFsaWQKCgkvLyBwcm92aWRlZCBORkQgbXVzdCBiZSB2YWxpZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzMyCgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICAgICAgdGhpcy50eG4uc2VuZGVyID09PSAoQXBwSUQuZnJvbVVpbnQ2NChjb25maWcubmZkRm9ySW5mbykuZ2xvYmFsU3RhdGUoJ2kub3duZXIuYScpIGFzIEFkZHJlc3MpLAoJLy8gICAgICAgICAgICAgICAgICdJZiBzcGVjaWZ5aW5nIE5GRCwgYWNjb3VudCBhZGRpbmcgdmFsaWRhdG9yIG11c3QgYmUgb3duZXInLAoJLy8gICAgICAgICAgICAgKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0zIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDcyIDgKCWJ0b2kKCWJ5dGVjIDEwIC8vICAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQoY29uZmlnLm5mZEZvckluZm8pLmdsb2JhbFN0YXRlKCdpLm93bmVyLmEnKQoJYXNzZXJ0Cgk9PQoKCS8vIElmIHNwZWNpZnlpbmcgTkZELCBhY2NvdW50IGFkZGluZyB2YWxpZGF0b3IgbXVzdCBiZSBvd25lcgoJYXNzZXJ0CgoqaWY1X2VuZDoKCS8vICppZjZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMzgKCS8vIGNvbmZpZy5lbnRyeUdhdGluZ1R5cGUgPT09IEdBVElOR19UWVBFX0NSRUFURURfQllfTkZEX0FERFJFU1NFUyB8fAoJLy8gICAgICAgICAgICAgY29uZmlnLmVudHJ5R2F0aW5nVHlwZSA9PT0gR0FUSU5HX1RZUEVfU0VHTUVOVF9PRl9ORkQKCWZyYW1lX2RpZyAtMyAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCA4MCAxCglidG9pCglpbnRjIDggLy8gMwoJPT0KCWR1cAoJYm56ICpza2lwX29yMAoJZnJhbWVfZGlnIC0zIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDgwIDEKCWJ0b2kKCWludGMgMTUgLy8gNAoJPT0KCXx8Cgoqc2tpcF9vcjA6CglieiAqaWY2X2VuZAoKCS8vICppZjZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzQyCgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICAgICAgdGhpcy5pc05GREFwcElEVmFsaWQoY29uZmlnLmVudHJ5R2F0aW5nQXNzZXRzWzBdKSwKCS8vICAgICAgICAgICAgICAgICAncHJvdmlkZWQgTkZEIEFwcCBpZCBmb3IgZ2F0aW5nIG11c3QgYmUgdmFsaWQgTkZEJywKCS8vICAgICAgICAgICAgICkKCWZyYW1lX2RpZyAtMyAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAxMTMgOAoJYnRvaQoJY2FsbHN1YiBpc05GREFwcElEVmFsaWQKCgkvLyBwcm92aWRlZCBORkQgQXBwIGlkIGZvciBnYXRpbmcgbXVzdCBiZSB2YWxpZCBORkQKCWFzc2VydAoKKmlmNl9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNDcKCS8vIHRoaXMucmV0aU9QX2FkZGVkVmFsaWRhdG9yLmxvZyh7IGlkOiB2YWxpZGF0b3JJZCwgb3duZXI6IGNvbmZpZy5vd25lciwgbWFuYWdlcjogY29uZmlnLm1hbmFnZXIgfSkKCXB1c2hieXRlcyAweGE4ZGQyMWNiIC8vIHJldGlPUF9hZGRlZFZhbGlkYXRvcih1aW50NjQsYWRkcmVzcyxhZGRyZXNzKQoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJaXRvYgoJZnJhbWVfZGlnIC0zIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDggMzIKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDQwIDMyCgljb25jYXQKCWNvbmNhdAoJbG9nCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzQ4CgkvLyByZXR1cm4gdmFsaWRhdG9ySWQKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvcklkOiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gY2hhbmdlVmFsaWRhdG9yTWFuYWdlcih1aW50NjQsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfY2hhbmdlVmFsaWRhdG9yTWFuYWdlcjoKCS8vIG1hbmFnZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDYgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMCAobWFuYWdlcikgZm9yIGNoYW5nZVZhbGlkYXRvck1hbmFnZXIgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIHZhbGlkYXRvcklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGNoYW5nZVZhbGlkYXRvck1hbmFnZXIodWludDY0LGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBjaGFuZ2VWYWxpZGF0b3JNYW5hZ2VyCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBjaGFuZ2VWYWxpZGF0b3JNYW5hZ2VyKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIG1hbmFnZXI6IEFkZHJlc3MpOiB2b2lkCi8vCi8vIENoYW5nZXMgdGhlIFZhbGlkYXRvciBtYW5hZ2VyIGZvciBhIHNwZWNpZmljIFZhbGlkYXRvciBpZC4KLy8gWyBPTkxZIE9XTkVSIENBTiBDSEFOR0UgXQovLwovLyBAcGFyYW0ge1ZhbGlkYXRvcklkVHlwZX0gdmFsaWRhdG9ySWQgLSBUaGUgaWQgb2YgdGhlIHZhbGlkYXRvciB0byBjaGFuZ2UgdGhlIG1hbmFnZXIgZm9yLgovLyBAcGFyYW0ge0FkZHJlc3N9IG1hbmFnZXIgLSBUaGUgbmV3IG1hbmFnZXIgYWRkcmVzcy4KY2hhbmdlVmFsaWRhdG9yTWFuYWdlcjoKCXByb3RvIDIgMAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM1OQoJLy8gdGhpcy5jYWxsZXJNdXN0QmVPd25lcih2YWxpZGF0b3JJZCkKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgljYWxsc3ViIGNhbGxlck11c3RCZU93bmVyCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzYwCgkvLyBhc3NlcnQobWFuYWdlciAhPT0gZ2xvYmFscy56ZXJvQWRkcmVzcywgJ25lZWRzIHRvIGF0IGxlYXN0IGJlIHZhbGlkIGFkZHJlc3MnKQoJZnJhbWVfZGlnIC0yIC8vIG1hbmFnZXI6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCgkvLyBuZWVkcyB0byBhdCBsZWFzdCBiZSB2YWxpZCBhZGRyZXNzCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNjEKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1hbmFnZXIgPSBtYW5hZ2VyCglpbnRjIDIwIC8vIDQwCglmcmFtZV9kaWcgLTIgLy8gbWFuYWdlcjogQWRkcmVzcwoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBjaGFuZ2VWYWxpZGF0b3JTdW5zZXRJbmZvKHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9jaGFuZ2VWYWxpZGF0b3JTdW5zZXRJbmZvOgoJLy8gc3Vuc2V0dGluZ1RvOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyBzdW5zZXR0aW5nT246IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHZhbGlkYXRvcklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGNoYW5nZVZhbGlkYXRvclN1bnNldEluZm8odWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBjaGFuZ2VWYWxpZGF0b3JTdW5zZXRJbmZvCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBjaGFuZ2VWYWxpZGF0b3JTdW5zZXRJbmZvKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIHN1bnNldHRpbmdPbjogdWludDY0LCBzdW5zZXR0aW5nVG86IFZhbGlkYXRvcklkVHlwZSk6IHZvaWQKLy8KLy8gVXBkYXRlcyB0aGUgc3Vuc2V0IGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIHZhbGlkYXRvci4KLy8gWyBPTkxZIE9XTkVSIENBTiBDSEFOR0UgXQovLwovLyBAcGFyYW0ge1ZhbGlkYXRvcklkVHlwZX0gdmFsaWRhdG9ySWQgLSBUaGUgaWQgb2YgdGhlIHZhbGlkYXRvciB0byB1cGRhdGUuCi8vIEBwYXJhbSB7dWludDY0fSBzdW5zZXR0aW5nT24gLSBUaGUgbmV3IHN1bnNldCB0aW1lc3RhbXAuCi8vIEBwYXJhbSB7dWludDY0fSBzdW5zZXR0aW5nVG8gLSBUaGUgbmV3IHN1bnNldCB0byB2YWxpZGF0b3IgaWQuCmNoYW5nZVZhbGlkYXRvclN1bnNldEluZm86Cglwcm90byAzIDAKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNzMKCS8vIHRoaXMuY2FsbGVyTXVzdEJlT3duZXIodmFsaWRhdG9ySWQpCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJY2FsbHN1YiBjYWxsZXJNdXN0QmVPd25lcgoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM3NAoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcuc3Vuc2V0dGluZ09uID0gc3Vuc2V0dGluZ09uCglpbnRjIDI3IC8vIDIyNgoJZnJhbWVfZGlnIC0yIC8vIHN1bnNldHRpbmdPbjogdWludDY0CglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Mzc1CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5zdW5zZXR0aW5nVG8gPSBzdW5zZXR0aW5nVG8KCXB1c2hpbnQgMjM0CglmcmFtZV9kaWcgLTMgLy8gc3Vuc2V0dGluZ1RvOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCXJldHN1YgoKLy8gY2hhbmdlVmFsaWRhdG9yTkZEKHVpbnQ2NCx1aW50NjQsc3RyaW5nKXZvaWQKKmFiaV9yb3V0ZV9jaGFuZ2VWYWxpZGF0b3JORkQ6CgkvLyBuZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWV4dHJhY3QgMiAwCgoJLy8gbmZkQXBwSUQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHZhbGlkYXRvcklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGNoYW5nZVZhbGlkYXRvck5GRCh1aW50NjQsdWludDY0LHN0cmluZyl2b2lkCgljYWxsc3ViIGNoYW5nZVZhbGlkYXRvck5GRAoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gY2hhbmdlVmFsaWRhdG9yTkZEKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIG5mZEFwcElEOiB1aW50NjQsIG5mZE5hbWU6IHN0cmluZyk6IHZvaWQKLy8KLy8gQ2hhbmdlcyB0aGUgTkZEIGZvciBhIHZhbGlkYXRvciBpbiB0aGUgdmFsaWRhdG9yTGlzdCBjb250cmFjdC4KLy8gWyBPTkxZIE9XTkVSIENBTiBDSEFOR0UgXQovLwovLyBAcGFyYW0ge1ZhbGlkYXRvcklkVHlwZX0gdmFsaWRhdG9ySWQgLSBUaGUgaWQgb2YgdGhlIHZhbGlkYXRvciB0byB1cGRhdGUuCi8vIEBwYXJhbSB7dWludDY0fSBuZmRBcHBJRCAtIFRoZSBhcHBsaWNhdGlvbiBpZCBvZiB0aGUgTkZEIHRvIGFzc2lnbiB0byB0aGUgdmFsaWRhdG9yLgovLyBAcGFyYW0ge3N0cmluZ30gbmZkTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBORkQgKHdoaWNoIG11c3QgbWF0Y2gpCmNoYW5nZVZhbGlkYXRvck5GRDoKCXByb3RvIDMgMAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM4NwoJLy8gdGhpcy5jYWxsZXJNdXN0QmVPd25lcih2YWxpZGF0b3JJZCkKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgljYWxsc3ViIGNhbGxlck11c3RCZU93bmVyCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Mzg5CgkvLyBhc3NlcnQodGhpcy5pc05GREFwcElEVmFsaWQobmZkQXBwSUQpLCAncHJvdmlkZWQgTkZEIG11c3QgYmUgdmFsaWQnKQoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElEOiB1aW50NjQKCWNhbGxzdWIgaXNORkRBcHBJRFZhbGlkCgoJLy8gcHJvdmlkZWQgTkZEIG11c3QgYmUgdmFsaWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM5MQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgdGhpcy50eG4uc2VuZGVyID09PSAoQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJRCkuZ2xvYmFsU3RhdGUoJ2kub3duZXIuYScpIGFzIEFkZHJlc3MpLAoJLy8gICAgICAgICAgICAgJ0lmIHNwZWNpZnlpbmcgTkZELCBhY2NvdW50IGFkZGluZyB2YWxpZGF0b3IgbXVzdCBiZSBvd25lcicsCgkvLyAgICAgICAgICkKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMiAvLyBuZmRBcHBJRDogdWludDY0CglieXRlYyAxMCAvLyAgImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElEKS5nbG9iYWxTdGF0ZSgnaS5vd25lci5hJykKCWFzc2VydAoJPT0KCgkvLyBJZiBzcGVjaWZ5aW5nIE5GRCwgYWNjb3VudCBhZGRpbmcgdmFsaWRhdG9yIG11c3QgYmUgb3duZXIKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM5NQoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcubmZkRm9ySW5mbyA9IG5mZEFwcElECglpbnRjIDIxIC8vIDcyCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSUQ6IHVpbnQ2NAoJaXRvYgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBjaGFuZ2VWYWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyh1aW50NjQsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfY2hhbmdlVmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3M6CgkvLyBjb21taXNzaW9uQWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgNiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChjb21taXNzaW9uQWRkcmVzcykgZm9yIGNoYW5nZVZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBjaGFuZ2VWYWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyh1aW50NjQsYWRkcmVzcyl2b2lkCgljYWxsc3ViIGNoYW5nZVZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBjaGFuZ2VWYWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCBjb21taXNzaW9uQWRkcmVzczogQWRkcmVzcyk6IHZvaWQKLy8KLy8gQ2hhbmdlIHRoZSBjb21taXNzaW9uIGFkZHJlc3MgdGhhdCB2YWxpZGF0b3IgcmV3YXJkcyBhcmUgc2VudCB0by4KLy8gWyBPTkxZIE9XTkVSIENBTiBDSEFOR0UgXQpjaGFuZ2VWYWxpZGF0b3JDb21taXNzaW9uQWRkcmVzczoKCXByb3RvIDIgMAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQwMwoJLy8gdGhpcy5jYWxsZXJNdXN0QmVPd25lcih2YWxpZGF0b3JJZCkKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgljYWxsc3ViIGNhbGxlck11c3RCZU93bmVyCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDA0CgkvLyBhc3NlcnQoY29tbWlzc2lvbkFkZHJlc3MgIT09IEFkZHJlc3MuemVyb0FkZHJlc3MpCglmcmFtZV9kaWcgLTIgLy8gY29tbWlzc2lvbkFkZHJlc3M6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQwNQoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcudmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3MgPSBjb21taXNzaW9uQWRkcmVzcwoJcHVzaGludCAxNzcKCWZyYW1lX2RpZyAtMiAvLyBjb21taXNzaW9uQWRkcmVzczogQWRkcmVzcwoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvKHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9jaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvOgoJLy8gUmV3YXJkUGVyUGF5b3V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDYKCWJ0b2kKCgkvLyBHYXRpbmdBc3NldE1pbkJhbGFuY2U6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJYnRvaQoKCS8vIEVudHJ5R2F0aW5nQXNzZXRzOiB1aW50NjRbNF0KCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWR1cAoJbGVuCglpbnRjIDYgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMiAoRW50cnlHYXRpbmdBc3NldHMpIGZvciBjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvIG11c3QgYmUgYSB1aW50NjRbNF0KCWFzc2VydAoKCS8vIEVudHJ5R2F0aW5nQWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludGMgNiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAzIChFbnRyeUdhdGluZ0FkZHJlc3MpIGZvciBjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBFbnRyeUdhdGluZ1R5cGU6IHVpbnQ4Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAxIC8vIDEKCT09CgoJLy8gYXJndW1lbnQgNCAoRW50cnlHYXRpbmdUeXBlKSBmb3IgY2hhbmdlVmFsaWRhdG9yUmV3YXJkSW5mbyBtdXN0IGJlIGEgdWludDgKCWFzc2VydAoJYnRvaQoKCS8vIHZhbGlkYXRvcklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGNoYW5nZVZhbGlkYXRvclJld2FyZEluZm8odWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIEVudHJ5R2F0aW5nVHlwZTogdWludDgsIEVudHJ5R2F0aW5nQWRkcmVzczogQWRkcmVzcywgRW50cnlHYXRpbmdBc3NldHM6IFN0YXRpY0FycmF5PHVpbnQ2NCwgND4sIEdhdGluZ0Fzc2V0TWluQmFsYW5jZTogdWludDY0LCBSZXdhcmRQZXJQYXlvdXQ6IHVpbnQ2NCk6IHZvaWQKLy8KLy8gQWxsb3cgdGhlIGFkZGl0aW9uYWwgcmV3YXJkcyAoZ2F0aW5nIGVudHJ5LCBhZGRpdGlvbmFsIHRva2VuIHJld2FyZHMpIGluZm9ybWF0aW9uIGJlIGNoYW5nZWQgYXQgd2lsbC4KLy8gWyBPTkxZIE9XTkVSIENBTiBDSEFOR0UgXQpjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvOgoJcHJvdG8gNiAwCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDIwCgkvLyB0aGlzLmNhbGxlck11c3RCZU93bmVyKHZhbGlkYXRvcklkKQoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWNhbGxzdWIgY2FsbGVyTXVzdEJlT3duZXIKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MjIKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIEVudHJ5R2F0aW5nVHlwZSA+PSBHQVRJTkdfVFlQRV9OT05FICYmIEVudHJ5R2F0aW5nVHlwZSA8IEdBVElOR19UWVBFX0NPTlNUX01BWCwKCS8vICAgICAgICAgICAgICdpbnZhbGlkIEVudHJ5IGdhdGluZyB0eXBlJywKCS8vICAgICAgICAgKQoJZnJhbWVfZGlnIC0yIC8vIEVudHJ5R2F0aW5nVHlwZTogdWludDgKCWludGMgMCAvLyAwCgk+PQoJZHVwCglieiAqc2tpcF9hbmQxCglmcmFtZV9kaWcgLTIgLy8gRW50cnlHYXRpbmdUeXBlOiB1aW50OAoJaW50YyAxNSAvLyA0Cgk8CgkmJgoKKnNraXBfYW5kMToKCS8vIGludmFsaWQgRW50cnkgZ2F0aW5nIHR5cGUKCWFzc2VydAoKCS8vICppZjdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MjYKCS8vIEVudHJ5R2F0aW5nVHlwZSA9PT0gR0FUSU5HX1RZUEVfQVNTRVRTX0NSRUFURURfQlkKCWZyYW1lX2RpZyAtMiAvLyBFbnRyeUdhdGluZ1R5cGU6IHVpbnQ4CglpbnRjIDEgLy8gMQoJPT0KCWJ6ICppZjdfZW5kCgoJLy8gKmlmN19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MjcKCS8vIGFzc2VydChFbnRyeUdhdGluZ0FkZHJlc3MgIT09IGdsb2JhbHMuemVyb0FkZHJlc3MpCglmcmFtZV9kaWcgLTMgLy8gRW50cnlHYXRpbmdBZGRyZXNzOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9Cglhc3NlcnQKCippZjdfZW5kOgoJLy8gKmlmOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQzMAoJLy8gRW50cnlHYXRpbmdUeXBlID09PSBHQVRJTkdfVFlQRV9DUkVBVEVEX0JZX05GRF9BRERSRVNTRVMgfHwKCS8vICAgICAgICAgICAgIEVudHJ5R2F0aW5nVHlwZSA9PT0gR0FUSU5HX1RZUEVfU0VHTUVOVF9PRl9ORkQKCWZyYW1lX2RpZyAtMiAvLyBFbnRyeUdhdGluZ1R5cGU6IHVpbnQ4CglpbnRjIDggLy8gMwoJPT0KCWR1cAoJYm56ICpza2lwX29yMQoJZnJhbWVfZGlnIC0yIC8vIEVudHJ5R2F0aW5nVHlwZTogdWludDgKCWludGMgMTUgLy8gNAoJPT0KCXx8Cgoqc2tpcF9vcjE6CglieiAqaWY4X2VuZAoKCS8vICppZjhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDMzCgkvLyBhc3NlcnQodGhpcy5pc05GREFwcElEVmFsaWQoRW50cnlHYXRpbmdBc3NldHNbMF0pLCAncHJvdmlkZWQgTkZEIEFwcCBpZCBmb3IgZ2F0aW5nIG11c3QgYmUgdmFsaWQgTkZEJykKCWZyYW1lX2RpZyAtNCAvLyBFbnRyeUdhdGluZ0Fzc2V0czogU3RhdGljQXJyYXk8dWludDY0LCA0PgoJZXh0cmFjdCAwIDgKCWJ0b2kKCWNhbGxzdWIgaXNORkRBcHBJRFZhbGlkCgoJLy8gcHJvdmlkZWQgTkZEIEFwcCBpZCBmb3IgZ2F0aW5nIG11c3QgYmUgdmFsaWQgTkZECglhc3NlcnQKCippZjhfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDM1CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5lbnRyeUdhdGluZ1R5cGUgPSBFbnRyeUdhdGluZ1R5cGUKCWludGMgMzYgLy8gODAKCWZyYW1lX2RpZyAtMiAvLyBFbnRyeUdhdGluZ1R5cGU6IHVpbnQ4CglpdG9iCglleHRyYWN0IDcgMQoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQzNgoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcuZW50cnlHYXRpbmdBZGRyZXNzID0gRW50cnlHYXRpbmdBZGRyZXNzCglwdXNoaW50IDgxCglmcmFtZV9kaWcgLTMgLy8gRW50cnlHYXRpbmdBZGRyZXNzOiBBZGRyZXNzCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDM3CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5lbnRyeUdhdGluZ0Fzc2V0cyA9IEVudHJ5R2F0aW5nQXNzZXRzCglwdXNoaW50IDExMwoJZnJhbWVfZGlnIC00IC8vIEVudHJ5R2F0aW5nQXNzZXRzOiBTdGF0aWNBcnJheTx1aW50NjQsIDQ+CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDM4CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5nYXRpbmdBc3NldE1pbkJhbGFuY2UgPSBHYXRpbmdBc3NldE1pbkJhbGFuY2UKCWludGMgMzcgLy8gMTQ1CglmcmFtZV9kaWcgLTUgLy8gR2F0aW5nQXNzZXRNaW5CYWxhbmNlOiB1aW50NjQKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MzkKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLnJld2FyZFBlclBheW91dCA9IFJld2FyZFBlclBheW91dAoJcHVzaGludCAxNjEKCWZyYW1lX2RpZyAtNiAvLyBSZXdhcmRQZXJQYXlvdXQ6IHVpbnQ2NAoJaXRvYgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBhZGRQb29sKHBheSx1aW50NjQsdWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCkKKmFiaV9yb3V0ZV9hZGRQb29sOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyBub2RlTnVtOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gbWJyUGF5bWVudDogcGF5Cgl0eG4gR3JvdXBJbmRleAoJaW50YyAxIC8vIDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludGMgMSAvLyAgcGF5Cgk9PQoKCS8vIGFyZ3VtZW50IDIgKG1iclBheW1lbnQpIGZvciBhZGRQb29sIG11c3QgYmUgYSBwYXkgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGV4ZWN1dGUgYWRkUG9vbChwYXksdWludDY0LHVpbnQ2NCkodWludDY0LHVpbnQ2NCx1aW50NjQpCgljYWxsc3ViIGFkZFBvb2wKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBhZGRQb29sKG1iclBheW1lbnQ6IFBheVR4biwgdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSwgbm9kZU51bTogdWludDY0KTogVmFsaWRhdG9yUG9vbEtleQovLwovLyBBZGRzIGEgbmV3IHBvb2wgdG8gYSB2YWxpZGF0b3IncyBwb29sIHNldCwgcmV0dXJuaW5nIHRoZSAna2V5JyB0byByZWZlcmVuY2UgdGhlIHBvb2wgaW4gdGhlIGZ1dHVyZSBmb3Igc3Rha2luZywgZXRjLgovLyBUaGUgY2FsbGVyIG11c3QgcGF5IHRoZSBjb3N0IG9mIHRoZSB2YWxpZGF0b3JzIE1CUiBpbmNyZWFzZSBhcyB3ZWxsIGFzIHRoZSBNQlIgdGhhdCB3aWxsIGJlIG5lZWRlZCBmb3IgdGhlIHBvb2wgaXRzZWxmLgovLwovLyBbIE9OTFkgT1dORVIgT1IgTUFOQUdFUiBDQU4gY2FsbCBdCi8vIEBwYXJhbSB7UGF5VHhufSBtYnJQYXltZW50IHBheW1lbnQgZnJvbSBjYWxsZXIgd2hpY2ggY292ZXJzIG1iciBpbmNyZWFzZSBvZiBhZGRpbmcgYSBuZXcgcG9vbAovLyBAcGFyYW0ge3VpbnQ2NH0gdmFsaWRhdG9ySWQgaXMgaWQgb2YgdmFsaWRhdG9yIHRvIHBvb2wgdG8gKG11c3QgYmUgb3duZXIgb3IgbWFuYWdlcikKLy8gQHBhcmFtIHt1aW50NjR9IG5vZGVOdW0gaXMgbm9kZSBudW1iZXIgdG8gYWRkIHRvCi8vIEByZXR1cm5zIHtWYWxpZGF0b3JQb29sS2V5fSBwb29sIGtleSB0byBjcmVhdGVkIHBvb2wKYWRkUG9vbDoKCXByb3RvIDMgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXAKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NTQKCS8vIHRoaXMuY2FsbGVyTXVzdEJlT3duZXJPck1hbmFnZXIodmFsaWRhdG9ySWQpCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJY2FsbHN1YiBjYWxsZXJNdXN0QmVPd25lck9yTWFuYWdlcgoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ1NwoJLy8gdmVyaWZ5UGF5VHhuKG1iclBheW1lbnQsIHsgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsIGFtb3VudDogdGhpcy5nZXRNYnJBbW91bnRzKCkuYWRkUG9vbE1iciB9KQoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gbWJyUGF5bWVudDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJtYnJQYXltZW50IiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gbWJyUGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWNhbGxzdWIgZ2V0TWJyQW1vdW50cwoJZXh0cmFjdCA4IDgKCWJ0b2kKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJtYnJQYXltZW50IiwiZmllbGQiOiJhbW91bnQiLCJleHBlY3RlZCI6InRoaXMuZ2V0TWJyQW1vdW50cygpLmFkZFBvb2xNYnIifQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDU5CgkvLyBhc3NlcnQodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS5leGlzdHMsICJzcGVjaWZpZWQgdmFsaWRhdG9yIGlkIGlzbid0IHZhbGlkIikKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCgoJLy8gc3BlY2lmaWVkIHZhbGlkYXRvciBpZCBpc24ndCB2YWxpZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDYxCgkvLyBudW1Qb29sczogdWludDY0ID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5zdGF0ZS5udW1Qb29scyBhcyB1aW50NjQKCWludGMgOSAvLyAyNDIKCWludGMgMTAgLy8gMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAwIC8vIG51bVBvb2xzOiB1aW50NjQKCgkvLyAqaWY5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDYyCgkvLyAobnVtUG9vbHMgYXMgdWludDY0KSA+PSBNQVhfUE9PTFMKCWZyYW1lX2RpZyAwIC8vIG51bVBvb2xzOiB1aW50NjQKCWludGMgMyAvLyAyNAoJPj0KCWJ6ICppZjlfZW5kCgoJLy8gKmlmOV9jb25zZXF1ZW50CgkvLyBhbHJlYWR5IGF0IG1heCBwb29sIHNpemUKCWVycgoKKmlmOV9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NjUKCS8vIG51bVBvb2xzICs9IDEKCWZyYW1lX2RpZyAwIC8vIG51bVBvb2xzOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDAgLy8gbnVtUG9vbHM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ2OAoJLy8gc2VuZEFwcENhbGwoewoJLy8gICAgICAgICAgICAgb25Db21wbGV0aW9uOiBPbkNvbXBsZXRpb24uTm9PcCwKCS8vICAgICAgICAgICAgIGFwcHJvdmFsUHJvZ3JhbTogWwoJLy8gICAgICAgICAgICAgICAgIHRoaXMuc3Rha2luZ1Bvb2xBcHByb3ZhbFByb2dyYW0uZXh0cmFjdCgwLCA0MDk2KSwKCS8vICAgICAgICAgICAgICAgICB0aGlzLnN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtLmV4dHJhY3QoNDA5NiwgdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5zaXplIC0gNDA5NiksCgkvLyAgICAgICAgICAgICBdLAoJLy8gICAgICAgICAgICAgY2xlYXJTdGF0ZVByb2dyYW06IFN0YWtpbmdQb29sLmNsZWFyUHJvZ3JhbSgpLAoJLy8gICAgICAgICAgICAgZ2xvYmFsTnVtVWludDogU3Rha2luZ1Bvb2wuc2NoZW1hLmdsb2JhbC5udW1VaW50LAoJLy8gICAgICAgICAgICAgZ2xvYmFsTnVtQnl0ZVNsaWNlOiBTdGFraW5nUG9vbC5zY2hlbWEuZ2xvYmFsLm51bUJ5dGVTbGljZSwKCS8vICAgICAgICAgICAgIGV4dHJhUHJvZ3JhbVBhZ2VzOiAzLAoJLy8gICAgICAgICAgICAgYXBwbGljYXRpb25BcmdzOiBbCgkvLyAgICAgICAgICAgICAgICAgLy8gY3JlYXRpbmdDb250cmFjdElELCB2YWxpZGF0b3JJZCwgcG9vbElkLCBtaW5FbnRyeVN0YWtlCgkvLyAgICAgICAgICAgICAgICAgbWV0aG9kKCdjcmVhdGVBcHBsaWNhdGlvbih1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCcpLAoJLy8gICAgICAgICAgICAgICAgIGl0b2IodGhpcy5hcHAuaWQpLAoJLy8gICAgICAgICAgICAgICAgIGl0b2IodmFsaWRhdG9ySWQpLAoJLy8gICAgICAgICAgICAgICAgIGl0b2IobnVtUG9vbHMgYXMgdWludDY0KSwKCS8vICAgICAgICAgICAgICAgICBpdG9iKHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1pbkVudHJ5U3Rha2UpLAoJLy8gICAgICAgICAgICAgXSwKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ2OQoJLy8gb25Db21wbGV0aW9uOiBPbkNvbXBsZXRpb24uTm9PcAoJaW50YyAwIC8vICBOb09wCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ3MAoJLy8gYXBwcm92YWxQcm9ncmFtOiBbCgkvLyAgICAgICAgICAgICAgICAgdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5leHRyYWN0KDAsIDQwOTYpLAoJLy8gICAgICAgICAgICAgICAgIHRoaXMuc3Rha2luZ1Bvb2xBcHByb3ZhbFByb2dyYW0uZXh0cmFjdCg0MDk2LCB0aGlzLnN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtLnNpemUgLSA0MDk2KSwKCS8vICAgICAgICAgICAgIF0KCWJ5dGVjIDkgLy8gICJwb29sVGVtcGxhdGVBcHByb3ZhbEJ5dGVzIgoJaW50YyAwIC8vIDAKCWludGMgMjUgLy8gNDA5NgoJYm94X2V4dHJhY3QKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtUGFnZXMKCWJ5dGVjIDkgLy8gICJwb29sVGVtcGxhdGVBcHByb3ZhbEJ5dGVzIgoJaW50YyAyNSAvLyA0MDk2CglieXRlYyA5IC8vICAicG9vbFRlbXBsYXRlQXBwcm92YWxCeXRlcyIKCWJveF9sZW4KCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuc3Rha2luZ1Bvb2xBcHByb3ZhbFByb2dyYW0uc2l6ZQoJYXNzZXJ0CglpbnRjIDI1IC8vIDQwOTYKCS0KCWJveF9leHRyYWN0CglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbVBhZ2VzCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDc0CgkvLyBjbGVhclN0YXRlUHJvZ3JhbTogU3Rha2luZ1Bvb2wuY2xlYXJQcm9ncmFtKCkKCXB1c2hieXRlcyAweDBiCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDc1CgkvLyBnbG9iYWxOdW1VaW50OiBTdGFraW5nUG9vbC5zY2hlbWEuZ2xvYmFsLm51bVVpbnQKCWludGMgMzUgLy8gMTEKCWl0eG5fZmllbGQgR2xvYmFsTnVtVWludAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ3NgoJLy8gZ2xvYmFsTnVtQnl0ZVNsaWNlOiBTdGFraW5nUG9vbC5zY2hlbWEuZ2xvYmFsLm51bUJ5dGVTbGljZQoJaW50YyA4IC8vIDMKCWl0eG5fZmllbGQgR2xvYmFsTnVtQnl0ZVNsaWNlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDc3CgkvLyBleHRyYVByb2dyYW1QYWdlczogMwoJaW50YyA4IC8vIDMKCWl0eG5fZmllbGQgRXh0cmFQcm9ncmFtUGFnZXMKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NzgKCS8vIGFwcGxpY2F0aW9uQXJnczogWwoJLy8gICAgICAgICAgICAgICAgIC8vIGNyZWF0aW5nQ29udHJhY3RJRCwgdmFsaWRhdG9ySWQsIHBvb2xJZCwgbWluRW50cnlTdGFrZQoJLy8gICAgICAgICAgICAgICAgIG1ldGhvZCgnY3JlYXRlQXBwbGljYXRpb24odWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQnKSwKCS8vICAgICAgICAgICAgICAgICBpdG9iKHRoaXMuYXBwLmlkKSwKCS8vICAgICAgICAgICAgICAgICBpdG9iKHZhbGlkYXRvcklkKSwKCS8vICAgICAgICAgICAgICAgICBpdG9iKG51bVBvb2xzIGFzIHVpbnQ2NCksCgkvLyAgICAgICAgICAgICAgICAgaXRvYih0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5taW5FbnRyeVN0YWtlKSwKCS8vICAgICAgICAgICAgIF0KCXB1c2hieXRlcyAweDU5ZTkwYWE2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24odWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDAgLy8gbnVtUG9vbHM6IHVpbnQ2NAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWludGMgMzkgLy8gMjA5CglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDg4CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnN0YXRlLm51bVBvb2xzID0gbnVtUG9vbHMgYXMgdWludDE2CglpbnRjIDkgLy8gMjQyCglmcmFtZV9kaWcgMCAvLyBudW1Qb29sczogdWludDY0CglpdG9iCglleHRyYWN0IDYgMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ5MQoJLy8gcG9vbEFwcElkID0gdGhpcy5pdHhuLmNyZWF0ZWRBcHBsaWNhdGlvbklELmlkCglpdHhuIENyZWF0ZWRBcHBsaWNhdGlvbklECglmcmFtZV9idXJ5IDEgLy8gcG9vbEFwcElkOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0OTIKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUucG9vbHNbbnVtUG9vbHMgLSAxXS5wb29sQXBwSWQgPSBwb29sQXBwSWQKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIDAgLy8gbnVtUG9vbHM6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCS0KCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnRjIDAgLy8gMAoJKwoJZnJhbWVfZGlnIDEgLy8gcG9vbEFwcElkOiB1aW50NjQKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0OTMKCS8vIHRoaXMuYWRkUG9vbFRvTm9kZSh2YWxpZGF0b3JJZCwgcG9vbEFwcElkLCBub2RlTnVtKQoJZnJhbWVfZGlnIC0zIC8vIG5vZGVOdW06IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gcG9vbEFwcElkOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgljYWxsc3ViIGFkZFBvb2xUb05vZGUKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0OTUKCS8vIHRoaXMucmV0aU9QX3ZhbGlkYXRvckFkZGVkUG9vbC5sb2coewoJLy8gICAgICAgICAgICAgaWQ6IHZhbGlkYXRvcklkLAoJLy8gICAgICAgICAgICAgbnVtOiBudW1Qb29scyBhcyB1aW50MTYsCgkvLyAgICAgICAgICAgICBwb29sQXBwSWQ6IEFwcElELmZyb21VaW50NjQocG9vbEFwcElkKSwKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweGZiY2MwZjZiIC8vIHJldGlPUF92YWxpZGF0b3JBZGRlZFBvb2wodWludDY0LHVpbnQxNix1aW50NjQpCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJZnJhbWVfZGlnIDAgLy8gbnVtUG9vbHM6IHVpbnQ2NAoJaXRvYgoJZHVwCgliaXRsZW4KCWludGMgMTggLy8gMTYKCTw9CgoJLy8gbnVtUG9vbHMgYXMgdWludDE2IG92ZXJmbG93ZWQgMTYgYml0cwoJYXNzZXJ0CglleHRyYWN0IDYgMgoJY29uY2F0CglmcmFtZV9kaWcgMSAvLyBwb29sQXBwSWQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb25jYXQKCWxvZwoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUwMQoJLy8gcmV0dXJuIHsgaWQ6IHZhbGlkYXRvcklkLCBwb29sSWQ6IG51bVBvb2xzIGFzIHVpbnQ2NCwgcG9vbEFwcElkOiB0aGlzLml0eG4hLmNyZWF0ZWRBcHBsaWNhdGlvbklELmlkIH0KCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCglmcmFtZV9kaWcgMCAvLyBudW1Qb29sczogdWludDY0CglpdG9iCgljb25jYXQKCWl0eG4gQ3JlYXRlZEFwcGxpY2F0aW9uSUQKCWl0b2IKCWNvbmNhdAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gYWRkU3Rha2UocGF5LHVpbnQ2NCx1aW50NjQpKHVpbnQ2NCx1aW50NjQsdWludDY0KQoqYWJpX3JvdXRlX2FkZFN0YWtlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gc3Rha2VkQW1vdW50UGF5bWVudDogcGF5Cgl0eG4gR3JvdXBJbmRleAoJaW50YyAxIC8vIDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludGMgMSAvLyAgcGF5Cgk9PQoKCS8vIGFyZ3VtZW50IDIgKHN0YWtlZEFtb3VudFBheW1lbnQpIGZvciBhZGRTdGFrZSBtdXN0IGJlIGEgcGF5IHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBleGVjdXRlIGFkZFN0YWtlKHBheSx1aW50NjQsdWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCkKCWNhbGxzdWIgYWRkU3Rha2UKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBhZGRTdGFrZShzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4sIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIHZhbHVlVG9WZXJpZnk6IHVpbnQ2NCk6IFZhbGlkYXRvclBvb2xLZXkKLy8KLy8gQWRkcyBzdGFrZSB0byBhIHZhbGlkYXRvciBwb29sLgovLwovLyBAcGFyYW0ge1BheVR4bn0gc3Rha2VkQW1vdW50UGF5bWVudCAtIHBheW1lbnQgY29taW5nIGZyb20gc3Rha2VyIHRvIHBsYWNlIGludG8gYSBwb29sCi8vIEBwYXJhbSB7VmFsaWRhdG9ySWRUeXBlfSB2YWxpZGF0b3JJZCAtIFRoZSBpZCBvZiB0aGUgdmFsaWRhdG9yLgovLyBAcGFyYW0ge3VpbnQ2NH0gdmFsdWVUb1ZlcmlmeSAtIG9ubHkgaWYgdmFsaWRhdG9yIGhhcyBnYXRpbmcgdG8gZW50ZXIgLSB0aGlzIGlzIGFzc2V0IGlkIG9yIG5mZCBpZCB0aGF0IGNvcnJlc3BvbmRzIHRvIGdhdGluZy4KLy8gVHhuIHNlbmRlciBpcyBmYWN0b3JlZCBpbiBhcyB3ZWxsIGlmIHRoYXQgaXMgcGFydCBvZiBnYXRpbmcuCi8vICogQHJldHVybnMge1ZhbGlkYXRvclBvb2xLZXl9IC0gVGhlIGtleSBvZiB0aGUgdmFsaWRhdG9yIHBvb2wuCmFkZFN0YWtlOgoJcHJvdG8gMyAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDEgLy8gMHgKCWR1cG4gNQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUxNAoJLy8gYXNzZXJ0KHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkuZXhpc3RzLCAic3BlY2lmaWVkIHZhbGlkYXRvciBpZCBpc24ndCB2YWxpZCIpCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWJveF9sZW4KCXN3YXAKCXBvcAoKCS8vIHNwZWNpZmllZCB2YWxpZGF0b3IgaWQgaXNuJ3QgdmFsaWQKCWFzc2VydAoKCS8vICppZjEwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTE3CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5zdW5zZXR0aW5nT24gPiAwCglpbnRjIDI3IC8vIDIyNgoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWludGMgMCAvLyAwCgk+CglieiAqaWYxMF9lbmQKCgkvLyAqaWYxMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MTkKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5zdW5zZXR0aW5nT24gPiBnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCwKCS8vICAgICAgICAgICAgICAgICAiY2FuJ3Qgc3Rha2Ugd2l0aCBhIHZhbGlkYXRvciB0aGF0IGlzIHBhc3QgaXRzIHN1bnNldHRpbmcgdGltZSIsCgkvLyAgICAgICAgICAgICApCglpbnRjIDI3IC8vIDIyNgoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCT4KCgkvLyBjYW4ndCBzdGFrZSB3aXRoIGEgdmFsaWRhdG9yIHRoYXQgaXMgcGFzdCBpdHMgc3Vuc2V0dGluZyB0aW1lCglhc3NlcnQKCippZjEwX2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUyNQoJLy8gc3Rha2VyID0gdGhpcy50eG4uc2VuZGVyCgl0eG4gU2VuZGVyCglmcmFtZV9idXJ5IDAgLy8gc3Rha2VyOiBhZGRyZXNzCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTI5CgkvLyB2ZXJpZnlQYXlUeG4oc3Rha2VkQW1vdW50UGF5bWVudCwgewoJLy8gICAgICAgICAgICAgc2VuZGVyOiBzdGFrZXIsCgkvLyAgICAgICAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgfSkKCS8vIHZlcmlmeSBzZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIFNlbmRlcgoJZnJhbWVfZGlnIDAgLy8gc3Rha2VyOiBhZGRyZXNzCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoic3Rha2VkQW1vdW50UGF5bWVudCIsImZpZWxkIjoic2VuZGVyIiwiZXhwZWN0ZWQiOiJzdGFrZXIifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJzdGFrZWRBbW91bnRQYXltZW50IiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MzcKCS8vIHRoaXMuZG9lc1N0YWtlck1lZXRHYXRpbmcodmFsaWRhdG9ySWQsIHZhbHVlVG9WZXJpZnkpCglmcmFtZV9kaWcgLTMgLy8gdmFsdWVUb1ZlcmlmeTogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJY2FsbHN1YiBkb2VzU3Rha2VyTWVldEdhdGluZwoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUzOQoJLy8gcmVhbEFtb3VudCA9IHN0YWtlZEFtb3VudFBheW1lbnQuYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2J1cnkgMSAvLyByZWFsQW1vdW50OiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1NDAKCS8vIG1ickFtdExlZnRCZWhpbmQ6IHVpbnQ2NCA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDIgLy8gbWJyQW10TGVmdEJlaGluZDogdWludDY0CgoJLy8gKmlmMTFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1NDIKCS8vIHRoaXMuZG9lc1N0YWtlck5lZWRUb1BheU1CUihzdGFrZXIpCglmcmFtZV9kaWcgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCWNhbGxzdWIgZG9lc1N0YWtlck5lZWRUb1BheU1CUgoJYnogKmlmMTFfZW5kCgoJLy8gKmlmMTFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTQ1CgkvLyBtYnJBbXRMZWZ0QmVoaW5kID0gdGhpcy5nZXRNYnJBbW91bnRzKCkuYWRkU3Rha2VyTWJyCgljYWxsc3ViIGdldE1ickFtb3VudHMKCWV4dHJhY3QgMjQgOAoJYnRvaQoJZnJhbWVfYnVyeSAyIC8vIG1ickFtdExlZnRCZWhpbmQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU0NgoJLy8gcmVhbEFtb3VudCAtPSBtYnJBbXRMZWZ0QmVoaW5kCglmcmFtZV9kaWcgMSAvLyByZWFsQW1vdW50OiB1aW50NjQKCWZyYW1lX2RpZyAyIC8vIG1ickFtdExlZnRCZWhpbmQ6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSAxIC8vIHJlYWxBbW91bnQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU0NwoJLy8gdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikuY3JlYXRlKCkKCWJ5dGVjIDMgLy8gICJzcHMiCglmcmFtZV9kaWcgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCWNvbmNhdAoJcHVzaGludCAxNDQKCWJveF9jcmVhdGUKCXBvcAoKKmlmMTFfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTUxCgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnN0YXRlLnRvdGFsQWxnb1N0YWtlZCArIHJlYWxBbW91bnQgPCB0aGlzLm1heEFsbG93ZWRTdGFrZSgpLAoJLy8gICAgICAgICAgICAgJ3RvdGFsIHN0YWtlZCBmb3IgYWxsIG9mIGEgdmFsaWRhdG9ycyBwb29scyBtYXkgbm90IGV4Y2VlZCBoYXJkIGNhcCcsCgkvLyAgICAgICAgICkKCWludGMgMTIgLy8gMjUyCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIDEgLy8gcmVhbEFtb3VudDogdWludDY0CgkrCgljYWxsc3ViIG1heEFsbG93ZWRTdGFrZQoJPAoKCS8vIHRvdGFsIHN0YWtlZCBmb3IgYWxsIG9mIGEgdmFsaWRhdG9ycyBwb29scyBtYXkgbm90IGV4Y2VlZCBoYXJkIGNhcAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTU4CgkvLyBmaW5kUmV0ID0gdGhpcy5maW5kUG9vbEZvclN0YWtlcih2YWxpZGF0b3JJZCwgc3Rha2VyLCByZWFsQW1vdW50KQoJZnJhbWVfZGlnIDEgLy8gcmVhbEFtb3VudDogdWludDY0CglmcmFtZV9kaWcgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgljYWxsc3ViIGZpbmRQb29sRm9yU3Rha2VyCglmcmFtZV9idXJ5IDMgLy8gZmluZFJldDogKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxib29sKQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU1OQoJLy8gcG9vbEtleSA9IGZpbmRSZXRbMF0KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU2MAoJLy8gaXNOZXdTdGFrZXJUb1ZhbGlkYXRvciA9IGZpbmRSZXRbMV0KCWZyYW1lX2RpZyAzIC8vIGZpbmRSZXQ6ICgodWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDIyIC8vIDE5MgoJZ2V0Yml0CglmcmFtZV9idXJ5IDQgLy8gaXNOZXdTdGFrZXJUb1ZhbGlkYXRvcjogYm9vbAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU2MQoJLy8gaXNOZXdTdGFrZXJUb1Byb3RvY29sID0gZmluZFJldFsyXQoJZnJhbWVfZGlnIDMgLy8gZmluZFJldDogKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxib29sKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXB1c2hpbnQgMTkzCglnZXRiaXQKCWZyYW1lX2J1cnkgNSAvLyBpc05ld1N0YWtlclRvUHJvdG9jb2w6IGJvb2wKCgkvLyAqaWYxMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU2MgoJLy8gcG9vbEtleS5wb29sSWQgPT09IDAKCWZyYW1lX2RpZyAzIC8vIGZpbmRSZXQ6ICgodWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDggOAoJYnRvaQoJaW50YyAwIC8vIDAKCT09CglieiAqaWYxMl9lbmQKCgkvLyAqaWYxMl9jb25zZXF1ZW50CgkvLyBObyBwb29sIGF2YWlsYWJsZSB3aXRoIGZyZWUgc3Rha2UuICBWYWxpZGF0b3IgbmVlZHMgdG8gYWRkIGFub3RoZXIgcG9vbAoJZXJyCgoqaWYxMl9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1NjcKCS8vIHRoaXMudXBkYXRlU3Rha2VyUG9vbFNldChzdGFrZXIsIHBvb2xLZXkpCglmcmFtZV9kaWcgMyAvLyBmaW5kUmV0OiAoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxib29sLGJvb2wpCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAwIDI0CglmcmFtZV9kaWcgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCWNhbGxzdWIgdXBkYXRlU3Rha2VyUG9vbFNldAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU3MAoJLy8gdGhpcy5jYWxsUG9vbEFkZFN0YWtlKAoJLy8gICAgICAgICAgICAgc3Rha2VkQW1vdW50UGF5bWVudCwKCS8vICAgICAgICAgICAgIHBvb2xLZXksCgkvLyAgICAgICAgICAgICBtYnJBbXRMZWZ0QmVoaW5kLAoJLy8gICAgICAgICAgICAgaXNOZXdTdGFrZXJUb1ZhbGlkYXRvciwKCS8vICAgICAgICAgICAgIGlzTmV3U3Rha2VyVG9Qcm90b2NvbCwKCS8vICAgICAgICAgKQoJZnJhbWVfZGlnIDUgLy8gaXNOZXdTdGFrZXJUb1Byb3RvY29sOiBib29sCglmcmFtZV9kaWcgNCAvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yOiBib29sCglmcmFtZV9kaWcgMiAvLyBtYnJBbXRMZWZ0QmVoaW5kOiB1aW50NjQKCWZyYW1lX2RpZyAzIC8vIGZpbmRSZXQ6ICgodWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDAgMjQKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWNhbGxzdWIgY2FsbFBvb2xBZGRTdGFrZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU3NwoJLy8gdGhpcy5yZXRpT1Bfc3Rha2VBZGRlZC5sb2coewoJLy8gICAgICAgICAgICAgaWQ6IHZhbGlkYXRvcklkLAoJLy8gICAgICAgICAgICAgcG9vbE51bTogcG9vbEtleS5wb29sSWQgYXMgdWludDE2LAoJLy8gICAgICAgICAgICAgcG9vbEFwcElkOiBBcHBJRC5mcm9tVWludDY0KHBvb2xLZXkucG9vbEFwcElkKSwKCS8vICAgICAgICAgICAgIGFtb3VudFN0YWtlZDogcmVhbEFtb3VudCwKCS8vICAgICAgICAgICAgIHN0YWtlcjogc3Rha2VyLAoJLy8gICAgICAgICB9KQoJcHVzaGJ5dGVzIDB4OTYyYjQxNDMgLy8gcmV0aU9QX3N0YWtlQWRkZWQodWludDY0LHVpbnQxNix1aW50NjQsYWRkcmVzcyx1aW50NjQpCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJZnJhbWVfZGlnIDMgLy8gZmluZFJldDogKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxib29sKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgOCA4CglidG9pCglpdG9iCglkdXAKCWJpdGxlbgoJaW50YyAxOCAvLyAxNgoJPD0KCgkvLyBwb29sS2V5LnBvb2xJZCBhcyB1aW50MTYgb3ZlcmZsb3dlZCAxNiBiaXRzCglhc3NlcnQKCWV4dHJhY3QgNiAyCgljb25jYXQKCWZyYW1lX2RpZyAzIC8vIGZpbmRSZXQ6ICgodWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDE2IDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIDAgLy8gc3Rha2VyOiBhZGRyZXNzCgljb25jYXQKCWZyYW1lX2RpZyAxIC8vIHJlYWxBbW91bnQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb25jYXQKCWxvZwoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU4NQoJLy8gcmV0dXJuIHBvb2xLZXkKCWZyYW1lX2RpZyAzIC8vIGZpbmRSZXQ6ICgodWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDAgMjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiA1CglyZXRzdWIKCi8vIHNldFRva2VuUGF5b3V0UmF0aW8odWludDY0KSh1aW50NjRbMjRdLHVpbnQ2NCkKKmFiaV9yb3V0ZV9zZXRUb2tlblBheW91dFJhdGlvOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBzZXRUb2tlblBheW91dFJhdGlvKHVpbnQ2NCkodWludDY0WzI0XSx1aW50NjQpCgljYWxsc3ViIHNldFRva2VuUGF5b3V0UmF0aW8KCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBzZXRUb2tlblBheW91dFJhdGlvKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUpOiBQb29sVG9rZW5QYXlvdXRSYXRpbwovLwovLyBzZXRUb2tlblBheW91dFJhdGlvIGlzIGNhbGxlZCBieSBTdGFraW5nIFBvb2wgIyAxIChPTkxZKSB0byBhc2sgdGhlIHZhbGlkYXRvciAodXMpIHRvIGNhbGN1bGF0ZSB0aGUgcmF0aW9zCi8vIG9mIHN0YWtlIGluIHRoZSBwb29scyBmb3Igc3Vic2VxdWVudCB0b2tlbiBwYXlvdXRzIChpZTogMiBwb29scywgJzEwMCcgYWxnbyB0b3RhbCBzdGFrZWQsIDYwIGluIHBvb2wgMSwgYW5kIDQwCi8vIGluIHBvb2wgMikgIFRoaXMgaXMgZG9uZSBzbyB3ZSBoYXZlIGEgc3RhYmxlIHNuYXBzaG90IG9mIHN0YWtlIC0gdGFrZW4gb25jZSBwZXIgZXBvY2ggLSBvbmx5IHRyaWdnZXJlZCBieQovLyBwb29sIDEgZG9pbmcgcGF5b3V0LiAgcG9vbHMgb3RoZXIgdGhhbiAxIGRvaW5nIHBheW91dCBjYWxsIHBvb2wgMSB0byBhc2sgaXQgZG8gaXQgZmlyc3QuCi8vIEl0IHdvdWxkIGJlIDYwLzQwJSBpbiB0aGUgcG9vbFBjdE9mV2hvbGUgdmFsdWVzLiAgVGhlIHRva2VuIHJld2FyZCBwYXlvdXRzIHRoZW4gdXNlIHRoZXNlIHZhbHVlcyBpbnN0ZWFkIG9mCi8vIHRoZWlyICdjdXJyZW50JyBzdGFrZSB3aGljaCBjaGFuZ2VzIGFzIHBhcnQgb2YgdGhlIHBheW91dHMgdGhlbXNlbHZlcyAoYW5kIHBlb3BsZSBjb3VsZCBiZSBjaGFuZ2luZyBzdGFrZQovLyBkdXJpbmcgdGhlIGVwb2NoIHVwZGF0ZXMgYWNyb3NzIHBvb2xzKQovLwovLyBNdWx0aXBsZSBwb29scyB3aWxsIGNhbGwgdXMgdmlhIHBvb2wgMSAocG9vbDItPnBvb2wxLT52YWxpZGF0b3IsIGV0Yy4pIHNvIGRvbid0IGFzc2VydCBvbiBwb29sMSBjYWxsaW5nIG11bHRpcGxlCi8vIHRpbWVzIGluIHNhbWUgZXBvY2guICBKdXN0IHJldHVybi4KLy8KLy8gQHBhcmFtIHZhbGlkYXRvcklkIC0gdmFsaWRhdG9yIGlkIChhbmQgdGh1cyBwb29sKSBjYWxsaW5nIHVzLiAgVmVyaWZpZWQgc28gdGhhdCBzZW5kZXIgTVVTVCBiZSBwb29sIDEgb2YgdGhpcyB2YWxpZGF0b3IuCi8vIEByZXR1cm5zIFBvb2xUb2tlblBheW91dFJhdGlvIC0gdGhlIGZpbmlzaGVkIHJhdGlvIGRhdGEKc2V0VG9rZW5QYXlvdXRSYXRpbzoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXBuIDgKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MDUKCS8vIHBvb2wxQXBwSUQgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnBvb2xzWzBdLnBvb2xBcHBJZAoJaW50YyA1IC8vIDI2OAoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgMCAvLyBwb29sMUFwcElEOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MDYKCS8vIGFzc2VydChwb29sMUFwcElEICE9PSAwKQoJZnJhbWVfZGlnIDAgLy8gcG9vbDFBcHBJRDogdWludDY0CglpbnRjIDAgLy8gMAoJIT0KCWFzc2VydAoKCS8vICppZjEzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjA4CgkvLyB0aGlzLnR4bi5zZW5kZXIgIT09IEFwcElELmZyb21VaW50NjQocG9vbDFBcHBJRCkuYWRkcmVzcwoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIDAgLy8gcG9vbDFBcHBJRDogdWludDY0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCSE9CglieiAqaWYxM19lbmQKCgkvLyAqaWYxM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MDkKCS8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnRva2VuUGF5b3V0UmF0aW8KCWludGMgMTQgLy8gIGhlYWRPZmZzZXQKCWludGMgMTkgLy8gMjAwCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CgliICpzZXRUb2tlblBheW91dFJhdGlvKnJldHVybgoKKmlmMTNfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjE1CgkvLyBjdXJSb3VuZCA9IGdsb2JhbHMucm91bmQKCWdsb2JhbCBSb3VuZAoJZnJhbWVfYnVyeSAxIC8vIGN1clJvdW5kOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MTYKCS8vIGxhc3RQYXlvdXRVcGRhdGUgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnRva2VuUGF5b3V0UmF0aW8udXBkYXRlZEZvclBheW91dAoJaW50YyAzMSAvLyA4OTIKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDIgLy8gbGFzdFBheW91dFVwZGF0ZTogdWludDY0CgoJLy8gKmlmMTRfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MTcKCS8vIGxhc3RQYXlvdXRVcGRhdGUgIT09IDAKCWZyYW1lX2RpZyAyIC8vIGxhc3RQYXlvdXRVcGRhdGU6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCSE9CglieiAqaWYxNF9lbmQKCgkvLyAqaWYxNF9jb25zZXF1ZW50CgkvLyAqaWYxNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYxOQoJLy8gKEFwcElELmZyb21VaW50NjQocG9vbDFBcHBJRCkuZ2xvYmFsU3RhdGUoJ2xhc3RQYXlvdXQnKSBhcyB1aW50NjQpID09PSBsYXN0UGF5b3V0VXBkYXRlCglmcmFtZV9kaWcgMCAvLyBwb29sMUFwcElEOiB1aW50NjQKCXB1c2hieXRlcyAweDZjNjE3Mzc0NTA2MTc5NmY3NTc0IC8vICJsYXN0UGF5b3V0IgoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQocG9vbDFBcHBJRCkuZ2xvYmFsU3RhdGUoJ2xhc3RQYXlvdXQnKQoJYXNzZXJ0CglmcmFtZV9kaWcgMiAvLyBsYXN0UGF5b3V0VXBkYXRlOiB1aW50NjQKCT09CglieiAqaWYxNV9lbmQKCgkvLyAqaWYxNV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MjAKCS8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnRva2VuUGF5b3V0UmF0aW8KCWludGMgMTQgLy8gIGhlYWRPZmZzZXQKCWludGMgMTkgLy8gMjAwCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CgliICpzZXRUb2tlblBheW91dFJhdGlvKnJldHVybgoKKmlmMTVfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjIyCgkvLyBlcG9jaFJvdW5kTGVuZ3RoID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcuZXBvY2hSb3VuZExlbmd0aCBhcyB1aW50NjQKCXB1c2hpbnQgMTY5CglpbnRjIDE1IC8vIDQKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgMyAvLyBlcG9jaFJvdW5kTGVuZ3RoOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MjMKCS8vIHRoaXNFcG9jaEJlZ2luID0gY3VyUm91bmQgLSAoY3VyUm91bmQgJSBlcG9jaFJvdW5kTGVuZ3RoKQoJZnJhbWVfZGlnIDEgLy8gY3VyUm91bmQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gY3VyUm91bmQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDMgLy8gZXBvY2hSb3VuZExlbmd0aDogdWludDY0CgklCgktCglmcmFtZV9idXJ5IDQgLy8gdGhpc0Vwb2NoQmVnaW46IHVpbnQ2NAoKCS8vICppZjE2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjI1CgkvLyBsYXN0UGF5b3V0VXBkYXRlIC0gKGxhc3RQYXlvdXRVcGRhdGUgJSBlcG9jaFJvdW5kTGVuZ3RoKSA9PT0gdGhpc0Vwb2NoQmVnaW4KCWZyYW1lX2RpZyAyIC8vIGxhc3RQYXlvdXRVcGRhdGU6IHVpbnQ2NAoJZnJhbWVfZGlnIDIgLy8gbGFzdFBheW91dFVwZGF0ZTogdWludDY0CglmcmFtZV9kaWcgMyAvLyBlcG9jaFJvdW5kTGVuZ3RoOiB1aW50NjQKCSUKCS0KCWZyYW1lX2RpZyA0IC8vIHRoaXNFcG9jaEJlZ2luOiB1aW50NjQKCT09CglieiAqaWYxNl9lbmQKCgkvLyAqaWYxNl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MjYKCS8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnRva2VuUGF5b3V0UmF0aW8KCWludGMgMTQgLy8gIGhlYWRPZmZzZXQKCWludGMgMTkgLy8gMjAwCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CgliICpzZXRUb2tlblBheW91dFJhdGlvKnJldHVybgoKKmlmMTZfZW5kOgoKKmlmMTRfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjI5CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnRva2VuUGF5b3V0UmF0aW8udXBkYXRlZEZvclBheW91dCA9IGN1clJvdW5kCglpbnRjIDMxIC8vIDg5MgoJZnJhbWVfZGlnIDEgLy8gY3VyUm91bmQ6IHVpbnQ2NAoJaXRvYgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYzMQoJLy8gY3VyTnVtUG9vbHMgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnN0YXRlLm51bVBvb2xzIGFzIHVpbnQ2NAoJaW50YyA5IC8vIDI0MgoJaW50YyAxMCAvLyAyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDUgLy8gY3VyTnVtUG9vbHM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYzMgoJLy8gdG90YWxTdGFrZUZvclZhbGlkYXRvciA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuc3RhdGUudG90YWxBbGdvU3Rha2VkCglpbnRjIDEyIC8vIDI1MgoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgNiAvLyB0b3RhbFN0YWtlRm9yVmFsaWRhdG9yOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MzMKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTnVtUG9vbHM7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDcgLy8gaTogdWludDY0CgoqZm9yXzI6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MzMKCS8vIGkgPCBjdXJOdW1Qb29scwoJZnJhbWVfZGlnIDcgLy8gaTogdWludDY0CglmcmFtZV9kaWcgNSAvLyBjdXJOdW1Qb29sczogdWludDY0Cgk8CglieiAqZm9yXzJfZW5kCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjM4CgkvLyBvdXJQb29sUGN0T2ZXaG9sZSA9IHdpZGVSYXRpbygKCS8vICAgICAgICAgICAgICAgICBbdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29sc1tpXS50b3RhbEFsZ29TdGFrZWQsIDFfMDAwXzAwMF0sCgkvLyAgICAgICAgICAgICAgICAgW3RvdGFsU3Rha2VGb3JWYWxpZGF0b3JdLAoJLy8gICAgICAgICAgICAgKQoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgNyAvLyBpOiB1aW50NjQKCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnRjIDExIC8vICBoZWFkT2Zmc2V0CgkrCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJcHVzaGludCAxXzAwMF8wMDAKCW11bHcKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgNiAvLyB0b3RhbFN0YWtlRm9yVmFsaWRhdG9yOiB1aW50NjQKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CglmcmFtZV9idXJ5IDggLy8gb3VyUG9vbFBjdE9mV2hvbGU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY0MgoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS50b2tlblBheW91dFJhdGlvLnBvb2xQY3RPZldob2xlW2ldID0gb3VyUG9vbFBjdE9mV2hvbGUKCWludGMgMTQgLy8gNzAwCglmcmFtZV9kaWcgNyAvLyBpOiB1aW50NjQKCWludGMgMiAvLyA4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWZyYW1lX2RpZyA4IC8vIG91clBvb2xQY3RPZldob2xlOiB1aW50NjQKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCipmb3JfMl9jb250aW51ZToKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYzMwoJLy8gaSArPSAxCglmcmFtZV9kaWcgNyAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDcgLy8gaTogdWludDY0CgliICpmb3JfMgoKKmZvcl8yX2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY0NAoJLy8gcmV0dXJuIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUudG9rZW5QYXlvdXRSYXRpbwoJaW50YyAxNCAvLyAgaGVhZE9mZnNldAoJaW50YyAxOSAvLyAyMDAKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCipzZXRUb2tlblBheW91dFJhdGlvKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDgKCXJldHN1YgoKLy8gc3Rha2VVcGRhdGVkVmlhUmV3YXJkcygodWludDY0LHVpbnQ2NCx1aW50NjQpLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfc3Rha2VVcGRhdGVkVmlhUmV3YXJkczoKCS8vIHNhdHVyYXRlZEJ1cm5Ub0ZlZVNpbms6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJYnRvaQoKCS8vIHZhbGlkYXRvckNvbW1pc3Npb246IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJYnRvaQoKCS8vIHJld2FyZFRva2VuQW1vdW50UmVzZXJ2ZWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGFsZ29Ub0FkZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gcG9vbEtleTogKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgMyAvLyAyNAoJPT0KCgkvLyBhcmd1bWVudCA0IChwb29sS2V5KSBmb3Igc3Rha2VVcGRhdGVkVmlhUmV3YXJkcyBtdXN0IGJlIGEgKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzKCh1aW50NjQsdWludDY0LHVpbnQ2NCksdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgc3Rha2VVcGRhdGVkVmlhUmV3YXJkcwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc3Rha2VVcGRhdGVkVmlhUmV3YXJkcyhwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5LCBhbGdvVG9BZGQ6IHVpbnQ2NCwgcmV3YXJkVG9rZW5BbW91bnRSZXNlcnZlZDogdWludDY0LCB2YWxpZGF0b3JDb21taXNzaW9uOiB1aW50NjQsIHNhdHVyYXRlZEJ1cm5Ub0ZlZVNpbms6IHVpbnQ2NCk6IHZvaWQKLy8KLy8gc3Rha2VVcGRhdGVkVmlhUmV3YXJkcyBpcyBjYWxsZWQgYnkgU3Rha2luZyBwb29scyB0byBpbmZvcm0gdGhlIHZhbGlkYXRvciAodXMpIHRoYXQgYSBwYXJ0aWN1bGFyIGFtb3VudCBvZiB0b3RhbAovLyBzdGFrZSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgc3BlY2lmaWVkIHBvb2wuICBUaGlzIGlzIHVzZWQgdG8gdXBkYXRlIHRoZSBzdGF0cyB3ZSBoYXZlIGluIG91ciBQb29sSW5mbyBzdG9yYWdlLgovLyBUaGUgY2FsbGluZyBBcHAgaWQgaXMgdmFsaWRhdGVkIGFnYWluc3Qgb3VyIHBvb2wgbGlzdCBhcyB3ZWxsLgovLyBAcGFyYW0ge1ZhbGlkYXRvclBvb2xLZXl9IHBvb2xLZXkgLSBWYWxpZGF0b3JQb29sS2V5IHR5cGUKLy8gQHBhcmFtIHt1aW50NjR9IGFsZ29Ub0FkZCAtIGFtb3VudCB0aGlzIHZhbGlkYXRvcidzIHRvdGFsIHN0YWtlIGluY3JlYXNlZCB2aWEgcmV3YXJkcwovLyBAcGFyYW0ge3VpbnQ2NH0gcmV3YXJkVG9rZW5BbW91bnRSZXNlcnZlZCAtIGFtb3VudCB0aGlzIHZhbGlkYXRvcidzIHRvdGFsIHN0YWtlIGluY3JlYXNlZCB2aWEgcmV3YXJkcyAodGhhdCBzaG91bGQgYmUKLy8gQHBhcmFtIHt1aW50NjR9IHZhbGlkYXRvckNvbW1pc3Npb24gLSB0aGUgY29tbWlzc2lvbiBhbW91bnQgdGhlIHZhbGlkYXRvciB3YXMgcGFpZCwgaWYgYW55Ci8vIEBwYXJhbSB7dWludDY0fSBzYXR1cmF0ZWRCdXJuVG9GZWVTaW5rIC0gaWYgdGhlIHBvb2wgd2FzIGluIHNhdHVyYXRlZCBzdGF0ZSwgdGhlIGFtb3VudCBzZW50IGJhY2sgdG8gdGhlIGZlZSBzaW5rLgovLyBzZWVuIGFzICdhY2NvdW50ZWQgZm9yL3BlbmRpbmcgc3BlbnQnKQpzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzOgoJcHJvdG8gNSAwCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjY1CgkvLyB0aGlzLnZlcmlmeVBvb2xLZXlDYWxsZXIocG9vbEtleSkKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CgljYWxsc3ViIHZlcmlmeVBvb2xLZXlDYWxsZXIKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2NjgKCS8vIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5wb29sc1twb29sS2V5LnBvb2xJZCAtIDFdLnRvdGFsQWxnb1N0YWtlZCArPSBhbGdvVG9BZGQKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnRjIDEgLy8gMQoJLQoJaW50YyA0IC8vIDE4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMTEgLy8gIGhlYWRPZmZzZXQKCSsKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnRjIDEgLy8gMQoJLQoJaW50YyA0IC8vIDE4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMTEgLy8gIGhlYWRPZmZzZXQKCSsKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0yIC8vIGFsZ29Ub0FkZDogdWludDY0CgkrCglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY2OQoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLnRvdGFsQWxnb1N0YWtlZCArPSBhbGdvVG9BZGQKCWludGMgMTIgLy8gMjUyCglkdXAKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0yIC8vIGFsZ29Ub0FkZDogdWludDY0CgkrCglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY3MAoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLnJld2FyZFRva2VuSGVsZEJhY2sgKz0gcmV3YXJkVG9rZW5BbW91bnRSZXNlcnZlZAoJaW50YyAxMyAvLyAyNjAKCWR1cAoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgLTMgLy8gcmV3YXJkVG9rZW5BbW91bnRSZXNlcnZlZDogdWludDY0CgkrCglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY3MgoJLy8gdGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgKz0gYWxnb1RvQWRkCglieXRlYyA0IC8vICAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyBhbGdvVG9BZGQ6IHVpbnQ2NAoJKwoJYnl0ZWMgNCAvLyAgInN0YWtlZCIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Njc1CgkvLyB0aGlzLnJldmVyaWZ5TkZET3duZXJzaGlwKHBvb2xLZXkuaWQpCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWNhbGxzdWIgcmV2ZXJpZnlORkRPd25lcnNoaXAKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2NzcKCS8vIHRoaXMucmV0aU9QX2Vwb2NoUmV3YXJkVXBkYXRlLmxvZyh7CgkvLyAgICAgICAgICAgICBpZDogcG9vbEtleS5pZCwKCS8vICAgICAgICAgICAgIHBvb2xOdW06IHBvb2xLZXkucG9vbElkIGFzIHVpbnQxNiwKCS8vICAgICAgICAgICAgIHBvb2xBcHBJZDogQXBwSUQuZnJvbVVpbnQ2NChwb29sS2V5LnBvb2xBcHBJZCksCgkvLyAgICAgICAgICAgICBhbGdvQWRkZWQ6IGFsZ29Ub0FkZCwKCS8vICAgICAgICAgICAgIHJld2FyZFRva2VuSGVsZEJhY2s6IHJld2FyZFRva2VuQW1vdW50UmVzZXJ2ZWQsCgkvLyAgICAgICAgICAgICBzYXR1cmF0ZWRCdXJuVG9GZWVTaW5rOiBzYXR1cmF0ZWRCdXJuVG9GZWVTaW5rLAoJLy8gICAgICAgICAgICAgdmFsaWRhdG9yQ29tbWlzc2lvbjogdmFsaWRhdG9yQ29tbWlzc2lvbiwKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweGIzZTQ3YzNkIC8vIHJldGlPUF9lcG9jaFJld2FyZFVwZGF0ZSh1aW50NjQsdWludDE2LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaXRvYgoJZHVwCgliaXRsZW4KCWludGMgMTggLy8gMTYKCTw9CgoJLy8gcG9vbEtleS5wb29sSWQgYXMgdWludDE2IG92ZXJmbG93ZWQgMTYgYml0cwoJYXNzZXJ0CglleHRyYWN0IDYgMgoJY29uY2F0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAxNiA4CglidG9pCglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAtNCAvLyB2YWxpZGF0b3JDb21taXNzaW9uOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC01IC8vIHNhdHVyYXRlZEJ1cm5Ub0ZlZVNpbms6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglmcmFtZV9kaWcgLTIgLy8gYWxnb1RvQWRkOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIHJld2FyZFRva2VuQW1vdW50UmVzZXJ2ZWQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyBzdGFrZVJlbW92ZWQoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYm9vbCl2b2lkCiphYmlfcm91dGVfc3Rha2VSZW1vdmVkOgoJLy8gc3Rha2VyUmVtb3ZlZDogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJZHVwCglsZW4KCWludGMgMSAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDAgKHN0YWtlclJlbW92ZWQpIGZvciBzdGFrZVJlbW92ZWQgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIHJld2FyZFJlbW92ZWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJYnRvaQoKCS8vIGFtb3VudFJlbW92ZWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIHN0YWtlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgNiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAzIChzdGFrZXIpIGZvciBzdGFrZVJlbW92ZWQgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIHBvb2xLZXk6ICh1aW50NjQsdWludDY0LHVpbnQ2NCkKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDMgLy8gMjQKCT09CgoJLy8gYXJndW1lbnQgNCAocG9vbEtleSkgZm9yIHN0YWtlUmVtb3ZlZCBtdXN0IGJlIGEgKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBzdGFrZVJlbW92ZWQoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYm9vbCl2b2lkCgljYWxsc3ViIHN0YWtlUmVtb3ZlZAoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc3Rha2VSZW1vdmVkKHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXksIHN0YWtlcjogQWRkcmVzcywgYW1vdW50UmVtb3ZlZDogdWludDY0LCByZXdhcmRSZW1vdmVkOiB1aW50NjQsIHN0YWtlclJlbW92ZWQ6IGJvb2xlYW4pOiB2b2lkCi8vCi8vIHN0YWtlUmVtb3ZlZCBpcyBjYWxsZWQgYnkgU3Rha2luZyBwb29scyB0byBpbmZvcm0gdGhlIHZhbGlkYXRvciAodXMpIHRoYXQgYSBwYXJ0aWN1bGFyIGFtb3VudCBvZiB0b3RhbCBzdGFrZSBoYXMgYmVlbiByZW1vdmVkCi8vIGZyb20gdGhlIHNwZWNpZmllZCBwb29sLiAgVGhpcyBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgc3RhdHMgd2UgaGF2ZSBpbiBvdXIgUG9vbEluZm8gc3RvcmFnZS4KLy8gSWYgYW55IGFtb3VudCBvZiByZXdhcmRSZW1vdmVkIGlzIHNwZWNpZmllZCwgdGhlbiB0aGF0IGFtb3VudCBvZiByZXdhcmQgaXMgc2VudCB0byB0aGUgdXNlCi8vIFRoZSBjYWxsaW5nIEFwcCBpZCBpcyB2YWxpZGF0ZWQgYWdhaW5zdCBvdXIgcG9vbCBsaXN0IGFzIHdlbGwuCi8vCi8vIEBwYXJhbSB7VmFsaWRhdG9yUG9vbEtleX0gcG9vbEtleSBjYWxsaW5nIHVzIGZyb20gd2hpY2ggc3Rha2Ugd2FzIHJlbW92ZWQKLy8gQHBhcmFtIHtBZGRyZXNzfSBzdGFrZXIKLy8gQHBhcmFtIHt1aW50NjR9IGFtb3VudFJlbW92ZWQgLSBhbGdvIGFtb3VudCByZW1vdmVkCi8vIEBwYXJhbSB7dWludDY0fSByZXdhcmRSZW1vdmVkIC0gaWYgYXBwbGljYWJsZSwgYW1vdW50IG9mIHRva2VuIHJld2FyZCByZW1vdmVkIChieSBwb29sIDEgY2FsbGVyKSBvciBUTyByZW1vdmUgYW5kIHBheSBvdXQgKHZpYSBwb29sIDEgZnJvbSBkaWZmZXJlbnQgcG9vbCBjYWxsZXIpCi8vIEBwYXJhbSB7Ym9vbGVhbn0gc3Rha2VyUmVtb3ZlZApzdGFrZVJlbW92ZWQ6Cglwcm90byA1IDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiAzCgoJLy8gKmlmMTdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MDcKCS8vIGdsb2JhbHMub3Bjb2RlQnVkZ2V0IDwgMzAwCglnbG9iYWwgT3Bjb2RlQnVkZ2V0CglpbnRjIDI5IC8vIDMwMAoJPAoJYnogKmlmMTdfZW5kCgoJLy8gKmlmMTdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzA4CgkvLyBpbmNyZWFzZU9wY29kZUJ1ZGdldCgpCglpdHhuX2JlZ2luCglpbnRjIDcgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoJYnl0ZWMgOCAvLyAgI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50YyAyNiAvLyAgRGVsZXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMTdfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzEwCgkvLyB0aGlzLnZlcmlmeVBvb2xLZXlDYWxsZXIocG9vbEtleSkKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CgljYWxsc3ViIHZlcmlmeVBvb2xLZXlDYWxsZXIKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MTQKCS8vIGFzc2VydChhbW91bnRSZW1vdmVkID4gMCB8fCByZXdhcmRSZW1vdmVkID4gMCwgJ3Nob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiBhbGdvIG9yIHJld2FyZCB3YXMgcmVtb3ZlZCcpCglmcmFtZV9kaWcgLTMgLy8gYW1vdW50UmVtb3ZlZDogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJZHVwCglibnogKnNraXBfb3IyCglmcmFtZV9kaWcgLTQgLy8gcmV3YXJkUmVtb3ZlZDogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJfHwKCipza2lwX29yMjoKCS8vIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiBhbGdvIG9yIHJld2FyZCB3YXMgcmVtb3ZlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzE3CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXS50b3RhbEFsZ29TdGFrZWQgLT0gYW1vdW50UmVtb3ZlZAoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAxMSAvLyAgaGVhZE9mZnNldAoJKwoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAxMSAvLyAgaGVhZE9mZnNldAoJKwoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgLTMgLy8gYW1vdW50UmVtb3ZlZDogdWludDY0CgktCglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcxOAoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLnRvdGFsQWxnb1N0YWtlZCAtPSBhbW91bnRSZW1vdmVkCglpbnRjIDEyIC8vIDI1MgoJZHVwCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnRSZW1vdmVkOiB1aW50NjQKCS0KCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzE5CgkvLyB0aGlzLnRvdGFsQWxnb1N0YWtlZC52YWx1ZSAtPSBhbW91bnRSZW1vdmVkCglieXRlYyA0IC8vICAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnRSZW1vdmVkOiB1aW50NjQKCS0KCWJ5dGVjIDQgLy8gICJzdGFrZWQiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vICppZjE4X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzIxCgkvLyByZXdhcmRSZW1vdmVkID4gMAoJZnJhbWVfZGlnIC00IC8vIHJld2FyZFJlbW92ZWQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT4KCWJ6ICppZjE4X2Vsc2UKCgkvLyAqaWYxOF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MjIKCS8vIHJld2FyZFRva2VuSUQgPSB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUuY29uZmlnLnJld2FyZFRva2VuSWQKCWludGMgMzggLy8gMTUzCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgMCAvLyByZXdhcmRUb2tlbklEOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MjMKCS8vIGFzc2VydChyZXdhcmRUb2tlbklEICE9PSAwLCAicmV3YXJkUmVtb3ZlZCBjYW4ndCBiZSBzZXQgaWYgdmFsaWRhdG9yIGRvZXNuJ3QgaGF2ZSByZXdhcmQgdG9rZW4hIikKCWZyYW1lX2RpZyAwIC8vIHJld2FyZFRva2VuSUQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCSE9CgoJLy8gcmV3YXJkUmVtb3ZlZCBjYW4ndCBiZSBzZXQgaWYgdmFsaWRhdG9yIGRvZXNuJ3QgaGF2ZSByZXdhcmQgdG9rZW4hCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MjQKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUuc3RhdGUucmV3YXJkVG9rZW5IZWxkQmFjayA+PSByZXdhcmRSZW1vdmVkLAoJLy8gICAgICAgICAgICAgICAgICdyZXdhcmQgYmVpbmcgcmVtb3ZlZCBtdXN0IGJlIGNvdmVyZWQgYnkgaG9sZCBiYWNrIGFtb3VudCcsCgkvLyAgICAgICAgICAgICApCglpbnRjIDEzIC8vIDI2MAoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgLTQgLy8gcmV3YXJkUmVtb3ZlZDogdWludDY0Cgk+PQoKCS8vIHJld2FyZCBiZWluZyByZW1vdmVkIG11c3QgYmUgY292ZXJlZCBieSBob2xkIGJhY2sgYW1vdW50Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MzAKCS8vIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5zdGF0ZS5yZXdhcmRUb2tlbkhlbGRCYWNrIC09IHJld2FyZFJlbW92ZWQKCWludGMgMTMgLy8gMjYwCglkdXAKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC00IC8vIHJld2FyZFJlbW92ZWQ6IHVpbnQ2NAoJLQoJaXRvYgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyAqaWYxOV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjczNQoJLy8gcG9vbEtleS5wb29sSWQgIT09IDEKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50YyAxIC8vIDEKCSE9CglieiAqaWYxOV9lbmQKCgkvLyAqaWYxOV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MzYKCS8vIHNlbmRNZXRob2RDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUucGF5VG9rZW5SZXdhcmQ+KHsKCS8vICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbMF0ucG9vbEFwcElkKSwKCS8vICAgICAgICAgICAgICAgICAgICAgbWV0aG9kQXJnczogW3N0YWtlciwgcmV3YXJkVG9rZW5JRCwgcmV3YXJkUmVtb3ZlZF0sCgkvLyAgICAgICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJYnl0ZWMgMTMgLy8gIG1ldGhvZCAicGF5VG9rZW5SZXdhcmQoYWRkcmVzcyx1aW50NjQsdWludDY0KXZvaWQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjczNwoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbMF0ucG9vbEFwcElkKQoJaW50YyA1IC8vIDI2OAoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MzgKCS8vIG1ldGhvZEFyZ3M6IFtzdGFrZXIsIHJld2FyZFRva2VuSUQsIHJld2FyZFJlbW92ZWRdCglmcmFtZV9kaWcgLTIgLy8gc3Rha2VyOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDAgLy8gcmV3YXJkVG9rZW5JRDogdWludDY0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC00IC8vIHJld2FyZFJlbW92ZWQ6IHVpbnQ2NAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoqaWYxOV9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NDEKCS8vIHRoaXMucmV0aU9QX3N0YWtlUmVtb3ZlZC5sb2coewoJLy8gICAgICAgICAgICAgICAgIGlkOiBwb29sS2V5LmlkLAoJLy8gICAgICAgICAgICAgICAgIHBvb2xOdW06IHBvb2xLZXkucG9vbElkIGFzIHVpbnQxNiwKCS8vICAgICAgICAgICAgICAgICBwb29sQXBwSWQ6IEFwcElELmZyb21VaW50NjQocG9vbEtleS5wb29sQXBwSWQpLAoJLy8gICAgICAgICAgICAgICAgIHN0YWtlcjogc3Rha2VyLAoJLy8gICAgICAgICAgICAgICAgIGFtb3VudFVuc3Rha2VkOiBhbW91bnRSZW1vdmVkLAoJLy8gICAgICAgICAgICAgICAgIHJld2FyZFRva2VuQXNzZXRJZDogQXNzZXRJRC5mcm9tVWludDY0KHJld2FyZFRva2VuSUQpLAoJLy8gICAgICAgICAgICAgICAgIHJld2FyZFRva2Vuc1JlY2VpdmVkOiByZXdhcmRSZW1vdmVkLAoJLy8gICAgICAgICAgICAgfSkKCWJ5dGVjIDE0IC8vICByZXRpT1Bfc3Rha2VSZW1vdmVkKHVpbnQ2NCx1aW50MTYsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaXRvYgoJZHVwCgliaXRsZW4KCWludGMgMTggLy8gMTYKCTw9CgoJLy8gcG9vbEtleS5wb29sSWQgYXMgdWludDE2IG92ZXJmbG93ZWQgMTYgYml0cwoJYXNzZXJ0CglleHRyYWN0IDYgMgoJY29uY2F0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAxNiA4CglidG9pCglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAtMiAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudFJlbW92ZWQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglmcmFtZV9kaWcgLTQgLy8gcmV3YXJkUmVtb3ZlZDogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAwIC8vIHJld2FyZFRva2VuSUQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb25jYXQKCWxvZwoJYiAqaWYxOF9lbmQKCippZjE4X2Vsc2U6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NTEKCS8vIHRoaXMucmV0aU9QX3N0YWtlUmVtb3ZlZC5sb2coewoJLy8gICAgICAgICAgICAgICAgIGlkOiBwb29sS2V5LmlkLAoJLy8gICAgICAgICAgICAgICAgIHBvb2xOdW06IHBvb2xLZXkucG9vbElkIGFzIHVpbnQxNiwKCS8vICAgICAgICAgICAgICAgICBwb29sQXBwSWQ6IEFwcElELmZyb21VaW50NjQocG9vbEtleS5wb29sQXBwSWQpLAoJLy8gICAgICAgICAgICAgICAgIHN0YWtlcjogc3Rha2VyLAoJLy8gICAgICAgICAgICAgICAgIGFtb3VudFVuc3Rha2VkOiBhbW91bnRSZW1vdmVkLAoJLy8gICAgICAgICAgICAgICAgIC8vIG5vIHRva2VucyByZXdhcmRlZC4uCgkvLyAgICAgICAgICAgICAgICAgcmV3YXJkVG9rZW5Bc3NldElkOiBBc3NldElELnplcm9JbmRleCwKCS8vICAgICAgICAgICAgICAgICByZXdhcmRUb2tlbnNSZWNlaXZlZDogMCwKCS8vICAgICAgICAgICAgIH0pCglieXRlYyAxNCAvLyAgcmV0aU9QX3N0YWtlUmVtb3ZlZCh1aW50NjQsdWludDE2LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWl0b2IKCWR1cAoJYml0bGVuCglpbnRjIDE4IC8vIDE2Cgk8PQoKCS8vIHBvb2xLZXkucG9vbElkIGFzIHVpbnQxNiBvdmVyZmxvd2VkIDE2IGJpdHMKCWFzc2VydAoJZXh0cmFjdCA2IDIKCWNvbmNhdAoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMTYgOAoJYnRvaQoJaXRvYgoJY29uY2F0CglmcmFtZV9kaWcgLTIgLy8gc3Rha2VyOiBBZGRyZXNzCgljb25jYXQKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnRSZW1vdmVkOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJYnl0ZWMgNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJYnl0ZWMgNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJY29uY2F0Cglsb2cKCippZjE4X2VuZDoKCS8vICppZjIwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzYzCgkvLyBzdGFrZXJSZW1vdmVkCglmcmFtZV9kaWcgLTUgLy8gc3Rha2VyUmVtb3ZlZDogYm9vbGVhbgoJYnogKmlmMjBfZW5kCgoJLy8gKmlmMjBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzY1CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXS50b3RhbFN0YWtlcnMgLT0gMQoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAyIC8vICBoZWFkT2Zmc2V0CgkrCglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50YyAxIC8vIDEKCS0KCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnRjIDIgLy8gIGhlYWRPZmZzZXQKCSsKCWludGMgMTAgLy8gMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpdG9iCglleHRyYWN0IDYgMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NjcKCS8vIHJlbW92ZVJldCA9IHRoaXMucmVtb3ZlRnJvbVN0YWtlclBvb2xTZXQoc3Rha2VyLCA8VmFsaWRhdG9yUG9vbEtleT57CgkvLyAgICAgICAgICAgICAgICAgaWQ6IHBvb2xLZXkuaWQsCgkvLyAgICAgICAgICAgICAgICAgcG9vbElkOiBwb29sS2V5LnBvb2xJZCwKCS8vICAgICAgICAgICAgICAgICBwb29sQXBwSWQ6IHBvb2xLZXkucG9vbEFwcElkLAoJLy8gICAgICAgICAgICAgfSkKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDE2IDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC0yIC8vIHN0YWtlcjogQWRkcmVzcwoJY2FsbHN1YiByZW1vdmVGcm9tU3Rha2VyUG9vbFNldAoJZnJhbWVfYnVyeSAxIC8vIHJlbW92ZVJldDogKGJvb2wsYm9vbCkKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NzIKCS8vIHN0YWtlck91dE9mVGhpc1ZhbGlkYXRvciA9IHJlbW92ZVJldFswXQoJZnJhbWVfZGlnIDEgLy8gcmVtb3ZlUmV0OiAoYm9vbCxib29sKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMCAvLyAwCglnZXRiaXQKCWZyYW1lX2J1cnkgMiAvLyBzdGFrZXJPdXRPZlRoaXNWYWxpZGF0b3I6IGJvb2wKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NzMKCS8vIHN0YWtlck91dE9mUHJvdG9jb2wgPSByZW1vdmVSZXRbMV0KCWZyYW1lX2RpZyAxIC8vIHJlbW92ZVJldDogKGJvb2wsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDEgLy8gMQoJZ2V0Yml0CglmcmFtZV9idXJ5IDMgLy8gc3Rha2VyT3V0T2ZQcm90b2NvbDogYm9vbAoKCS8vICppZjIxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Nzc1CgkvLyBzdGFrZXJPdXRPZlRoaXNWYWxpZGF0b3IKCWZyYW1lX2RpZyAyIC8vIHN0YWtlck91dE9mVGhpc1ZhbGlkYXRvcjogYm9vbAoJYnogKmlmMjFfZW5kCgoJLy8gKmlmMjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Nzc2CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUuc3RhdGUudG90YWxTdGFrZXJzIC09IDEKCWludGMgMjMgLy8gMjQ0CglkdXAKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJaW50YyAxIC8vIDEKCS0KCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoqaWYyMV9lbmQ6CgkvLyAqaWYyMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc3OQoJLy8gc3Rha2VyT3V0T2ZQcm90b2NvbAoJZnJhbWVfZGlnIDMgLy8gc3Rha2VyT3V0T2ZQcm90b2NvbDogYm9vbAoJYnogKmlmMjJfZW5kCgoJLy8gKmlmMjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzgwCgkvLyB0aGlzLm51bVN0YWtlcnMudmFsdWUgLT0gMQoJYnl0ZWMgNiAvLyAgIm51bVN0YWtlcnMiCglhcHBfZ2xvYmFsX2dldAoJaW50YyAxIC8vIDEKCS0KCWJ5dGVjIDYgLy8gICJudW1TdGFrZXJzIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCippZjIyX2VuZDoKCippZjIwX2VuZDoKCXJldHN1YgoKLy8gZmluZFBvb2xGb3JTdGFrZXIodWludDY0LGFkZHJlc3MsdWludDY0KSgodWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYm9vbCkKKmFiaV9yb3V0ZV9maW5kUG9vbEZvclN0YWtlcjoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gYW1vdW50VG9TdGFrZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gc3Rha2VyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyA2IC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKHN0YWtlcikgZm9yIGZpbmRQb29sRm9yU3Rha2VyIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBmaW5kUG9vbEZvclN0YWtlcih1aW50NjQsYWRkcmVzcyx1aW50NjQpKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxib29sKQoJY2FsbHN1YiBmaW5kUG9vbEZvclN0YWtlcgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGZpbmRQb29sRm9yU3Rha2VyKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIHN0YWtlcjogQWRkcmVzcywgYW1vdW50VG9TdGFrZTogdWludDY0KTogW1ZhbGlkYXRvclBvb2xLZXksIGJvb2xlYW4sIGJvb2xlYW5dCi8vCi8vIEZpbmRzIHRoZSBwb29sIGZvciBhIHN0YWtlciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgdmFsaWRhdG9yIGlkLCBzdGFrZXIgYWRkcmVzcywgYW5kIGFtb3VudCB0byBzdGFrZS4KLy8gRmlyc3QgY2hlY2tzIHRoZSBzdGFrZXJzICdhbHJlYWR5IHN0YWtlZCBsaXN0JyBmb3IgdGhlIHZhbGlkYXRvciBwcmVmZXJyaW5nIHRob3NlIChhZGRpbmcgaWYgcG9zc2libGUpIHRoZW4gYWRkcwovLyB0byBuZXcgcG9vbCBpZiBuZWNlc3NhcnkuCi8vCi8vIEBwYXJhbSB7VmFsaWRhdG9ySWRUeXBlfSB2YWxpZGF0b3JJZCAtIFRoZSBpZCBvZiB0aGUgdmFsaWRhdG9yLgovLyBAcGFyYW0ge0FkZHJlc3N9IHN0YWtlciAtIFRoZSBhZGRyZXNzIG9mIHRoZSBzdGFrZXIuCi8vIEBwYXJhbSB7dWludDY0fSBhbW91bnRUb1N0YWtlIC0gVGhlIGFtb3VudCB0byBzdGFrZS4KLy8gQHJldHVybnMge1ZhbGlkYXRvclBvb2xLZXksIGJvb2xlYW4sIGJvb2xlYW59IC0gVGhlIHBvb2wgZm9yIHRoZSBzdGFrZXIsIHRydWUvZmFsc2Ugb24gd2hldGhlciB0aGUgc3Rha2VyIGlzICduZXcnCi8vIHRvIHRoaXMgVkFMSURBVE9SLCBhbmQgdHJ1ZS9mYWxzZSBpZiBzdGFrZXIgaXMgbmV3IHRvIHRoZSBwcm90b2NvbC4KZmluZFBvb2xGb3JTdGFrZXI6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiA3CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODAyCgkvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yID0gdHJ1ZQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgMCAvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yOiBib29sCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODAzCgkvLyBpc05ld1N0YWtlclRvUHJvdG9jb2wgPSB0cnVlCglpbnRjIDEgLy8gMQoJZnJhbWVfYnVyeSAxIC8vIGlzTmV3U3Rha2VyVG9Qcm90b2NvbDogYm9vbAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgxMQoJLy8gbWF4UGVyUG9vbCA9IHRoaXMuZ2V0Q3VyTWF4U3Rha2VQZXJQb29sKHZhbGlkYXRvcklkKQoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWNhbGxzdWIgZ2V0Q3VyTWF4U3Rha2VQZXJQb29sCglmcmFtZV9idXJ5IDIgLy8gbWF4UGVyUG9vbDogdWludDY0CgoJLy8gKmlmMjNfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MTQKCS8vIHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLmV4aXN0cwoJYnl0ZWMgMyAvLyAgInNwcyIKCWZyYW1lX2RpZyAtMiAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglieiAqaWYyM19lbmQKCgkvLyAqaWYyM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MTUKCS8vIHBvb2xTZXQgPSBjbG9uZSh0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZSkKCWJ5dGVjIDMgLy8gICJzcHMiCglmcmFtZV9kaWcgLTIgLy8gc3Rha2VyOiBBZGRyZXNzCgljb25jYXQKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlCglhc3NlcnQKCWZyYW1lX2J1cnkgMyAvLyBwb29sU2V0OiAodWludDY0LHVpbnQ2NCx1aW50NjQpWzZdCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODE2CgkvLyBhc3NlcnQodmFsaWRhdG9ySWQgIT09IDApCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaW50YyAwIC8vIDAKCSE9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MTcKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgcG9vbFNldC5sZW5ndGg7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDQgLy8gaTogdWludDY0CgoqZm9yXzM6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MTcKCS8vIGkgPCBwb29sU2V0Lmxlbmd0aAoJZnJhbWVfZGlnIDQgLy8gaTogdWludDY0CglpbnRjIDcgLy8gNgoJPAoJYnogKmZvcl8zX2VuZAoKCS8vICppZjI0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODE4CgkvLyBnbG9iYWxzLm9wY29kZUJ1ZGdldCA8IDMwMAoJZ2xvYmFsIE9wY29kZUJ1ZGdldAoJaW50YyAyOSAvLyAzMDAKCTwKCWJ6ICppZjI0X2VuZAoKCS8vICppZjI0X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgxOQoJLy8gaW5jcmVhc2VPcGNvZGVCdWRnZXQoKQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCWJ5dGVjIDggLy8gICNwcmFnbWEgdmVyc2lvbiAxMDsgaW50IDEKCWR1cAoJaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KCWl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KCWludGMgMjYgLy8gIERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCippZjI0X2VuZDoKCS8vICppZjI1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODIxCgkvLyBwb29sU2V0W2ldLmlkID09PSAwCglmcmFtZV9kaWcgMyAvLyBwb29sU2V0OiAodWludDY0LHVpbnQ2NCx1aW50NjQpWzZdCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgMyAvLyAyNAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDAgLy8gMAoJKwoJaW50YyAyIC8vIDgKCWV4dHJhY3QzCglidG9pCglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjI1X2VuZAoKCS8vICppZjI1X2NvbnNlcXVlbnQKCWIgKmZvcl8zX2NvbnRpbnVlCgoqaWYyNV9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MjQKCS8vIGlzTmV3U3Rha2VyVG9Qcm90b2NvbCA9IGZhbHNlCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAxIC8vIGlzTmV3U3Rha2VyVG9Qcm90b2NvbDogYm9vbAoKCS8vICppZjI2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODI1CgkvLyBwb29sU2V0W2ldLmlkID09PSB2YWxpZGF0b3JJZAoJZnJhbWVfZGlnIDMgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQsdWludDY0KVs2XQoJZnJhbWVfZGlnIDQgLy8gaTogdWludDY0CglpbnRjIDMgLy8gMjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAwIC8vIDAKCSsKCWludGMgMiAvLyA4CglleHRyYWN0MwoJYnRvaQoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCT09CglieiAqaWYyNl9lbmQKCgkvLyAqaWYyNl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MjcKCS8vIGlzTmV3U3Rha2VyVG9WYWxpZGF0b3IgPSBmYWxzZQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMCAvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yOiBib29sCgoJLy8gKmlmMjdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MjkKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUucG9vbHNbcG9vbFNldFtpXS5wb29sSWQgLSAxXS50b3RhbEFsZ29TdGFrZWQgKwoJLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudFRvU3Rha2UgPD0KCS8vICAgICAgICAgICAgICAgICAgICAgICAgIG1heFBlclBvb2wKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIDMgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQsdWludDY0KVs2XQoJZnJhbWVfZGlnIDQgLy8gaTogdWludDY0CglpbnRjIDMgLy8gMjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAyIC8vICBoZWFkT2Zmc2V0CgkrCglpbnRjIDIgLy8gOAoJZXh0cmFjdDMKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAxMSAvLyAgaGVhZE9mZnNldAoJKwoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnRUb1N0YWtlOiB1aW50NjQKCSsKCWZyYW1lX2RpZyAyIC8vIG1heFBlclBvb2w6IHVpbnQ2NAoJPD0KCWJ6ICppZjI3X2VuZAoKCS8vICppZjI3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgzMwoJLy8gcmV0dXJuIFtwb29sU2V0W2ldLCBpc05ld1N0YWtlclRvVmFsaWRhdG9yLCBpc05ld1N0YWtlclRvUHJvdG9jb2xdCglmcmFtZV9kaWcgMyAvLyBwb29sU2V0OiAodWludDY0LHVpbnQ2NCx1aW50NjQpWzZdCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgMyAvLyAyNAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDMgLy8gMjQKCWV4dHJhY3QzCglieXRlYyA1IC8vIDB4MDAKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgMCAvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yOiBib29sCglzZXRiaXQKCWludGMgMSAvLyAxCglmcmFtZV9kaWcgMSAvLyBpc05ld1N0YWtlclRvUHJvdG9jb2w6IGJvb2wKCXNldGJpdAoJY29uY2F0CgliICpmaW5kUG9vbEZvclN0YWtlcipyZXR1cm4KCippZjI3X2VuZDoKCippZjI2X2VuZDoKCipmb3JfM19jb250aW51ZToKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgxNwoJLy8gaSArPSAxCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDQgLy8gaTogdWludDY0CgliICpmb3JfMwoKKmZvcl8zX2VuZDoKCippZjIzX2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg0MAoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgYW1vdW50VG9TdGFrZSA+PSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5taW5FbnRyeVN0YWtlLAoJLy8gICAgICAgICAgICAgJ211c3Qgc3Rha2UgYXQgbGVhc3QgdGhlIG1pbmltdW0gZm9yIHRoaXMgcG9vbCcsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnRUb1N0YWtlOiB1aW50NjQKCWludGMgMzkgLy8gMjA5CglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJPj0KCgkvLyBtdXN0IHN0YWtlIGF0IGxlYXN0IHRoZSBtaW5pbXVtIGZvciB0aGlzIHBvb2wKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg0NgoJLy8gcG9vbHMgPSBjbG9uZSh0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnBvb2xzKQoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglpbnRjIDMwIC8vIDQzMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJZnJhbWVfYnVyeSA1IC8vIHBvb2xzOiAodWludDY0LHVpbnQxNix1aW50NjQpWzI0XQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg0NwoJLy8gY3VyTnVtUG9vbHMgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnN0YXRlLm51bVBvb2xzIGFzIHVpbnQ2NAoJaW50YyA5IC8vIDI0MgoJaW50YyAxMCAvLyAyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDYgLy8gY3VyTnVtUG9vbHM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg0OAoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJOdW1Qb29sczsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNyAvLyBpOiB1aW50NjQKCipmb3JfNDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg0OAoJLy8gaSA8IGN1ck51bVBvb2xzCglmcmFtZV9kaWcgNyAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyA2IC8vIGN1ck51bVBvb2xzOiB1aW50NjQKCTwKCWJ6ICpmb3JfNF9lbmQKCgkvLyAqaWYyOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg0OQoJLy8gcG9vbHNbaV0udG90YWxBbGdvU3Rha2VkICsgYW1vdW50VG9TdGFrZSA8PSBtYXhQZXJQb29sCglmcmFtZV9kaWcgNSAvLyBwb29sczogKHVpbnQ2NCx1aW50MTYsdWludDY0KVsyNF0KCWZyYW1lX2RpZyA3IC8vIGk6IHVpbnQ2NAoJaW50YyA0IC8vIDE4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMTEgLy8gIGhlYWRPZmZzZXQKCSsKCWludGMgMiAvLyA4CglleHRyYWN0MwoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudFRvU3Rha2U6IHVpbnQ2NAoJKwoJZnJhbWVfZGlnIDIgLy8gbWF4UGVyUG9vbDogdWludDY0Cgk8PQoJYnogKmlmMjhfZW5kCgoJLy8gKmlmMjhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODUwCgkvLyByZXR1cm4gWwoJLy8gICAgICAgICAgICAgICAgICAgICB7IGlkOiB2YWxpZGF0b3JJZCwgcG9vbElkOiBpICsgMSwgcG9vbEFwcElkOiBwb29sc1tpXS5wb29sQXBwSWQgfSwKCS8vICAgICAgICAgICAgICAgICAgICAgaXNOZXdTdGFrZXJUb1ZhbGlkYXRvciwKCS8vICAgICAgICAgICAgICAgICAgICAgaXNOZXdTdGFrZXJUb1Byb3RvY29sLAoJLy8gICAgICAgICAgICAgICAgIF0KCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCglmcmFtZV9kaWcgNyAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyA1IC8vIHBvb2xzOiAodWludDY0LHVpbnQxNix1aW50NjQpWzI0XQoJZnJhbWVfZGlnIDcgLy8gaTogdWludDY0CglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAwIC8vIDAKCSsKCWludGMgMiAvLyA4CglleHRyYWN0MwoJYnRvaQoJaXRvYgoJY29uY2F0CglieXRlYyA1IC8vIDB4MDAKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgMCAvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yOiBib29sCglzZXRiaXQKCWludGMgMSAvLyAxCglmcmFtZV9kaWcgMSAvLyBpc05ld1N0YWtlclRvUHJvdG9jb2w6IGJvb2wKCXNldGJpdAoJY29uY2F0CgliICpmaW5kUG9vbEZvclN0YWtlcipyZXR1cm4KCippZjI4X2VuZDoKCipmb3JfNF9jb250aW51ZToKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg0OAoJLy8gaSArPSAxCglmcmFtZV9kaWcgNyAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDcgLy8gaTogdWludDY0CgliICpmb3JfNAoKKmZvcl80X2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg1OAoJLy8gcmV0dXJuIFt7IGlkOiB2YWxpZGF0b3JJZCwgcG9vbElkOiAwLCBwb29sQXBwSWQ6IDAgfSwgaXNOZXdTdGFrZXJUb1ZhbGlkYXRvciwgaXNOZXdTdGFrZXJUb1Byb3RvY29sXQoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWJ5dGVjIDcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCgljb25jYXQKCWJ5dGVjIDcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCgljb25jYXQKCWJ5dGVjIDUgLy8gMHgwMAoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAwIC8vIGlzTmV3U3Rha2VyVG9WYWxpZGF0b3I6IGJvb2wKCXNldGJpdAoJaW50YyAxIC8vIDEKCWZyYW1lX2RpZyAxIC8vIGlzTmV3U3Rha2VyVG9Qcm90b2NvbDogYm9vbAoJc2V0Yml0Cgljb25jYXQKCipmaW5kUG9vbEZvclN0YWtlcipyZXR1cm46CgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiA3CglyZXRzdWIKCi8vIG1vdmVQb29sVG9Ob2RlKHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9tb3ZlUG9vbFRvTm9kZToKCS8vIG5vZGVOdW06IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIHBvb2xBcHBJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgbW92ZVBvb2xUb05vZGUodWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBtb3ZlUG9vbFRvTm9kZQoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gbW92ZVBvb2xUb05vZGUodmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSwgcG9vbEFwcElkOiB1aW50NjQsIG5vZGVOdW06IHVpbnQ2NCk6IHZvaWQKLy8KLy8gRmluZCB0aGUgc3BlY2lmaWVkIHBvb2wgKGluIGFueSBub2RlIG51bWJlcikgYW5kIG1vdmUgaXQgdG8gdGhlIHNwZWNpZmllZCBub2RlLgovLyBUaGUgcG9vbCBhY2NvdW50IGlzIGZvcmNlZCBvZmZsaW5lIGlmIG1vdmVkIHNvIHByaW9yIG5vZGUgd2lsbCBzdGlsbCBydW4gZm9yIDMyMCByb3VuZHMgYnV0Ci8vIG5ldyBrZXkgZ29lcyBvbmxpbmUgb24gbmV3IG5vZGUgc29vbiBhZnRlciAoMzIwIHJvdW5kcyBhZnRlciBpdCBnb2VzIG9ubGluZSkKLy8gTm8tb3AgaWYgc3VjY2VzcywgYXNzZXJ0cyBpZiBub3QgZm91bmQgb3IgY2FuJ3QgbW92ZSAgKG5vIHNwYWNlIGluIHRhcmdldCkKLy8gWyBPTkxZIE9XTkVSIE9SIE1BTkFHRVIgQ0FOIENIQU5HRSBdCi8vCi8vIEBwYXJhbSB7VmFsaWRhdG9ySWRUeXBlfSB2YWxpZGF0b3JJZCAtIFRoZSBpZCBvZiB0aGUgdmFsaWRhdG9yLgovLyBAcGFyYW0ge3VpbnQ2NH0gcG9vbEFwcElkCi8vIEBwYXJhbSB7dWludDY0fSBub2RlTnVtCm1vdmVQb29sVG9Ob2RlOgoJcHJvdG8gMyAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDEgLy8gMHgKCWR1cG4gMgoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg3MwoJLy8gdGhpcy5jYWxsZXJNdXN0QmVPd25lck9yTWFuYWdlcih2YWxpZGF0b3JJZCkKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgljYWxsc3ViIGNhbGxlck11c3RCZU93bmVyT3JNYW5hZ2VyCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODc1CgkvLyBub2RlUG9vbEFzc2lnbm1lbnRzID0gY2xvbmUodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5ub2RlUG9vbEFzc2lnbm1lbnRzKQoJaW50YyAxNyAvLyAgaGVhZE9mZnNldAoJaW50YyAyMiAvLyAxOTIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWZyYW1lX2J1cnkgMCAvLyBub2RlUG9vbEFzc2lnbm1lbnRzOiAoKHVpbnQ2NFszXSlbOF0pCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODc2CgkvLyBhc3NlcnQobm9kZU51bSA+PSAxICYmIG5vZGVOdW0gPD0gTUFYX05PREVTLCAnbm9kZSBudW1iZXIgb3V0IG9mIGFsbG93YWJsZSByYW5nZScpCglmcmFtZV9kaWcgLTMgLy8gbm9kZU51bTogdWludDY0CglpbnRjIDEgLy8gMQoJPj0KCWR1cAoJYnogKnNraXBfYW5kMgoJZnJhbWVfZGlnIC0zIC8vIG5vZGVOdW06IHVpbnQ2NAoJaW50YyAyIC8vIDgKCTw9CgkmJgoKKnNraXBfYW5kMjoKCS8vIG5vZGUgbnVtYmVyIG91dCBvZiBhbGxvd2FibGUgcmFuZ2UKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg3OAoJLy8gZm9yIChsZXQgc3JjTm9kZUlkeCA9IDA7IHNyY05vZGVJZHggPCBNQVhfTk9ERVM7IHNyY05vZGVJZHggKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDEgLy8gc3JjTm9kZUlkeDogdWludDY0CgoqZm9yXzU6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4NzgKCS8vIHNyY05vZGVJZHggPCBNQVhfTk9ERVMKCWZyYW1lX2RpZyAxIC8vIHNyY05vZGVJZHg6IHVpbnQ2NAoJaW50YyAyIC8vIDgKCTwKCWJ6ICpmb3JfNV9lbmQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4NzkKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX1BPT0xTX1BFUl9OT0RFOyBpICs9IDEpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoKKmZvcl82OgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODc5CgkvLyBpIDwgTUFYX1BPT0xTX1BFUl9OT0RFCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgOCAvLyAzCgk8CglieiAqZm9yXzZfZW5kCgoJLy8gKmlmMjlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4ODAKCS8vIG5vZGVQb29sQXNzaWdubWVudHMubm9kZXNbc3JjTm9kZUlkeF0ucG9vbEFwcElkc1tpXSA9PT0gcG9vbEFwcElkCglmcmFtZV9kaWcgMCAvLyBub2RlUG9vbEFzc2lnbm1lbnRzOiAoKHVpbnQ2NFszXSlbOF0pCglpbnRjIDAgLy8gMAoJZnJhbWVfZGlnIDEgLy8gc3JjTm9kZUlkeDogdWludDY0CglpbnRjIDMgLy8gMjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAwIC8vIDAKCSsKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAyIC8vIDgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAyIC8vIDgKCWV4dHJhY3QzCglidG9pCglmcmFtZV9kaWcgLTIgLy8gcG9vbEFwcElkOiB1aW50NjQKCT09CglieiAqaWYyOV9lbmQKCgkvLyAqaWYyOV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4ODEKCS8vIGFzc2VydChub2RlTnVtIC0gMSAhPT0gc3JjTm9kZUlkeCwgImNhbid0IG1vdmUgdG8gc2FtZSBub2RlIikKCWZyYW1lX2RpZyAtMyAvLyBub2RlTnVtOiB1aW50NjQKCWludGMgMSAvLyAxCgktCglmcmFtZV9kaWcgMSAvLyBzcmNOb2RlSWR4OiB1aW50NjQKCSE9CgoJLy8gY2FuJ3QgbW92ZSB0byBzYW1lIG5vZGUKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg4MwoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5ub2RlUG9vbEFzc2lnbm1lbnRzLm5vZGVzW3NyY05vZGVJZHhdLnBvb2xBcHBJZHNbaV0gPSAwCglpbnRjIDE3IC8vIDkwMAoJZnJhbWVfZGlnIDEgLy8gc3JjTm9kZUlkeDogdWludDY0CglpbnRjIDMgLy8gMjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAwIC8vIDAKCSsKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAyIC8vIDgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJYnl0ZWMgNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4ODYKCS8vIHNlbmRNZXRob2RDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuZ29PZmZsaW5lPih7CgkvLyAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KHBvb2xBcHBJZCksCgkvLyAgICAgICAgICAgICAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDcgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCXB1c2hieXRlcyAweDUxZWYzYjIxIC8vIG1ldGhvZCAiZ29PZmZsaW5lKCl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4ODcKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQocG9vbEFwcElkKQoJZnJhbWVfZGlnIC0yIC8vIHBvb2xBcHBJZDogdWludDY0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODkxCgkvLyB0aGlzLmFkZFBvb2xUb05vZGUodmFsaWRhdG9ySWQsIHBvb2xBcHBJZCwgbm9kZU51bSkKCWZyYW1lX2RpZyAtMyAvLyBub2RlTnVtOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBwb29sQXBwSWQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWNhbGxzdWIgYWRkUG9vbFRvTm9kZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg5MgoJLy8gcmV0dXJuCglyZXRzdWIKCippZjI5X2VuZDoKCipmb3JfNl9jb250aW51ZToKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg3OQoJLy8gaSArPSAxCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDIgLy8gaTogdWludDY0CgliICpmb3JfNgoKKmZvcl82X2VuZDoKCipmb3JfNV9jb250aW51ZToKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg3OAoJLy8gc3JjTm9kZUlkeCArPSAxCglmcmFtZV9kaWcgMSAvLyBzcmNOb2RlSWR4OiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDEgLy8gc3JjTm9kZUlkeDogdWludDY0CgliICpmb3JfNQoKKmZvcl81X2VuZDoKCS8vIGNvdWxkbid0IGZpbmQgcG9vbCBhcHAgaWQgaW4gbm9kZXMgdG8gbW92ZQoJZXJyCglyZXRzdWIKCi8vIGVtcHR5VG9rZW5SZXdhcmRzKHVpbnQ2NCxhZGRyZXNzKXVpbnQ2NAoqYWJpX3JvdXRlX2VtcHR5VG9rZW5SZXdhcmRzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyByZWNlaXZlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgNiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChyZWNlaXZlcikgZm9yIGVtcHR5VG9rZW5SZXdhcmRzIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBlbXB0eVRva2VuUmV3YXJkcyh1aW50NjQsYWRkcmVzcyl1aW50NjQKCWNhbGxzdWIgZW1wdHlUb2tlblJld2FyZHMKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBlbXB0eVRva2VuUmV3YXJkcyh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCByZWNlaXZlcjogQWRkcmVzcyk6IHVpbnQ2NAovLwovLyBTZW5kcyB0aGUgcmV3YXJkIHRva2VucyBoZWxkIGluIHBvb2wgMSB0byBzcGVjaWZpZWQgcmVjZWl2ZXIuCi8vIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBieSB0aGUgb3duZXIgd2hlbiB0aGV5IHdhbnQgdG8gZ2V0IHJld2FyZCB0b2tlbnMgJ2JhY2snIHdoaWNoIHRoZXkgc2VudCB0bwovLyB0aGUgZmlyc3QgcG9vbCAobGlrZWx5IGJlY2F1c2UgdmFsaWRhdG9yIGlzIHN1bnNldHRpbmcuICBBbnkgdG9rZW5zIGN1cnJlbnRseSAncmVzZXJ2ZWQnIGZvciBzdGFrZXJzIHRvIGNsYWltIHdpbGwKLy8gTk9UIGJlIHNlbnQgYXMgdGhleSBtdXN0IGJlIGhlbGQgYmFjayBmb3Igc3Rha2VycyB0byBsYXRlciBjbGFpbS4KLy8gWyBPTkxZIE9XTkVSIENBTiBDQUxMXQovLwovLyBAcGFyYW0ge1ZhbGlkYXRvcklkVHlwZX0gdmFsaWRhdG9ySWQgLSBUaGUgaWQgb2YgdGhlIHZhbGlkYXRvci4KLy8gQHBhcmFtIHtBZGRyZXNzfSByZWNlaXZlciAtIHRoZSBhY2NvdW50IHRvIHNlbmQgdGhlIHRva2VucyB0byAobXVzdCBhbHJlYWR5IGJlIG9wdGVkLWluIHRvIHRoZSByZXdhcmQgdG9rZW4pCi8vIEByZXR1cm5zIHt1aW50NjR9IHRoZSBhbW91bnQgb2YgcmV3YXJkIHRva2VuIHNlbnQKZW1wdHlUb2tlblJld2FyZHM6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiAzCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTExCgkvLyB0aGlzLmNhbGxlck11c3RCZU93bmVyKHZhbGlkYXRvcklkKQoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWNhbGxzdWIgY2FsbGVyTXVzdEJlT3duZXIKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MTIKCS8vIHJld2FyZFRva2VuSWQgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5yZXdhcmRUb2tlbklkCglpbnRjIDM4IC8vIDE1MwoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgMCAvLyByZXdhcmRUb2tlbklkOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MTMKCS8vIHJld2FyZFRva2VuSGVsZEJhY2sgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnN0YXRlLnJld2FyZFRva2VuSGVsZEJhY2sKCWludGMgMTMgLy8gMjYwCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAxIC8vIHJld2FyZFRva2VuSGVsZEJhY2s6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjkxNAoJLy8gYXNzZXJ0KHJld2FyZFRva2VuSWQgIT09IDAsICJ0aGlzIHZhbGlkYXRvciBkb2Vzbid0IGhhdmUgYSByZXdhcmQgdG9rZW4gZGVmaW5lZCIpCglmcmFtZV9kaWcgMCAvLyByZXdhcmRUb2tlbklkOiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoKCS8vIHRoaXMgdmFsaWRhdG9yIGRvZXNuJ3QgaGF2ZSBhIHJld2FyZCB0b2tlbiBkZWZpbmVkCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MTUKCS8vIHBvb2xPbmVBcHBJZCA9IEFwcElELmZyb21VaW50NjQodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29sc1swXS5wb29sQXBwSWQpCglpbnRjIDUgLy8gMjY4CglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAyIC8vIHBvb2xPbmVBcHBJZDogdWludDY0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTE3CgkvLyB0b2tlblJld2FyZEJhbCA9CgkvLyAgICAgICAgICAgICBwb29sT25lQXBwSWQuYWRkcmVzcy5hc3NldEJhbGFuY2UoQXNzZXRJRC5mcm9tVWludDY0KHJld2FyZFRva2VuSWQpKSAtIHJld2FyZFRva2VuSGVsZEJhY2sKCWZyYW1lX2RpZyAyIC8vIHBvb2xPbmVBcHBJZDogdWludDY0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWZyYW1lX2RpZyAwIC8vIHJld2FyZFRva2VuSWQ6IHVpbnQ2NAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAxIC8vIHJld2FyZFRva2VuSGVsZEJhY2s6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSAzIC8vIHRva2VuUmV3YXJkQmFsOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MjEKCS8vIHNlbmRNZXRob2RDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUucGF5VG9rZW5SZXdhcmQ+KHsKCS8vICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IHBvb2xPbmVBcHBJZCwKCS8vICAgICAgICAgICAgIG1ldGhvZEFyZ3M6IFtyZWNlaXZlciwgcmV3YXJkVG9rZW5JZCwgdG9rZW5SZXdhcmRCYWxdLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglieXRlYyAxMyAvLyAgbWV0aG9kICJwYXlUb2tlblJld2FyZChhZGRyZXNzLHVpbnQ2NCx1aW50NjQpdm9pZCIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTIyCgkvLyBhcHBsaWNhdGlvbklEOiBwb29sT25lQXBwSWQKCWZyYW1lX2RpZyAyIC8vIHBvb2xPbmVBcHBJZDogdWludDY0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MjMKCS8vIG1ldGhvZEFyZ3M6IFtyZWNlaXZlciwgcmV3YXJkVG9rZW5JZCwgdG9rZW5SZXdhcmRCYWxdCglmcmFtZV9kaWcgLTIgLy8gcmVjZWl2ZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgMCAvLyByZXdhcmRUb2tlbklkOiB1aW50NjQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgMyAvLyB0b2tlblJld2FyZEJhbDogdWludDY0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MjUKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIHBvb2xPbmVBcHBJZC5hZGRyZXNzLmFzc2V0QmFsYW5jZShBc3NldElELmZyb21VaW50NjQocmV3YXJkVG9rZW5JZCkpID09PSByZXdhcmRUb2tlbkhlbGRCYWNrLAoJLy8gICAgICAgICAgICAgJ2JhbGFuY2Ugb2YgcmVtYWluaW5nIHJld2FyZCB0b2tlbnMgc2hvdWxkIG1hdGNoIHRoZSBoZWxkIGJhY2sgYW1vdW50JywKCS8vICAgICAgICAgKQoJZnJhbWVfZGlnIDIgLy8gcG9vbE9uZUFwcElkOiB1aW50NjQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJZnJhbWVfZGlnIDAgLy8gcmV3YXJkVG9rZW5JZDogdWludDY0Cglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIDEgLy8gcmV3YXJkVG9rZW5IZWxkQmFjazogdWludDY0Cgk9PQoKCS8vIGJhbGFuY2Ugb2YgcmVtYWluaW5nIHJld2FyZCB0b2tlbnMgc2hvdWxkIG1hdGNoIHRoZSBoZWxkIGJhY2sgYW1vdW50Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MjkKCS8vIHJldHVybiB0b2tlblJld2FyZEJhbAoJZnJhbWVfZGlnIDMgLy8gdG9rZW5SZXdhcmRCYWw6IHVpbnQ2NAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDMKCXJldHN1YgoKLy8gY2FsbGVyTXVzdEJlT3duZXIodmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSk6IHZvaWQKY2FsbGVyTXVzdEJlT3duZXI6Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDIyCgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICB0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm93bmVyLAoJLy8gICAgICAgICAgICAgJ2NhbiBvbmx5IGJlIGNhbGxlZCBieSB2YWxpZGF0b3Igb3duZXInLAoJLy8gICAgICAgICApCgl0eG4gU2VuZGVyCglpbnRjIDIgLy8gOAoJaW50YyA2IC8vIDMyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0Cgk9PQoKCS8vIGNhbiBvbmx5IGJlIGNhbGxlZCBieSB2YWxpZGF0b3Igb3duZXIKCWFzc2VydAoJcmV0c3ViCgovLyBjYWxsZXJNdXN0QmVPd25lck9yTWFuYWdlcih2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlKTogdm9pZApjYWxsZXJNdXN0QmVPd25lck9yTWFuYWdlcjoKCXByb3RvIDEgMAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMjkKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIHRoaXMudHhuLnNlbmRlciA9PT0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcub3duZXIgfHwKCS8vICAgICAgICAgICAgICAgICB0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1hbmFnZXIsCgkvLyAgICAgICAgICAgICAnY2FuIG9ubHkgYmUgY2FsbGVkIGJ5IG93bmVyIG9yIG1hbmFnZXIgb2YgdmFsaWRhdG9yJywKCS8vICAgICAgICAgKQoJdHhuIFNlbmRlcgoJaW50YyAyIC8vIDgKCWludGMgNiAvLyAzMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJPT0KCWR1cAoJYm56ICpza2lwX29yMwoJdHhuIFNlbmRlcgoJaW50YyAyMCAvLyA0MAoJaW50YyA2IC8vIDMyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0Cgk9PQoJfHwKCipza2lwX29yMzoKCS8vIGNhbiBvbmx5IGJlIGNhbGxlZCBieSBvd25lciBvciBtYW5hZ2VyIG9mIHZhbGlkYXRvcgoJYXNzZXJ0CglyZXRzdWIKCi8vIHZlcmlmeVBvb2xLZXlDYWxsZXIocG9vbEtleTogVmFsaWRhdG9yUG9vbEtleSk6IHZvaWQKLy8KLy8gdmVyaWZ5UG9vbEtleUNhbGxlciB2ZXJpZmllcyB0aGUgcGFzc2VkIGluIGtleSAoZnJvbSBhIHN0YWtpbmcgcG9vbCBjYWxsaW5nIHVzIHRvIHVwZGF0ZSBtZXRyaWNzKSBpcyB2YWxpZAovLyBhbmQgbWF0Y2hlcyB0aGUgaW5mb3JtYXRpb24gd2UgaGF2ZSBpbiBvdXIgc3RhdGUuICAnRmFrZScgcG9vbHMgY291bGQgY2FsbCB1cyB0byB1cGRhdGUgb3VyIGRhdGEsIGJ1dCB0aGV5Ci8vIGNhbid0IGZha2UgdGhlIGlkcyBhbmQgbW9zdCBpbXBvcnRhbnRseSBhcHBsaWNhdGlvbiBpZCghKSBvZiB0aGUgY2FsbGVyIHRoYXQgaGFzIHRvIG1hdGNoLgp2ZXJpZnlQb29sS2V5Q2FsbGVyOgoJcHJvdG8gMSAwCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA0MgoJLy8gYXNzZXJ0KHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS5leGlzdHMsICJ0aGUgc3BlY2lmaWVkIHZhbGlkYXRvciBpZCBpc24ndCB2YWxpZCIpCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cglib3hfbGVuCglzd2FwCglwb3AKCgkvLyB0aGUgc3BlY2lmaWVkIHZhbGlkYXRvciBpZCBpc24ndCB2YWxpZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA0MwoJLy8gYXNzZXJ0KHBvb2xLZXkucG9vbElkIDw9IE1BWF9QT09MUywgJ3Bvb2wgaWQgbm90IGluIHZhbGlkIHJhbmdlJykKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50YyAzIC8vIDI0Cgk8PQoKCS8vIHBvb2wgaWQgbm90IGluIHZhbGlkIHJhbmdlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDQ0CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICBwb29sS2V5LnBvb2xJZCA+IDAgJiYgKHBvb2xLZXkucG9vbElkIGFzIHVpbnQxNikgPD0gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLm51bVBvb2xzLAoJLy8gICAgICAgICAgICAgJ3Bvb2wgaWQgb3V0c2lkZSBvZiByYW5nZSBvZiBwb29scyBjcmVhdGVkIGZvciB0aGlzIHZhbGlkYXRvcicsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50YyAwIC8vIDAKCT4KCWR1cAoJYnogKnNraXBfYW5kMwoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnRjIDkgLy8gMjQyCglpbnRjIDEwIC8vIDIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCgk8PQoJJiYKCipza2lwX2FuZDM6CgkvLyBwb29sIGlkIG91dHNpZGUgb2YgcmFuZ2Ugb2YgcG9vbHMgY3JlYXRlZCBmb3IgdGhpcyB2YWxpZGF0b3IKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNTAKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIHBvb2xLZXkucG9vbEFwcElkID09PSB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXS5wb29sQXBwSWQsCgkvLyAgICAgICAgICAgICAiVGhlIHBhc3NlZCBpbiBhcHAgaWQgZG9lc24ndCBtYXRjaCB0aGUgcGFzc2VkIGluIGlkcyIsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDE2IDgKCWJ0b2kKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnRjIDEgLy8gMQoJLQoJaW50YyA0IC8vIDE4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMCAvLyAwCgkrCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCT09CgoJLy8gVGhlIHBhc3NlZCBpbiBhcHAgaWQgZG9lc24ndCBtYXRjaCB0aGUgcGFzc2VkIGluIGlkcwoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA1NQoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gQXBwSUQuZnJvbVVpbnQ2NChwb29sS2V5LnBvb2xBcHBJZCkuYWRkcmVzcykKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDE2IDgKCWJ0b2kKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNTcKCS8vIGFzc2VydChwb29sS2V5LmlkID09PSAoQXBwSUQuZnJvbVVpbnQ2NChwb29sS2V5LnBvb2xBcHBJZCkuZ2xvYmFsU3RhdGUoJ3ZhbGlkYXRvcklkJykgYXMgdWludDY0KSkKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMTYgOAoJYnRvaQoJcHVzaGJ5dGVzIDB4NzY2MTZjNjk2NDYxNzQ2ZjcyNDk2NCAvLyAidmFsaWRhdG9ySWQiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChwb29sS2V5LnBvb2xBcHBJZCkuZ2xvYmFsU3RhdGUoJ3ZhbGlkYXRvcklkJykKCWFzc2VydAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNTgKCS8vIGFzc2VydChwb29sS2V5LnBvb2xJZCA9PT0gKEFwcElELmZyb21VaW50NjQocG9vbEtleS5wb29sQXBwSWQpLmdsb2JhbFN0YXRlKCdwb29sSWQnKSBhcyB1aW50NjQpKQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAxNiA4CglidG9pCglwdXNoYnl0ZXMgMHg3MDZmNmY2YzQ5NjQgLy8gInBvb2xJZCIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KHBvb2xLZXkucG9vbEFwcElkKS5nbG9iYWxTdGF0ZSgncG9vbElkJykKCWFzc2VydAoJPT0KCWFzc2VydAoJcmV0c3ViCgovLyByZXZlcmlmeU5GRE93bmVyc2hpcCh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlKTogdm9pZAovLwovLyBUaGlzIG1ldGhvZCB2ZXJpZmllcyB0aGUgb3duZXJzaGlwIG9mIE5GRCAoTmFtZWQgRnVuY3Rpb24gRGF0YSkgYnkgYSB2YWxpZGF0b3IuCi8vIElmIHRoZSBvd25lcnNoaXAgaXMgbm8gbG9uZ2VyIHZhbGlkLCBpdCByZW1vdmVzIHRoZSBORkQgZnJvbSB0aGUgdmFsaWRhdG9yJ3MgY29uZmlndXJhdGlvbi4KLy8KLy8gQHBhcmFtIHtWYWxpZGF0b3JJZFR5cGV9IHZhbGlkYXRvcklkIC0gVGhlIGlkIG9mIHRoZSB2YWxpZGF0b3Igd2hvc2UgZGF0YSBzaG91bGQgYmUgcmUtZXZhbHVhdGVkLgpyZXZlcmlmeU5GRE93bmVyc2hpcDoKCXByb3RvIDEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXAKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDY4CgkvLyB2YWxpZGF0b3JDb25maWcgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZwoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL3ZhbGlkYXRvckNvbmZpZwoKCS8vICppZjMwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA2OQoJLy8gdmFsaWRhdG9yQ29uZmlnLm5mZEZvckluZm8gIT09IDAKCWludGMgMjEgLy8gNzIKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjMwX2VuZAoKCS8vICppZjMwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNzIKCS8vIG5mZE93bmVyID0gQXBwSUQuZnJvbVVpbnQ2NCh2YWxpZGF0b3JDb25maWcubmZkRm9ySW5mbykuZ2xvYmFsU3RhdGUoJ2kub3duZXIuYScpIGFzIEFkZHJlc3MKCWludGMgMjEgLy8gNzIKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglieXRlYyAxMCAvLyAgImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KHZhbGlkYXRvckNvbmZpZy5uZmRGb3JJbmZvKS5nbG9iYWxTdGF0ZSgnaS5vd25lci5hJykKCWFzc2VydAoJZnJhbWVfYnVyeSAxIC8vIG5mZE93bmVyOiBhZGRyZXNzCgoJLy8gKmlmMzFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDc0CgkvLyB2YWxpZGF0b3JDb25maWcub3duZXIgIT09IG5mZE93bmVyICYmIHZhbGlkYXRvckNvbmZpZy5tYW5hZ2VyICE9PSBuZmRPd25lcgoJaW50YyAyIC8vIDgKCWludGMgNiAvLyAzMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJZnJhbWVfZGlnIDEgLy8gbmZkT3duZXI6IGFkZHJlc3MKCSE9CglkdXAKCWJ6ICpza2lwX2FuZDQKCWludGMgMjAgLy8gNDAKCWludGMgNiAvLyAzMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJZnJhbWVfZGlnIDEgLy8gbmZkT3duZXI6IGFkZHJlc3MKCSE9CgkmJgoKKnNraXBfYW5kNDoKCWJ6ICppZjMxX2VuZAoKCS8vICppZjMxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNzYKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm5mZEZvckluZm8gPSAwCglpbnRjIDIxIC8vIDcyCglieXRlYyA3IC8vIDB4MDAwMDAwMDAwMDAwMDAwMAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKKmlmMzFfZW5kOgoKKmlmMzBfZW5kOgoJcmV0c3ViCgovLyB2YWxpZGF0ZUNvbmZpZyhjb25maWc6IFZhbGlkYXRvckNvbmZpZyk6IHZvaWQKdmFsaWRhdGVDb25maWc6Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDgzCgkvLyBhc3NlcnQoY29uZmlnLm93bmVyICE9PSBBZGRyZXNzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDggMzIKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwODQKCS8vIGFzc2VydChjb25maWcubWFuYWdlciAhPT0gQWRkcmVzcy56ZXJvQWRkcmVzcykKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCA0MCAzMgoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA4NQoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gY29uZmlnLm93bmVyLCAnc2VuZGVyIG11c3QgYmUgb3duZXIgdG8gYWRkIG5ldyB2YWxpZGF0b3InKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDggMzIKCT09CgoJLy8gc2VuZGVyIG11c3QgYmUgb3duZXIgdG8gYWRkIG5ldyB2YWxpZGF0b3IKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwODcKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIGNvbmZpZy5lbnRyeUdhdGluZ1R5cGUgPj0gR0FUSU5HX1RZUEVfTk9ORSAmJiBjb25maWcuZW50cnlHYXRpbmdUeXBlIDw9IEdBVElOR19UWVBFX0NPTlNUX01BWCwKCS8vICAgICAgICAgICAgICdnYXRpbmcgdHlwZSBub3QgdmFsaWQnLAoJLy8gICAgICAgICApCglmcmFtZV9kaWcgLTEgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgODAgMQoJYnRvaQoJaW50YyAwIC8vIDAKCT49CglkdXAKCWJ6ICpza2lwX2FuZDUKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCA4MCAxCglidG9pCglpbnRjIDE1IC8vIDQKCTw9CgkmJgoKKnNraXBfYW5kNToKCS8vIGdhdGluZyB0eXBlIG5vdCB2YWxpZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA5MQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgY29uZmlnLmVwb2NoUm91bmRMZW5ndGggPj0gTUlOX0VQT0NIX0xFTkdUSCAmJiBjb25maWcuZXBvY2hSb3VuZExlbmd0aCA8PSBNQVhfRVBPQ0hfTEVOR1RILAoJLy8gICAgICAgICAgICAgJ2Vwb2NoIGxlbmd0aCBub3QgaW4gYWxsb3dhYmxlIHJhbmdlJywKCS8vICAgICAgICAgKQoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDE2OSA0CglidG9pCglpbnRjIDEgLy8gMQoJPj0KCWR1cAoJYnogKnNraXBfYW5kNgoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDE2OSA0CglidG9pCglpbnRjIDI0IC8vIDEwMDAwMDAKCTw9CgkmJgoKKnNraXBfYW5kNjoKCS8vIGVwb2NoIGxlbmd0aCBub3QgaW4gYWxsb3dhYmxlIHJhbmdlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDk1CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICBjb25maWcucGVyY2VudFRvVmFsaWRhdG9yID49IE1JTl9QQ1RfVE9fVkFMSURBVE9SICYmIGNvbmZpZy5wZXJjZW50VG9WYWxpZGF0b3IgPD0gTUFYX1BDVF9UT19WQUxJREFUT1IsCgkvLyAgICAgICAgICAgICAnY29tbWlzc2lvbiBwZXJjZW50YWdlIG5vdCB2YWxpZCcsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAxNzMgNAoJYnRvaQoJaW50YyAwIC8vIDAKCT49CglkdXAKCWJ6ICpza2lwX2FuZDcKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAxNzMgNAoJYnRvaQoJaW50YyAyNCAvLyAxMDAwMDAwCgk8PQoJJiYKCipza2lwX2FuZDc6CgkvLyBjb21taXNzaW9uIHBlcmNlbnRhZ2Ugbm90IHZhbGlkCglhc3NlcnQKCgkvLyAqaWYzMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwOTkKCS8vIGNvbmZpZy5wZXJjZW50VG9WYWxpZGF0b3IgIT09IDAKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAxNzMgNAoJYnRvaQoJaW50YyAwIC8vIDAKCSE9CglieiAqaWYzMl9lbmQKCgkvLyAqaWYzMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTAwCgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICAgICAgY29uZmlnLnZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzICE9PSBBZGRyZXNzLnplcm9BZGRyZXNzLAoJLy8gICAgICAgICAgICAgICAgICd2YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyBtdXN0IGJlIHNldCBpZiBwZXJjZW50IHRvIHZhbGlkYXRvciBpcyBub3QgMCcsCgkvLyAgICAgICAgICAgICApCglmcmFtZV9kaWcgLTEgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgMTc3IDMyCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9CgoJLy8gdmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3MgbXVzdCBiZSBzZXQgaWYgcGVyY2VudCB0byB2YWxpZGF0b3IgaXMgbm90IDAKCWFzc2VydAoKKmlmMzJfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEwNQoJLy8gYXNzZXJ0KGNvbmZpZy5taW5FbnRyeVN0YWtlID49IE1JTl9BTEdPX1NUQUtFX1BFUl9QT09MLCAnc3Rha2luZyBwb29sIG11c3QgaGF2ZSBtaW5pbXVtIGVudHJ5IG9mIDEgYWxnbycpCglmcmFtZV9kaWcgLTEgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgMjA5IDgKCWJ0b2kKCWludGMgMjQgLy8gMTAwMDAwMAoJPj0KCgkvLyBzdGFraW5nIHBvb2wgbXVzdCBoYXZlIG1pbmltdW0gZW50cnkgb2YgMSBhbGdvCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTA3CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICBjb25maWcucG9vbHNQZXJOb2RlID4gMCAmJiBjb25maWcucG9vbHNQZXJOb2RlIDw9IE1BWF9QT09MU19QRVJfTk9ERSwKCS8vICAgICAgICAgICAgICdudW1iZXIgb2YgcG9vbHMgcGVyIG5vZGUgbXVzdCBiZSBiZSBiZXR3ZWVuIDEgYW5kIHRoZSBtYXhpbXVtIGFsbG93ZWQgbnVtYmVyJywKCS8vICAgICAgICAgKQoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDIyNSAxCglidG9pCglpbnRjIDAgLy8gMAoJPgoJZHVwCglieiAqc2tpcF9hbmQ4CglmcmFtZV9kaWcgLTEgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgMjI1IDEKCWJ0b2kKCWludGMgOCAvLyAzCgk8PQoJJiYKCipza2lwX2FuZDg6CgkvLyBudW1iZXIgb2YgcG9vbHMgcGVyIG5vZGUgbXVzdCBiZSBiZSBiZXR3ZWVuIDEgYW5kIHRoZSBtYXhpbXVtIGFsbG93ZWQgbnVtYmVyCglhc3NlcnQKCgkvLyAqaWYzM19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMTEKCS8vIGNvbmZpZy5zdW5zZXR0aW5nT24gIT09IDAKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAyMjYgOAoJYnRvaQoJaW50YyAwIC8vIDAKCSE9CglieiAqaWYzM19lbmQKCgkvLyAqaWYzM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTEyCgkvLyBhc3NlcnQoY29uZmlnLnN1bnNldHRpbmdPbiA+IGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wLCAnc3Vuc2V0dGluZ09uIG11c3QgYmUgbGF0ZXIgdGhhbiBub3cgaWYgc2V0JykKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAyMjYgOAoJYnRvaQoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJPgoKCS8vIHN1bnNldHRpbmdPbiBtdXN0IGJlIGxhdGVyIHRoYW4gbm93IGlmIHNldAoJYXNzZXJ0CgoqaWYzM19lbmQ6CglyZXRzdWIKCi8vIGNhbGxQb29sQWRkU3Rha2Uoc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuLCBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5LCBtYnJBbXRQYWlkOiB1aW50NjQsIGlzTmV3U3Rha2VyVG9WYWxpZGF0b3I6IGJvb2xlYW4sIGlzTmV3U3Rha2VyVG9Qcm90b2NvbDogYm9vbGVhbik6IHZvaWQKLy8KLy8gQWRkcyBhIHN0YWtlcnMgYW1vdW50IG9mIGFsZ28gdG8gYSB2YWxpZGF0b3IgcG9vbCwgdHJhbnNmZXJyaW5nIHRoZSBhbGdvIHdlIHJlY2VpdmVkIGZyb20gdGhlbSAoYWxyZWFkeSB2ZXJpZmllZAovLyBieSBvdXIgY2FsbGVyKSB0byB0aGUgc3Rha2luZyBwb29sIGFjY291bnQsIGFuZCB0aGVuIHRlbGxpbmcgaXQgYWJvdXQgdGhlIGFtb3VudCBiZWluZyBhZGRlZCBmb3IgdGhlIHNwZWNpZmllZAovLyBzdGFrZXIuCi8vCi8vIEBwYXJhbSB7UGF5VHhufSBzdGFrZWRBbW91bnRQYXltZW50IC0gcGF5bWVudCBjb21pbmcgZnJvbSBzdGFrZXIgdG8gcGxhY2UgaW50byBhIHBvb2wKLy8gQHBhcmFtIHtWYWxpZGF0b3JQb29sS2V5fSBwb29sS2V5IC0gVGhlIGtleSBvZiB0aGUgdmFsaWRhdG9yIHBvb2wuCi8vIEBwYXJhbSB7dWludDY0fSBtYnJBbXRQYWlkIC0gQW1vdW50IHRoZSB1c2VyIGlzIGxlYXZpbmcgYmVoaW5kIGluIHRoZSB2YWxpZGF0b3IgdG8gcGF5IGZvciB0aGVpciBzdGFrZXIgTUJSIGNvc3QKLy8gQHBhcmFtIHtib29sZWFufSBpc05ld1N0YWtlclRvVmFsaWRhdG9yIC0gaWYgdGhpcyBpcyBhIG5ldywgZmlyc3QtdGltZSBzdGFrZXIgdG8gdGhlIHZhbGlkYXRvcgovLyBAcGFyYW0ge2Jvb2xlYW59IGlzTmV3U3Rha2VyVG9Qcm90b2NvbCAtIGlmIHRoaXMgaXMgYSBuZXcsIGZpcnN0LXRpbWUgc3Rha2VyIHRvIHRoZSBwcm90b2NvbApjYWxsUG9vbEFkZFN0YWtlOgoJcHJvdG8gNSAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDEgLy8gMHgKCWR1cG4gMgoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMzQKCS8vIHBvb2xBcHBJZCA9IHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5wb29sc1twb29sS2V5LnBvb2xJZCAtIDFdLnBvb2xBcHBJZAoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAwIC8vIDAKCSsKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAwIC8vIHBvb2xBcHBJZDogdWludDY0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEzOAoJLy8gc2VuZE1ldGhvZENhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5hZGRTdGFrZSwgdWludDY0Pih7CgkvLyAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KHBvb2xBcHBJZCksCgkvLyAgICAgICAgICAgICBtZXRob2RBcmdzOiBbCgkvLyAgICAgICAgICAgICAgICAgLy8gPT09PT09PQoJLy8gICAgICAgICAgICAgICAgIC8vIFRISVMgSVMgQSBTRU5EIG9mIHRoZSBhbW91bnQgcmVjZWl2ZWQgcmlnaHQgYmFjayBvdXQgYW5kIGludG8gdGhlIHN0YWtpbmcgcG9vbCBjb250cmFjdCBhY2NvdW50LgoJLy8gICAgICAgICAgICAgICAgIHsgYW1vdW50OiBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCAtIG1ickFtdFBhaWQsIHJlY2VpdmVyOiBBcHBJRC5mcm9tVWludDY0KHBvb2xBcHBJZCkuYWRkcmVzcyB9LAoJLy8gICAgICAgICAgICAgICAgIC8vID09PT09PT0KCS8vICAgICAgICAgICAgICAgICBzdGFrZWRBbW91bnRQYXltZW50LnNlbmRlciwKCS8vICAgICAgICAgICAgIF0sCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDEgLy8gIHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNDMKCS8vIGFtb3VudDogc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQgLSBtYnJBbXRQYWlkCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2RpZyAtMyAvLyBtYnJBbXRQYWlkOiB1aW50NjQKCS0KCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE0MwoJLy8gcmVjZWl2ZXI6IEFwcElELmZyb21VaW50NjQocG9vbEFwcElkKS5hZGRyZXNzCglmcmFtZV9kaWcgMCAvLyBwb29sQXBwSWQ6IHVpbnQ2NAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCglpdHhuX25leHQKCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJcHVzaGJ5dGVzIDB4ZjljNzBjYmQgLy8gbWV0aG9kICJhZGRTdGFrZShwYXksYWRkcmVzcyl1aW50NjQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMzkKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQocG9vbEFwcElkKQoJZnJhbWVfZGlnIDAgLy8gcG9vbEFwcElkOiB1aW50NjQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNDAKCS8vIG1ldGhvZEFyZ3M6IFsKCS8vICAgICAgICAgICAgICAgICAvLyA9PT09PT09CgkvLyAgICAgICAgICAgICAgICAgLy8gVEhJUyBJUyBBIFNFTkQgb2YgdGhlIGFtb3VudCByZWNlaXZlZCByaWdodCBiYWNrIG91dCBhbmQgaW50byB0aGUgc3Rha2luZyBwb29sIGNvbnRyYWN0IGFjY291bnQuCgkvLyAgICAgICAgICAgICAgICAgeyBhbW91bnQ6IHN0YWtlZEFtb3VudFBheW1lbnQuYW1vdW50IC0gbWJyQW10UGFpZCwgcmVjZWl2ZXI6IEFwcElELmZyb21VaW50NjQocG9vbEFwcElkKS5hZGRyZXNzIH0sCgkvLyAgICAgICAgICAgICAgICAgLy8gPT09PT09PQoJLy8gICAgICAgICAgICAgICAgIHN0YWtlZEFtb3VudFBheW1lbnQuc2VuZGVyLAoJLy8gICAgICAgICAgICAgXQoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gTnVtTG9ncwoJaW50YyAxIC8vIDEKCS0KCWl0eG5hcyBMb2dzCglleHRyYWN0IDQgMAoJYnRvaQoKCS8vICppZjM0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE0OAoJLy8gZ2xvYmFscy5vcGNvZGVCdWRnZXQgPCA1MDAKCWdsb2JhbCBPcGNvZGVCdWRnZXQKCXB1c2hpbnQgNTAwCgk8CglieiAqaWYzNF9lbmQKCgkvLyAqaWYzNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTQ5CgkvLyBpbmNyZWFzZU9wY29kZUJ1ZGdldCgpCglpdHhuX2JlZ2luCglpbnRjIDcgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoJYnl0ZWMgOCAvLyAgI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50YyAyNiAvLyAgRGVsZXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMzRfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE1MwoJLy8gcG9vbE51bVN0YWtlcnMgPSBBcHBJRC5mcm9tVWludDY0KHBvb2xBcHBJZCkuZ2xvYmFsU3RhdGUoJ251bVN0YWtlcnMnKSBhcyB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIHBvb2xBcHBJZDogdWludDY0CglieXRlYyA2IC8vICAibnVtU3Rha2VycyIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KHBvb2xBcHBJZCkuZ2xvYmFsU3RhdGUoJ251bVN0YWtlcnMnKQoJYXNzZXJ0CglmcmFtZV9idXJ5IDEgLy8gcG9vbE51bVN0YWtlcnM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNTQKCS8vIHBvb2xBbGdvU3Rha2VkID0gQXBwSUQuZnJvbVVpbnQ2NChwb29sQXBwSWQpLmdsb2JhbFN0YXRlKCdzdGFrZWQnKSBhcyB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIHBvb2xBcHBJZDogdWludDY0CglieXRlYyA0IC8vICAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQocG9vbEFwcElkKS5nbG9iYWxTdGF0ZSgnc3Rha2VkJykKCWFzc2VydAoJZnJhbWVfYnVyeSAyIC8vIHBvb2xBbGdvU3Rha2VkOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTU1CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXS50b3RhbFN0YWtlcnMgPSBwb29sTnVtU3Rha2VycyBhcyB1aW50MTYKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnRjIDEgLy8gMQoJLQoJaW50YyA0IC8vIDE4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMiAvLyAgaGVhZE9mZnNldAoJKwoJZnJhbWVfZGlnIDEgLy8gcG9vbE51bVN0YWtlcnM6IHVpbnQ2NAoJaXRvYgoJZXh0cmFjdCA2IDIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE1NgoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnBvb2xzW3Bvb2xLZXkucG9vbElkIC0gMV0udG90YWxBbGdvU3Rha2VkID0gcG9vbEFsZ29TdGFrZWQKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnRjIDEgLy8gMQoJLQoJaW50YyA0IC8vIDE4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMTEgLy8gIGhlYWRPZmZzZXQKCSsKCWZyYW1lX2RpZyAyIC8vIHBvb2xBbGdvU3Rha2VkOiB1aW50NjQKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gKmlmMzVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTU5CgkvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yCglmcmFtZV9kaWcgLTQgLy8gaXNOZXdTdGFrZXJUb1ZhbGlkYXRvcjogYm9vbGVhbgoJYnogKmlmMzVfZW5kCgoJLy8gKmlmMzVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE2MAoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLnRvdGFsU3Rha2VycyArPSAxCglpbnRjIDIzIC8vIDI0NAoJZHVwCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWludGMgMSAvLyAxCgkrCglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKKmlmMzVfZW5kOgoJLy8gKmlmMzZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTYyCgkvLyBpc05ld1N0YWtlclRvUHJvdG9jb2wKCWZyYW1lX2RpZyAtNSAvLyBpc05ld1N0YWtlclRvUHJvdG9jb2w6IGJvb2xlYW4KCWJ6ICppZjM2X2VuZAoKCS8vICppZjM2X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNjMKCS8vIHRoaXMubnVtU3Rha2Vycy52YWx1ZSArPSAxCglieXRlYyA2IC8vICAibnVtU3Rha2VycyIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDEgLy8gMQoJKwoJYnl0ZWMgNiAvLyAgIm51bVN0YWtlcnMiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKKmlmMzZfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE2NQoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLnRvdGFsQWxnb1N0YWtlZCArPSBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCAtIG1ickFtdFBhaWQKCWludGMgMTIgLy8gMjUyCglkdXAKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgLTMgLy8gbWJyQW10UGFpZDogdWludDY0CgktCgkrCglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNjYKCS8vIHRoaXMudG90YWxBbGdvU3Rha2VkLnZhbHVlICs9IHN0YWtlZEFtb3VudFBheW1lbnQuYW1vdW50IC0gbWJyQW10UGFpZAoJYnl0ZWMgNCAvLyAgInN0YWtlZCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2RpZyAtMyAvLyBtYnJBbXRQYWlkOiB1aW50NjQKCS0KCSsKCWJ5dGVjIDQgLy8gICJzdGFrZWQiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyB1cGRhdGVTdGFrZXJQb29sU2V0KHN0YWtlcjogQWRkcmVzcywgcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleSk6IHZvaWQKdXBkYXRlU3Rha2VyUG9vbFNldDoKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXBuIDIKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTcwCgkvLyBhc3NlcnQodGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikuZXhpc3RzKQoJYnl0ZWMgMyAvLyAgInNwcyIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTcyCgkvLyBwb29sU2V0ID0gY2xvbmUodGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUpCglieXRlYyAzIC8vICAic3BzIgoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlcjogQWRkcmVzcwoJY29uY2F0Cglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDAgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQsdWludDY0KVs2XQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNzMKCS8vIGZpcnN0RW1wdHkgPSAwCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAxIC8vIGZpcnN0RW1wdHk6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNzQKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUubGVuZ3RoOyBpICs9IDEpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoKKmZvcl83OgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE3NAoJLy8gaSA8IHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlLmxlbmd0aAoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDcgLy8gNgoJPAoJYnogKmZvcl83X2VuZAoKCS8vICppZjM3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE3NQoJLy8gcG9vbFNldFtpXSA9PT0gcG9vbEtleQoJZnJhbWVfZGlnIDAgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQsdWludDY0KVs2XQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDMgLy8gMjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAzIC8vIDI0CglleHRyYWN0MwoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCT09CglieiAqaWYzN19lbmQKCgkvLyAqaWYzN19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTc3CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmMzdfZW5kOgoJLy8gKmlmMzhfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTc5CgkvLyBmaXJzdEVtcHR5ID09PSAwICYmIHBvb2xTZXRbaV0uaWQgPT09IDAKCWZyYW1lX2RpZyAxIC8vIGZpcnN0RW1wdHk6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT09CglkdXAKCWJ6ICpza2lwX2FuZDkKCWZyYW1lX2RpZyAwIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMCAvLyAwCgkrCglpbnRjIDIgLy8gOAoJZXh0cmFjdDMKCWJ0b2kKCWludGMgMCAvLyAwCgk9PQoJJiYKCipza2lwX2FuZDk6CglieiAqaWYzOF9lbmQKCgkvLyAqaWYzOF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTgwCgkvLyBmaXJzdEVtcHR5ID0gaSArIDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBmaXJzdEVtcHR5OiB1aW50NjQKCippZjM4X2VuZDoKCipmb3JfN19jb250aW51ZToKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNzQKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzcKCipmb3JfN19lbmQ6CgkvLyAqaWYzOV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExODMKCS8vIGZpcnN0RW1wdHkgPT09IDAKCWZyYW1lX2RpZyAxIC8vIGZpcnN0RW1wdHk6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT09CglieiAqaWYzOV9lbmQKCgkvLyAqaWYzOV9jb25zZXF1ZW50CgkvLyBObyBlbXB0eSBzbG90IGF2YWlsYWJsZSBpbiB0aGUgc3Rha2VyIHBvb2wgc2V0CgllcnIKCippZjM5X2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExODYKCS8vIHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlW2ZpcnN0RW1wdHkgLSAxXSA9IHBvb2xLZXkKCWZyYW1lX2RpZyAxIC8vIGZpcnN0RW1wdHk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCS0KCWludGMgMyAvLyAyNAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJYnl0ZWMgMyAvLyAgInNwcyIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCXJldHN1YgoKLy8gcmVtb3ZlRnJvbVN0YWtlclBvb2xTZXQoc3Rha2VyOiBBZGRyZXNzLCBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5KTogW2Jvb2xlYW4sIGJvb2xlYW5dCi8vCi8vIFJlbW92ZXMgYSBwb29sIGtleSBmcm9tIHRoZSBzdGFrZXIncyBhY3RpdmUgcG9vbCBzZXQgLSBmYWlscyBpZiBub3QgZm91bmQgKCEpCi8vCi8vIEBwYXJhbSB7QWRkcmVzc30gc3Rha2VyIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHN0YWtlci4KLy8gQHBhcmFtIHtWYWxpZGF0b3JQb29sS2V5fSBwb29sS2V5IC0gVGhlIHBvb2wga2V5IHRoZXkgc2hvdWxkIGJlIHN0b3JlZCBpbgovLwovLyBAcmV0dXJuIFtib29sZWFuLCBib29sZWFuXSBbaXMgdGhlIHN0YWtlciBnb25lIGZyb20gQUxMIHBvb2xzIG9mIHRoZSBnaXZlbiBWQUxJREFUT1IsIGFuZCBpcyBzdGFrZXIgZ29uZSBmcm9tIEFMTCBwb29sc10KcmVtb3ZlRnJvbVN0YWtlclBvb2xTZXQ6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiA0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE5OQoJLy8gaW5TYW1lVmFsaWRhdG9yUG9vbENvdW50ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMCAvLyBpblNhbWVWYWxpZGF0b3JQb29sQ291bnQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMDAKCS8vIGluQW55UG9vbENvdW50ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMSAvLyBpbkFueVBvb2xDb3VudDogdWludDY0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIwMQoJLy8gZm91bmQgPSBmYWxzZQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMiAvLyBmb3VuZDogYm9vbAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMDMKCS8vIHBvb2xTZXQgPSBjbG9uZSh0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZSkKCWJ5dGVjIDMgLy8gICJzcHMiCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VyOiBBZGRyZXNzCgljb25jYXQKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlCglhc3NlcnQKCWZyYW1lX2J1cnkgMyAvLyBwb29sU2V0OiAodWludDY0LHVpbnQ2NCx1aW50NjQpWzZdCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIwNAoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZS5sZW5ndGg7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDQgLy8gaTogdWludDY0CgoqZm9yXzg6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjA0CgkvLyBpIDwgdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUubGVuZ3RoCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgNyAvLyA2Cgk8CglieiAqZm9yXzhfZW5kCgoJLy8gKmlmNDBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjA1CgkvLyBwb29sU2V0W2ldLmlkID09PSAwCglmcmFtZV9kaWcgMyAvLyBwb29sU2V0OiAodWludDY0LHVpbnQ2NCx1aW50NjQpWzZdCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgMyAvLyAyNAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDAgLy8gMAoJKwoJaW50YyAyIC8vIDgKCWV4dHJhY3QzCglidG9pCglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjQwX2VuZAoKCS8vICppZjQwX2NvbnNlcXVlbnQKCWIgKmZvcl84X2NvbnRpbnVlCgoqaWY0MF9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjA4CgkvLyBpbkFueVBvb2xDb3VudCArPSAxCglmcmFtZV9kaWcgMSAvLyBpbkFueVBvb2xDb3VudDogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAxIC8vIGluQW55UG9vbENvdW50OiB1aW50NjQKCgkvLyAqaWY0MV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMDkKCS8vIHBvb2xTZXRbaV0uaWQgPT09IHBvb2xLZXkuaWQKCWZyYW1lX2RpZyAzIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMCAvLyAwCgkrCglpbnRjIDIgLy8gOAoJZXh0cmFjdDMKCWJ0b2kKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJPT0KCWJ6ICppZjQxX2VuZAoKCS8vICppZjQxX2NvbnNlcXVlbnQKCS8vICppZjQyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIxMAoJLy8gcG9vbFNldFtpXSA9PT0gcG9vbEtleQoJZnJhbWVfZGlnIDMgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQsdWludDY0KVs2XQoJZnJhbWVfZGlnIDQgLy8gaTogdWludDY0CglpbnRjIDMgLy8gMjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAzIC8vIDI0CglleHRyYWN0MwoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCT09CglieiAqaWY0Ml9lbHNlCgoJLy8gKmlmNDJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIxMQoJLy8gZm91bmQgPSB0cnVlCglpbnRjIDEgLy8gMQoJZnJhbWVfYnVyeSAyIC8vIGZvdW5kOiBib29sCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIxMwoJLy8gdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWVbaV0gPSB7IGlkOiAwLCBwb29sSWQ6IDAsIHBvb2xBcHBJZDogMCB9CglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgMyAvLyAyNAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWJ5dGVjIDMgLy8gICJzcHMiCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VyOiBBZGRyZXNzCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgliICppZjQyX2VuZAoKKmlmNDJfZWxzZToKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMTUKCS8vIGluU2FtZVZhbGlkYXRvclBvb2xDb3VudCArPSAxCglmcmFtZV9kaWcgMCAvLyBpblNhbWVWYWxpZGF0b3JQb29sQ291bnQ6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMCAvLyBpblNhbWVWYWxpZGF0b3JQb29sQ291bnQ6IHVpbnQ2NAoKKmlmNDJfZW5kOgoKKmlmNDFfZW5kOgoKKmZvcl84X2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIwNAoJLy8gaSArPSAxCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDQgLy8gaTogdWludDY0CgliICpmb3JfOAoKKmZvcl84X2VuZDoKCS8vICppZjQzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIxOQoJLy8gIWZvdW5kCglmcmFtZV9kaWcgMiAvLyBmb3VuZDogYm9vbAoJIQoJYnogKmlmNDNfZW5kCgoJLy8gKmlmNDNfY29uc2VxdWVudAoJLy8gTm8gbWF0Y2hpbmcgc2xvdCBmb3VuZCB3aGVuIHRvbGQgdG8gcmVtb3ZlIGEgcG9vbCBmcm9tIHRoZSBzdGFrZXJzIHNldAoJZXJyCgoqaWY0M19lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjIzCgkvLyByZXR1cm4gW2luU2FtZVZhbGlkYXRvclBvb2xDb3VudCA9PT0gMCwgaW5BbnlQb29sQ291bnQgPT09IDBdCglieXRlYyA1IC8vIDB4MDAKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgMCAvLyBpblNhbWVWYWxpZGF0b3JQb29sQ291bnQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT09CglzZXRiaXQKCWludGMgMSAvLyAxCglmcmFtZV9kaWcgMSAvLyBpbkFueVBvb2xDb3VudDogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCXNldGJpdAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDQKCXJldHN1YgoKLy8gYWRkUG9vbFRvTm9kZSh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCBwb29sQXBwSWQ6IHVpbnQ2NCwgbm9kZU51bTogdWludDY0KTogdm9pZAphZGRQb29sVG9Ob2RlOgoJcHJvdG8gMyAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDEgLy8gMHgKCWR1cG4gMgoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMjcKCS8vIG5vZGVQb29sQXNzaWdubWVudHMgPSBjbG9uZSh0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLm5vZGVQb29sQXNzaWdubWVudHMpCglpbnRjIDE3IC8vICBoZWFkT2Zmc2V0CglpbnRjIDIyIC8vIDE5MgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJZnJhbWVfYnVyeSAwIC8vIG5vZGVQb29sQXNzaWdubWVudHM6ICgodWludDY0WzNdKVs4XSkKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjI4CgkvLyBtYXhQb29sc1Blck5vZGVGb3JUaGlzVmFsaWRhdG9yID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcucG9vbHNQZXJOb2RlIGFzIHVpbnQ2NAoJcHVzaGludCAyMjUKCWludGMgMSAvLyAxCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDEgLy8gbWF4UG9vbHNQZXJOb2RlRm9yVGhpc1ZhbGlkYXRvcjogdWludDY0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzMAoJLy8gYXNzZXJ0KG5vZGVOdW0gPj0gMSAmJiBub2RlTnVtIDw9IE1BWF9OT0RFUywgJ25vZGUgbnVtYmVyIG5vdCBpbiB2YWxpZCByYW5nZScpCglmcmFtZV9kaWcgLTMgLy8gbm9kZU51bTogdWludDY0CglpbnRjIDEgLy8gMQoJPj0KCWR1cAoJYnogKnNraXBfYW5kMTAKCWZyYW1lX2RpZyAtMyAvLyBub2RlTnVtOiB1aW50NjQKCWludGMgMiAvLyA4Cgk8PQoJJiYKCipza2lwX2FuZDEwOgoJLy8gbm9kZSBudW1iZXIgbm90IGluIHZhbGlkIHJhbmdlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjMyCgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IG1heFBvb2xzUGVyTm9kZUZvclRoaXNWYWxpZGF0b3I7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDIgLy8gaTogdWludDY0CgoqZm9yXzk6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjMyCgkvLyBpIDwgbWF4UG9vbHNQZXJOb2RlRm9yVGhpc1ZhbGlkYXRvcgoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglmcmFtZV9kaWcgMSAvLyBtYXhQb29sc1Blck5vZGVGb3JUaGlzVmFsaWRhdG9yOiB1aW50NjQKCTwKCWJ6ICpmb3JfOV9lbmQKCgkvLyAqaWY0NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMzMKCS8vIG5vZGVQb29sQXNzaWdubWVudHMubm9kZXNbbm9kZU51bSAtIDFdLnBvb2xBcHBJZHNbaV0gPT09IDAKCWZyYW1lX2RpZyAwIC8vIG5vZGVQb29sQXNzaWdubWVudHM6ICgodWludDY0WzNdKVs4XSkKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgLTMgLy8gbm9kZU51bTogdWludDY0CglpbnRjIDEgLy8gMQoJLQoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMCAvLyAwCgkrCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMiAvLyA4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMiAvLyA4CglleHRyYWN0MwoJYnRvaQoJaW50YyAwIC8vIDAKCT09CglieiAqaWY0NF9lbmQKCgkvLyAqaWY0NF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjM1CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLm5vZGVQb29sQXNzaWdubWVudHMubm9kZXNbbm9kZU51bSAtIDFdLnBvb2xBcHBJZHNbaV0gPSBwb29sQXBwSWQKCWludGMgMTcgLy8gOTAwCglmcmFtZV9kaWcgLTMgLy8gbm9kZU51bTogdWludDY0CglpbnRjIDEgLy8gMQoJLQoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMCAvLyAwCgkrCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMiAvLyA4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWZyYW1lX2RpZyAtMiAvLyBwb29sQXBwSWQ6IHVpbnQ2NAoJaXRvYgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMzYKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY0NF9lbmQ6CgoqZm9yXzlfY29udGludWU6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjMyCgkvLyBpICs9IDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCWIgKmZvcl85CgoqZm9yXzlfZW5kOgoJLy8gbm8gYXZhaWxhYmxlIHNwYWNlIGluIHNwZWNpZmllZCBub2RlIGZvciB0aGlzIHBvb2wKCWVycgoJcmV0c3ViCgovLyBkb2VzU3Rha2VyTWVldEdhdGluZyh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQpOiB2b2lkCi8vCi8vIENoZWNrcyBpZiBhIHN0YWtlciBtZWV0cyB0aGUgZ2F0aW5nIHJlcXVpcmVtZW50cyBzcGVjaWZpZWQgYnkgdGhlIHZhbGlkYXRvci4KLy8KLy8gQHBhcmFtIHtWYWxpZGF0b3JJZFR5cGV9IHZhbGlkYXRvcklkIC0gVGhlIGlkIG9mIHRoZSB2YWxpZGF0b3IuCi8vIEBwYXJhbSB7dWludDY0fSB2YWx1ZVRvVmVyaWZ5IC0gVGhlIHZhbHVlIHRvIHZlcmlmeSBhZ2FpbnN0IHRoZSBnYXRpbmcgcmVxdWlyZW1lbnRzLgovLyBAcmV0dXJucyB7dm9pZH0gb3IgYXNzZXJ0cyBpZiByZXF1aXJlbWVudHMgbm90IG1ldC4KZG9lc1N0YWtlck1lZXRHYXRpbmc6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiA4CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI1MAoJLy8gdHlwZSA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLmVudHJ5R2F0aW5nVHlwZQoJaW50YyAzNiAvLyA4MAoJaW50YyAxIC8vIDEKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgMCAvLyB0eXBlOiB1aW50OAoKCS8vICppZjQ1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI1MQoJLy8gdHlwZSA9PT0gR0FUSU5HX1RZUEVfTk9ORQoJZnJhbWVfZGlnIDAgLy8gdHlwZTogdWludDgKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmNDVfZW5kCgoJLy8gKmlmNDVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI1MgoJLy8gcmV0dXJuCglyZXRzdWIKCippZjQ1X2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNTQKCS8vIHN0YWtlciA9IHRoaXMudHhuLnNlbmRlcgoJdHhuIFNlbmRlcgoJZnJhbWVfYnVyeSAxIC8vIHN0YWtlcjogYWRkcmVzcwoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNTUKCS8vIGNvbmZpZyA9IGNsb25lKHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnKQoJaW50YyAwIC8vIDAKCWludGMgOSAvLyAyNDIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWZyYW1lX2J1cnkgMiAvLyBjb25maWc6ICh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoKCS8vICppZjQ2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI1OQoJLy8gdHlwZSA9PT0gR0FUSU5HX1RZUEVfQVNTRVRTX0NSRUFURURfQlkgfHwKCS8vICAgICAgICAgICAgIHR5cGUgPT09IEdBVElOR19UWVBFX0FTU0VUX0lEIHx8CgkvLyAgICAgICAgICAgICB0eXBlID09PSBHQVRJTkdfVFlQRV9DUkVBVEVEX0JZX05GRF9BRERSRVNTRVMKCWZyYW1lX2RpZyAwIC8vIHR5cGU6IHVpbnQ4CglpbnRjIDEgLy8gMQoJPT0KCWR1cAoJYm56ICpza2lwX29yNAoJZnJhbWVfZGlnIDAgLy8gdHlwZTogdWludDgKCWludGMgMTAgLy8gMgoJPT0KCXx8Cgoqc2tpcF9vcjQ6CglkdXAKCWJueiAqc2tpcF9vcjUKCWZyYW1lX2RpZyAwIC8vIHR5cGU6IHVpbnQ4CglpbnRjIDggLy8gMwoJPT0KCXx8Cgoqc2tpcF9vcjU6CglieiAqaWY0Nl9lbmQKCgkvLyAqaWY0Nl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjYzCgkvLyBhc3NlcnQodmFsdWVUb1ZlcmlmeSAhPT0gMCkKCWZyYW1lX2RpZyAtMiAvLyB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI2NAoJLy8gYmFsUmVxdWlyZWQgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5nYXRpbmdBc3NldE1pbkJhbGFuY2UKCWludGMgMzcgLy8gMTQ1CglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAzIC8vIGJhbFJlcXVpcmVkOiB1aW50NjQKCgkvLyAqaWY0N19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNjUKCS8vIGJhbFJlcXVpcmVkID09PSAwCglmcmFtZV9kaWcgMyAvLyBiYWxSZXF1aXJlZDogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjQ3X2VuZAoKCS8vICppZjQ3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNjYKCS8vIGJhbFJlcXVpcmVkID0gMQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgMyAvLyBiYWxSZXF1aXJlZDogdWludDY0CgoqaWY0N19lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjY4CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICAgICAgc3Rha2VyLmFzc2V0QmFsYW5jZShBc3NldElELmZyb21VaW50NjQodmFsdWVUb1ZlcmlmeSkpID49IGJhbFJlcXVpcmVkLAoJLy8gICAgICAgICAgICAgICAgICdtdXN0IGhhdmUgcmVxdWlyZWQgbWluaW11bSBiYWxhbmNlIG9mIHZhbGlkYXRvciBkZWZpbmVkIHRva2VuIHRvIGFkZCBzdGFrZScsCgkvLyAgICAgICAgICAgICApCglmcmFtZV9kaWcgMSAvLyBzdGFrZXI6IGFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglmcmFtZV9kaWcgMyAvLyBiYWxSZXF1aXJlZDogdWludDY0Cgk+PQoKCS8vIG11c3QgaGF2ZSByZXF1aXJlZCBtaW5pbXVtIGJhbGFuY2Ugb2YgdmFsaWRhdG9yIGRlZmluZWQgdG9rZW4gdG8gYWRkIHN0YWtlCglhc3NlcnQKCippZjQ2X2VuZDoKCS8vICppZjQ4X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI3MwoJLy8gdHlwZSA9PT0gR0FUSU5HX1RZUEVfQVNTRVRTX0NSRUFURURfQlkKCWZyYW1lX2RpZyAwIC8vIHR5cGU6IHVpbnQ4CglpbnRjIDEgLy8gMQoJPT0KCWJ6ICppZjQ4X2VuZAoKCS8vICppZjQ4X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNzQKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgICAgICBBc3NldElELmZyb21VaW50NjQodmFsdWVUb1ZlcmlmeSkuY3JlYXRvciA9PT0gY29uZmlnLmVudHJ5R2F0aW5nQWRkcmVzcywKCS8vICAgICAgICAgICAgICAgICAnc3BlY2lmaWVkIGFzc2V0IG11c3QgYmUgY3JlYXRlZCBieSBjcmVhdG9yIHRoYXQgdGhlIHZhbGlkYXRvciBkZWZpbmVkIGFzIGEgcmVxdWlyZW1lbnQgdG8gc3Rha2UnLAoJLy8gICAgICAgICAgICAgKQoJZnJhbWVfZGlnIC0yIC8vIHZhbHVlVG9WZXJpZnk6IHVpbnQ2NAoJYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKCXBvcAoJZnJhbWVfZGlnIDIgLy8gY29uZmlnOiAodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgODEgMzIKCT09CgoJLy8gc3BlY2lmaWVkIGFzc2V0IG11c3QgYmUgY3JlYXRlZCBieSBjcmVhdG9yIHRoYXQgdGhlIHZhbGlkYXRvciBkZWZpbmVkIGFzIGEgcmVxdWlyZW1lbnQgdG8gc3Rha2UKCWFzc2VydAoKKmlmNDhfZW5kOgoJLy8gKmlmNDlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjc5CgkvLyB0eXBlID09PSBHQVRJTkdfVFlQRV9BU1NFVF9JRAoJZnJhbWVfZGlnIDAgLy8gdHlwZTogdWludDgKCWludGMgMTAgLy8gMgoJPT0KCWJ6ICppZjQ5X2VuZAoKCS8vICppZjQ5X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyODAKCS8vIGZvdW5kID0gZmFsc2UKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDQgLy8gZm91bmQ6IGJvb2wKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjgxCgkvLyBjb25maWcuZW50cnlHYXRpbmdBc3NldHMKCWZyYW1lX2RpZyAyIC8vIGNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDExMyAzMgoJZHVwCglmcmFtZV9idXJ5IDUgLy8gY29weSBvZiB0aGUgYXJyYXkgd2UgYXJlIGl0ZXJhdGluZyBvdmVyCglleHRyYWN0IDAgOAoJYnRvaQoJZnJhbWVfYnVyeSA2IC8vIGFzc2V0SWQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNyAvLyB0aGUgb2Zmc2V0IHdlIGFyZSBleHRyYWN0aW5nIHRoZSBuZXh0IGVsZW1lbnQgZnJvbQoKKmZvck9mXzA6CgkvLyAqaWY1MF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyODIKCS8vIHZhbHVlVG9WZXJpZnkgPT09IGFzc2V0SWQKCWZyYW1lX2RpZyAtMiAvLyB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQKCWZyYW1lX2RpZyA2IC8vIGFzc2V0SWQ6IHVpbnQ2NAoJPT0KCWJ6ICppZjUwX2VuZAoKCS8vICppZjUwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyODMKCS8vIGZvdW5kID0gdHJ1ZQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgNCAvLyBmb3VuZDogYm9vbAoJYiAqZm9yT2ZfMF9lbmQKCippZjUwX2VuZDoKCipmb3JPZl8wX2NvbnRpbnVlOgoJLy8gaW5jcmVtZW50IG9mZnNldCBhbmQgbG9vcCBpZiBub3Qgb3V0IG9mIGJvdW5kcwoJZnJhbWVfZGlnIDcgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWludGMgMiAvLyA4CgkrCglkdXAKCWludGMgNiAvLyAgb2Zmc2V0IG9mIGxhc3QgZWxlbWVudAoJPAoJYnogKmZvck9mXzBfZW5kCglmcmFtZV9idXJ5IDcgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWZyYW1lX2RpZyA1IC8vIGNvcHkgb2YgdGhlIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3ZlcgoJZnJhbWVfZGlnIDcgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWludGMgMiAvLyA4CglleHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDYgLy8gYXNzZXRJZDogdWludDY0CgliICpmb3JPZl8wCgoqZm9yT2ZfMF9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjg3CgkvLyBhc3NlcnQoZm91bmQsICdzcGVjaWZpZWQgYXNzZXQgbXVzdCBiZSBpZGVudGljYWwgdG8gdGhlIGFzc2V0IGlkIGRlZmluZWQgYXMgYSByZXF1aXJlbWVudCB0byBzdGFrZScpCglmcmFtZV9kaWcgNCAvLyBmb3VuZDogYm9vbAoKCS8vIHNwZWNpZmllZCBhc3NldCBtdXN0IGJlIGlkZW50aWNhbCB0byB0aGUgYXNzZXQgaWQgZGVmaW5lZCBhcyBhIHJlcXVpcmVtZW50IHRvIHN0YWtlCglhc3NlcnQKCippZjQ5X2VuZDoKCS8vICppZjUxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI4OQoJLy8gdHlwZSA9PT0gR0FUSU5HX1RZUEVfQ1JFQVRFRF9CWV9ORkRfQUREUkVTU0VTCglmcmFtZV9kaWcgMCAvLyB0eXBlOiB1aW50OAoJaW50YyA4IC8vIDMKCT09CglieiAqaWY1MV9lbmQKCgkvLyAqaWY1MV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjkyCgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICAgICAgdGhpcy5pc0FkZHJlc3NJbk5GRENBQWxnb0xpc3QoY29uZmlnLmVudHJ5R2F0aW5nQXNzZXRzWzBdLCBBc3NldElELmZyb21VaW50NjQodmFsdWVUb1ZlcmlmeSkuY3JlYXRvciksCgkvLyAgICAgICAgICAgICAgICAgJ3NwZWNpZmllZCBhc3NldCBtdXN0IGJlIGNyZWF0ZWQgYnkgY3JlYXRvciB0aGF0IGlzIG9uZSBvZiB0aGUgbGlua2VkIGFkZHJlc3NlcyBpbiBhbiBuZmQnLAoJLy8gICAgICAgICAgICAgKQoJZnJhbWVfZGlnIC0yIC8vIHZhbHVlVG9WZXJpZnk6IHVpbnQ2NAoJYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKCXBvcAoJZnJhbWVfZGlnIDIgLy8gY29uZmlnOiAodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMTEzIDgKCWJ0b2kKCWNhbGxzdWIgaXNBZGRyZXNzSW5ORkRDQUFsZ29MaXN0CgoJLy8gc3BlY2lmaWVkIGFzc2V0IG11c3QgYmUgY3JlYXRlZCBieSBjcmVhdG9yIHRoYXQgaXMgb25lIG9mIHRoZSBsaW5rZWQgYWRkcmVzc2VzIGluIGFuIG5mZAoJYXNzZXJ0CgoqaWY1MV9lbmQ6CgkvLyAqaWY1Ml9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyOTcKCS8vIHR5cGUgPT09IEdBVElOR19UWVBFX1NFR01FTlRfT0ZfTkZECglmcmFtZV9kaWcgMCAvLyB0eXBlOiB1aW50OAoJaW50YyAxNSAvLyA0Cgk9PQoJYnogKmlmNTJfZW5kCgoJLy8gKmlmNTJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI5OQoJLy8gdXNlck9mZmVyZWRORkRBcHBJRCA9IHZhbHVlVG9WZXJpZnkKCWZyYW1lX2RpZyAtMiAvLyB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQKCWZyYW1lX2J1cnkgOCAvLyB1c2VyT2ZmZXJlZE5GREFwcElEOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzAwCgkvLyBhc3NlcnQodGhpcy5pc05GREFwcElEVmFsaWQodXNlck9mZmVyZWRORkRBcHBJRCksICdwcm92aWRlZCBORkQgbXVzdCBiZSB2YWxpZCcpCglmcmFtZV9kaWcgOCAvLyB1c2VyT2ZmZXJlZE5GREFwcElEOiB1aW50NjQKCWNhbGxzdWIgaXNORkRBcHBJRFZhbGlkCgoJLy8gcHJvdmlkZWQgTkZEIG11c3QgYmUgdmFsaWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMDMKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgICAgICByYXdCeXRlcyhBcHBJRC5mcm9tVWludDY0KHVzZXJPZmZlcmVkTkZEQXBwSUQpLmdsb2JhbFN0YXRlKCdpLm93bmVyLmEnKSBhcyBBZGRyZXNzKSA9PT0KCS8vICAgICAgICAgICAgICAgICAgICAgcmF3Qnl0ZXMoc3Rha2VyKSB8fCB0aGlzLmlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdCh1c2VyT2ZmZXJlZE5GREFwcElELCBzdGFrZXIpLAoJLy8gICAgICAgICAgICAgICAgICJwcm92aWRlZCBuZmQgZm9yIGVudHJ5IGlzbid0IG93bmVkIG9yIGxpbmtlZCB0byB0aGUgc3Rha2VyIiwKCS8vICAgICAgICAgICAgICkKCWZyYW1lX2RpZyA4IC8vIHVzZXJPZmZlcmVkTkZEQXBwSUQ6IHVpbnQ2NAoJYnl0ZWMgMTAgLy8gICJpLm93bmVyLmEiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NCh1c2VyT2ZmZXJlZE5GREFwcElEKS5nbG9iYWxTdGF0ZSgnaS5vd25lci5hJykKCWFzc2VydAoJZnJhbWVfZGlnIDEgLy8gc3Rha2VyOiBhZGRyZXNzCgk9PQoJZHVwCglibnogKnNraXBfb3I2CglmcmFtZV9kaWcgMSAvLyBzdGFrZXI6IGFkZHJlc3MKCWZyYW1lX2RpZyA4IC8vIHVzZXJPZmZlcmVkTkZEQXBwSUQ6IHVpbnQ2NAoJY2FsbHN1YiBpc0FkZHJlc3NJbk5GRENBQWxnb0xpc3QKCXx8Cgoqc2tpcF9vcjY6CgkvLyBwcm92aWRlZCBuZmQgZm9yIGVudHJ5IGlzbid0IG93bmVkIG9yIGxpbmtlZCB0byB0aGUgc3Rha2VyCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzEwCgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICAgICAgYnRvaShBcHBJRC5mcm9tVWludDY0KHVzZXJPZmZlcmVkTkZEQXBwSUQpLmdsb2JhbFN0YXRlKCdpLnBhcmVudEFwcElEJykgYXMgYnl0ZXMpID09PQoJLy8gICAgICAgICAgICAgICAgICAgICBjb25maWcuZW50cnlHYXRpbmdBc3NldHNbMF0sCgkvLyAgICAgICAgICAgICAgICAgJ3NwZWNpZmllZCBuZmQgbXVzdCBiZSBhIHNlZ21lbnQgb2YgdGhlIG5mZCB0aGUgdmFsaWRhdG9yIHNwZWNpZmllZCBhcyBhIHJlcXVpcmVtZW50JywKCS8vICAgICAgICAgICAgICkKCWZyYW1lX2RpZyA4IC8vIHVzZXJPZmZlcmVkTkZEQXBwSUQ6IHVpbnQ2NAoJcHVzaGJ5dGVzIDB4NjkyZTcwNjE3MjY1NmU3NDQxNzA3MDQ5NDQgLy8gImkucGFyZW50QXBwSUQiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NCh1c2VyT2ZmZXJlZE5GREFwcElEKS5nbG9iYWxTdGF0ZSgnaS5wYXJlbnRBcHBJRCcpCglhc3NlcnQKCWJ0b2kKCWZyYW1lX2RpZyAyIC8vIGNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDExMyA4CglidG9pCgk9PQoKCS8vIHNwZWNpZmllZCBuZmQgbXVzdCBiZSBhIHNlZ21lbnQgb2YgdGhlIG5mZCB0aGUgdmFsaWRhdG9yIHNwZWNpZmllZCBhcyBhIHJlcXVpcmVtZW50Cglhc3NlcnQKCippZjUyX2VuZDoKCXJldHN1YgoKLy8gaXNORkRBcHBJRFZhbGlkKG5mZEFwcElEOiB1aW50NjQpOiBib29sZWFuCi8vCi8vIENoZWNrcyBpZiB0aGUgZ2l2ZW4gTkZEIEFwcCBpZCBpcyB2YWxpZC4gIFVzaW5nIG9ubHkgdGhlIEFwcCBpZCB0aGVyZSdzIG5vIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgbmFtZSAoaWU6IHRoYXQgbmZkIFggaXMgbmFtZSBZKQovLyBTbyBpdCdzIGFzc3VtZWQgZm9yIHRoZSBjYWxsZXIsIHRoZSBhcHAgaWQgYWxvbmUgaXMgZmluZS4gIFRoZSBuYW1lIGlzIGZldGNoZWQgZnJvbSB0aGUgc3BlY2lmaWVkIGFwcCBpZCBhbmQgdGhlIHR3bwovLyB0b2dldGhlciBhcmUgdXNlZCBmb3IgdmFsaWRpdHkgY2hlY2sgY2FsbCB0byB0aGUgbmZkIHJlZ2lzdHJ5LgovLwovLyBAcGFyYW0ge3VpbnQ2NH0gbmZkQXBwSUQgLSBUaGUgTkZEIEFwcCBpZCB0byB2ZXJpZnkuCi8vCi8vIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgTkZEIEFwcCBpZCBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlLgppc05GREFwcElEVmFsaWQ6Cglwcm90byAxIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMjkKCS8vIHVzZXJPZmZlcmVkTkZETmFtZSA9IEFwcElELmZyb21VaW50NjQobmZkQXBwSUQpLmdsb2JhbFN0YXRlKCdpLm5hbWUnKSBhcyBzdHJpbmcKCWZyYW1lX2RpZyAtMSAvLyBuZmRBcHBJRDogdWludDY0CglwdXNoYnl0ZXMgMHg2OTJlNmU2MTZkNjUgLy8gImkubmFtZSIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElEKS5nbG9iYWxTdGF0ZSgnaS5uYW1lJykKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIHVzZXJPZmZlcmVkTkZETmFtZTogc3RyaW5nCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTMzMQoJLy8gcmV0dXJuIHNlbmRNZXRob2RDYWxsPFtzdHJpbmcsIHVpbnQ2NF0sIGJvb2xlYW4+KHsKCS8vICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQodGhpcy5uZmRSZWdpc3RyeUFwcElkKSwKCS8vICAgICAgICAgICAgIG5hbWU6ICdpc1ZhbGlkTmZkQXBwSWQnLAoJLy8gICAgICAgICAgICAgbWV0aG9kQXJnczogW3VzZXJPZmZlcmVkTkZETmFtZSwgbmZkQXBwSURdLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglwdXNoYnl0ZXMgMHg0YmUyMmZjNiAvLyBtZXRob2QgImlzVmFsaWROZmRBcHBJZChzdHJpbmcsdWludDY0KWJvb2wiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMzIKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQodGhpcy5uZmRSZWdpc3RyeUFwcElkKQoJaW50YyAyOCAvLyBUTVBMX25mZFJlZ2lzdHJ5QXBwSWQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMzQKCS8vIG1ldGhvZEFyZ3M6IFt1c2VyT2ZmZXJlZE5GRE5hbWUsIG5mZEFwcElEXQoJZnJhbWVfZGlnIDAgLy8gdXNlck9mZmVyZWRORkROYW1lOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0xIC8vIG5mZEFwcElEOiB1aW50NjQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnRjIDEgLy8gMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglpbnRjIDAgLy8gMAoJZ2V0Yml0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCi8vIGlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdChuZmRBcHBJRDogdWludDY0LCBhZGRyVG9GaW5kOiBBZGRyZXNzKTogYm9vbGVhbgovLwovLyBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBhZGRyZXNzIGlzIHByZXNlbnQgaW4gYW4gTkZEcyBsaXN0IG9mIHZlcmlmaWVkIGFkZHJlc3Nlcy4KLy8gVGhlIE5GRCBpcyBhc3N1bWVkIHRvIGhhdmUgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcyBvZmZpY2lhbC4KLy8KLy8gQHBhcmFtIHt1aW50NjR9IG5mZEFwcElEIC0gVGhlIE5GRCBhcHBsaWNhdGlvbiBpZC4KLy8gQHBhcmFtIHtBZGRyZXNzfSBhZGRyVG9GaW5kIC0gVGhlIGFkZHJlc3MgdG8gZmluZCBpbiB0aGUgdi5jYUFsZ28uMC5hcyBwcm9wZXJ0eQovLyBAcmV0dXJuIHtib29sZWFufSAtIGB0cnVlYCBpZiB0aGUgYWRkcmVzcyBpcyBwcmVzZW50LCBgZmFsc2VgIG90aGVyd2lzZS4KaXNBZGRyZXNzSW5ORkRDQUFsZ29MaXN0OgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDEgLy8gMHgKCWR1cG4gMgoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzNDcKCS8vIHNlbmRBcHBDYWxsKHsKCS8vICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQobmZkQXBwSUQpLAoJLy8gICAgICAgICAgICAgYXBwbGljYXRpb25BcmdzOiBbJ3JlYWRfcHJvcGVydHknLCAndi5jYUFsZ28uMC5hcyddLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM0OAoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJRCkKCWZyYW1lX2RpZyAtMSAvLyBuZmRBcHBJRDogdWludDY0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzQ5CgkvLyBhcHBsaWNhdGlvbkFyZ3M6IFsncmVhZF9wcm9wZXJ0eScsICd2LmNhQWxnby4wLmFzJ10KCXB1c2hieXRlcyAweDcyNjU2MTY0NWY3MDcyNmY3MDY1NzI3NDc5IC8vICJyZWFkX3Byb3BlcnR5IgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCXB1c2hieXRlcyAweDc2MmU2MzYxNDE2YzY3NmYyZTMwMmU2MTczIC8vICJ2LmNhQWxnby4wLmFzIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM1MQoJLy8gY2FBbGdvRGF0YSA9IHRoaXMuaXR4bi5sYXN0TG9nCglpdHhuIExhc3RMb2cKCWZyYW1lX2J1cnkgMCAvLyBjYUFsZ29EYXRhOiBieXRlW10KCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzUyCgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IGNhQWxnb0RhdGEubGVuZ3RoOyBpICs9IDMyKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCipmb3JfMTA6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzUyCgkvLyBpIDwgY2FBbGdvRGF0YS5sZW5ndGgKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gY2FBbGdvRGF0YTogYnl0ZVtdCglsZW4KCTwKCWJ6ICpmb3JfMTBfZW5kCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM1MwoJLy8gYWRkciA9IGV4dHJhY3QzKGNhQWxnb0RhdGEsIGksIDMyKQoJZnJhbWVfZGlnIDAgLy8gY2FBbGdvRGF0YTogYnl0ZVtdCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgNiAvLyAzMgoJZXh0cmFjdDMKCWZyYW1lX2J1cnkgMiAvLyBhZGRyOiBieXRlW10KCgkvLyAqaWY1M19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzNTQKCS8vIGFkZHIgIT09IHJhd0J5dGVzKGdsb2JhbHMuemVyb0FkZHJlc3MpICYmIGFkZHIgPT09IHJhd0J5dGVzKGFkZHJUb0ZpbmQpCglmcmFtZV9kaWcgMiAvLyBhZGRyOiBieXRlW10KCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWR1cAoJYnogKnNraXBfYW5kMTEKCWZyYW1lX2RpZyAyIC8vIGFkZHI6IGJ5dGVbXQoJZnJhbWVfZGlnIC0yIC8vIGFkZHJUb0ZpbmQ6IEFkZHJlc3MKCT09CgkmJgoKKnNraXBfYW5kMTE6CglieiAqaWY1M19lbmQKCgkvLyAqaWY1M19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzU1CgkvLyByZXR1cm4gdHJ1ZQoJaW50YyAxIC8vIDEKCWIgKmlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdCpyZXR1cm4KCippZjUzX2VuZDoKCipmb3JfMTBfY29udGludWU6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzUyCgkvLyBpICs9IDMyCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgNiAvLyAzMgoJKwoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzEwCgoqZm9yXzEwX2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzNTgKCS8vIHJldHVybiBmYWxzZQoJaW50YyAwIC8vIDAKCippc0FkZHJlc3NJbk5GRENBQWxnb0xpc3QqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMgoJcmV0c3ViCgovLyBhbGdvU2F0dXJhdGlvbkxldmVsKCk6IHVpbnQ2NAovLwovLyBSZXR1cm5zIHRoZSBtYXhpbXVtIGFsbG93ZWQgc3Rha2UgcGVyIHZhbGlkYXRvciBiYXNlZCBvbiBhIHBlcmNlbnRhZ2Ugb2YgYWxsIGN1cnJlbnQgb25saW5lIHN0YWtlIGJlZm9yZQovLyB0aGUgdmFsaWRhdG9yIGlzIGNvbnNpZGVyZWQgc2F0dXJhdGVkIC0gd2hlcmUgcmV3YXJkcyBhcmUgZGltaW5pc2hlZC4KLy8gTk9URTogdGhpcyBmdW5jdGlvbiBpcyBkZWZpbmVkIHR3aWNlIC0gaGVyZSBhbmQgaW4gc3Rha2luZyBwb29sIGNvbnRyYWN0LiAgQm90aCBtdXN0IGJlIGlkZW50aWNhbC4KYWxnb1NhdHVyYXRpb25MZXZlbDoKCXByb3RvIDAgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM2NwoJLy8gb25saW5lID0gdGhpcy5nZXRDdXJyZW50T25saW5lU3Rha2UoKQoJY2FsbHN1YiBnZXRDdXJyZW50T25saW5lU3Rha2UKCWZyYW1lX2J1cnkgMCAvLyBvbmxpbmU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzNjkKCS8vIHJldHVybiB3aWRlUmF0aW8oW29ubGluZSwgTUFYX1ZBTElEQVRPUl9TT0ZUX1BDVF9PRl9PTkxJTkVfMURFQ0lNQUxdLCBbMTAwMF0pCglmcmFtZV9kaWcgMCAvLyBvbmxpbmU6IHVpbnQ2NAoJcHVzaGludCAxMDAKCW11bHcKCWludGMgMCAvLyAwCglpbnRjIDMyIC8vIDEwMDAKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCi8vIG1heEFsbG93ZWRTdGFrZSgpOiB1aW50NjQKLy8KLy8gUmV0dXJucyB0aGUgTUFYSU1VTSBhbGxvd2VkIHN0YWtlIHBlciB2YWxpZGF0b3IgYmFzZWQgb24gYSBwZXJjZW50YWdlIG9mIGFsbCBjdXJyZW50IG9ubGluZSBzdGFrZS4KLy8gQWRkaW5nIHN0YWtlIGlzIGNvbXBsZXRlbHkgYmxvY2tlZCBhdCB0aGlzIGFtb3VudC4KbWF4QWxsb3dlZFN0YWtlOgoJcHJvdG8gMCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDEgLy8gMHgKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzc3CgkvLyBvbmxpbmUgPSB0aGlzLmdldEN1cnJlbnRPbmxpbmVTdGFrZSgpCgljYWxsc3ViIGdldEN1cnJlbnRPbmxpbmVTdGFrZQoJZnJhbWVfYnVyeSAwIC8vIG9ubGluZTogdWludDY0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM3OQoJLy8gcmV0dXJuIHdpZGVSYXRpbyhbb25saW5lLCBNQVhfVkFMSURBVE9SX0hBUkRfUENUX09GX09OTElORV8xREVDSU1BTF0sIFsxMDAwXSkKCWZyYW1lX2RpZyAwIC8vIG9ubGluZTogdWludDY0CglwdXNoaW50IDE1MAoJbXVsdwoJaW50YyAwIC8vIDAKCWludGMgMzIgLy8gMTAwMAoJZGl2bW9kdwoJcG9wCglwb3AKCXN3YXAKCSEKCgkvLyB3aWRlUmF0aW8gZmFpbGVkCglhc3NlcnQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gbWF4QWxnb0FsbG93ZWRQZXJQb29sKCk6IHVpbnQ2NAovLwovLyBSZXR1cm5zIHRoZSBNQVhJTVVNIGFsbG93ZWQgc3Rha2UgcGVyIHBvb2wgYW5kIHN0aWxsIHJlY2VpdmUgaW5jZW50aXZlcyAtIHdlJ2xsIHRyZWF0IHRoaXMgYXMgdGhlICdtYXggcGVyIHBvb2wnCm1heEFsZ29BbGxvd2VkUGVyUG9vbDoKCXByb3RvIDAgMQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzODYKCS8vIHJldHVybiBnbG9iYWxzLnBheW91dHNNYXhCYWxhbmNlCglnbG9iYWwgUGF5b3V0c01heEJhbGFuY2UKCXJldHN1YgoKLy8gZ2V0Q3VycmVudE9ubGluZVN0YWtlKCk6IHVpbnQ2NApnZXRDdXJyZW50T25saW5lU3Rha2U6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzkwCgkvLyByZXR1cm4gb25saW5lU3Rha2UoKQoJb25saW5lX3N0YWtlCglyZXRzdWIKCi8vIG1pbkJhbGFuY2VGb3JBY2NvdW50KGNvbnRyYWN0czogdWludDY0LCBleHRyYVBhZ2VzOiB1aW50NjQsIGFzc2V0czogdWludDY0LCBsb2NhbEludHM6IHVpbnQ2NCwgbG9jYWxCeXRlczogdWludDY0LCBnbG9iYWxJbnRzOiB1aW50NjQsIGdsb2JhbEJ5dGVzOiB1aW50NjQpOiB1aW50NjQKbWluQmFsYW5jZUZvckFjY291bnQ6Cglwcm90byA3IDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE0MDIKCS8vIG1pbkJhbCA9IEFMR09SQU5EX0FDQ09VTlRfTUlOX0JBTEFOQ0UKCWludGMgMTYgLy8gMTAwMDAwCglmcmFtZV9idXJ5IDAgLy8gbWluQmFsOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxNDAzCgkvLyBtaW5CYWwgKz0gY29udHJhY3RzICogQVBQTElDQVRJT05fQkFTRV9GRUUKCWZyYW1lX2RpZyAwIC8vIG1pbkJhbDogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gY29udHJhY3RzOiB1aW50NjQKCWludGMgMTYgLy8gMTAwMDAwCgkqCgkrCglmcmFtZV9idXJ5IDAgLy8gbWluQmFsOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxNDA0CgkvLyBtaW5CYWwgKz0gZXh0cmFQYWdlcyAqIEFQUExJQ0FUSU9OX0JBU0VfRkVFCglmcmFtZV9kaWcgMCAvLyBtaW5CYWw6IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIGV4dHJhUGFnZXM6IHVpbnQ2NAoJaW50YyAxNiAvLyAxMDAwMDAKCSoKCSsKCWZyYW1lX2J1cnkgMCAvLyBtaW5CYWw6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE0MDUKCS8vIG1pbkJhbCArPSBhc3NldHMgKiBBU1NFVF9IT0xESU5HX0ZFRQoJZnJhbWVfZGlnIDAgLy8gbWluQmFsOiB1aW50NjQKCWZyYW1lX2RpZyAtMyAvLyBhc3NldHM6IHVpbnQ2NAoJaW50YyAxNiAvLyAxMDAwMDAKCSoKCSsKCWZyYW1lX2J1cnkgMCAvLyBtaW5CYWw6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE0MDYKCS8vIG1pbkJhbCArPSBsb2NhbEludHMgKiBTU0NfVkFMVUVfVUlOVAoJZnJhbWVfZGlnIDAgLy8gbWluQmFsOiB1aW50NjQKCWZyYW1lX2RpZyAtNCAvLyBsb2NhbEludHM6IHVpbnQ2NAoJaW50YyAzMyAvLyAyODUwMAoJKgoJKwoJZnJhbWVfYnVyeSAwIC8vIG1pbkJhbDogdWludDY0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTQwNwoJLy8gbWluQmFsICs9IGdsb2JhbEludHMgKiBTU0NfVkFMVUVfVUlOVAoJZnJhbWVfZGlnIDAgLy8gbWluQmFsOiB1aW50NjQKCWZyYW1lX2RpZyAtNiAvLyBnbG9iYWxJbnRzOiB1aW50NjQKCWludGMgMzMgLy8gMjg1MDAKCSoKCSsKCWZyYW1lX2J1cnkgMCAvLyBtaW5CYWw6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE0MDgKCS8vIG1pbkJhbCArPSBsb2NhbEJ5dGVzICogU1NDX1ZBTFVFX0JZVEVTCglmcmFtZV9kaWcgMCAvLyBtaW5CYWw6IHVpbnQ2NAoJZnJhbWVfZGlnIC01IC8vIGxvY2FsQnl0ZXM6IHVpbnQ2NAoJaW50YyAzNCAvLyA1MDAwMAoJKgoJKwoJZnJhbWVfYnVyeSAwIC8vIG1pbkJhbDogdWludDY0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTQwOQoJLy8gbWluQmFsICs9IGdsb2JhbEJ5dGVzICogU1NDX1ZBTFVFX0JZVEVTCglmcmFtZV9kaWcgMCAvLyBtaW5CYWw6IHVpbnQ2NAoJZnJhbWVfZGlnIC03IC8vIGdsb2JhbEJ5dGVzOiB1aW50NjQKCWludGMgMzQgLy8gNTAwMDAKCSoKCSsKCWZyYW1lX2J1cnkgMCAvLyBtaW5CYWw6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE0MTAKCS8vIHJldHVybiBtaW5CYWwKCWZyYW1lX2RpZyAwIC8vIG1pbkJhbDogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCi8vIGNvc3RGb3JCb3hTdG9yYWdlKHRvdGFsTnVtQnl0ZXM6IHVpbnQ2NCk6IHVpbnQ2NApjb3N0Rm9yQm94U3RvcmFnZToKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE0MTcKCS8vIHJldHVybiBTQ0JPWF9QRVJCT1ggKyB0b3RhbE51bUJ5dGVzICogU0NCT1hfUEVSQllURQoJcHVzaGludCAyNTAwCglmcmFtZV9kaWcgLTEgLy8gdG90YWxOdW1CeXRlczogdWludDY0CglwdXNoaW50IDQwMAoJKgoJKwoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CglwdXNoYnl0ZXMgMHhiODQ0N2IzNiAvLyBtZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjcmVhdGUgTm9PcAoJZXJyCgoqY2FsbF9Ob09wOgoJcHVzaGJ5dGVzIDB4MWI1ZTgyYzYgLy8gbWV0aG9kICJpbml0U3Rha2luZ0NvbnRyYWN0KHVpbnQ2NCl2b2lkIgoJcHVzaGJ5dGVzIDB4Nzk0NzJkODMgLy8gbWV0aG9kICJsb2FkU3Rha2luZ0NvbnRyYWN0RGF0YSh1aW50NjQsYnl0ZVtdKXZvaWQiCglwdXNoYnl0ZXMgMHg1ZjdhY2ZkOSAvLyBtZXRob2QgImZpbmFsaXplU3Rha2luZ0NvbnRyYWN0KCl2b2lkIgoJcHVzaGJ5dGVzIDB4MzE3MmNhOWQgLy8gbWV0aG9kICJnYXMoKXZvaWQiCglwdXNoYnl0ZXMgMHg4YTg3MTQyZCAvLyBtZXRob2QgImdldE1ickFtb3VudHMoKSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpIgoJcHVzaGJ5dGVzIDB4ZDEzNjZjYzMgLy8gbWV0aG9kICJnZXRQcm90b2NvbENvbnN0cmFpbnRzKCkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkiCglwdXNoYnl0ZXMgMHgzYjA0NWM1YyAvLyBtZXRob2QgImdldE51bVZhbGlkYXRvcnMoKXVpbnQ2NCIKCXB1c2hieXRlcyAweDc1YWZmNjFkIC8vIG1ldGhvZCAiZ2V0VmFsaWRhdG9yQ29uZmlnKHVpbnQ2NCkodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkiCglwdXNoYnl0ZXMgMHgxZjJmMDEwOSAvLyBtZXRob2QgImdldFZhbGlkYXRvclN0YXRlKHVpbnQ2NCkodWludDE2LHVpbnQ2NCx1aW50NjQsdWludDY0KSIKCXB1c2hieXRlcyAweDJmYTIyYzRiIC8vIG1ldGhvZCAiZ2V0VmFsaWRhdG9yT3duZXJBbmRNYW5hZ2VyKHVpbnQ2NCkoYWRkcmVzcyxhZGRyZXNzKSIKCXB1c2hieXRlcyAweDkxMGU5NGFjIC8vIG1ldGhvZCAiZ2V0UG9vbHModWludDY0KSh1aW50NjQsdWludDE2LHVpbnQ2NClbXSIKCXB1c2hieXRlcyAweDU3Mjc2N2QxIC8vIG1ldGhvZCAiZ2V0UG9vbEFwcElkKHVpbnQ2NCx1aW50NjQpdWludDY0IgoJcHVzaGJ5dGVzIDB4OWI1MDRhYWYgLy8gbWV0aG9kICJnZXRQb29sSW5mbygodWludDY0LHVpbnQ2NCx1aW50NjQpKSh1aW50NjQsdWludDE2LHVpbnQ2NCkiCglwdXNoYnl0ZXMgMHhmYmM2MzE3OCAvLyBtZXRob2QgImdldEN1ck1heFN0YWtlUGVyUG9vbCh1aW50NjQpdWludDY0IgoJcHVzaGJ5dGVzIDB4MjQ0OThjZjQgLy8gbWV0aG9kICJkb2VzU3Rha2VyTmVlZFRvUGF5TUJSKGFkZHJlc3MpYm9vbCIKCXB1c2hieXRlcyAweGY4NDZkZDdhIC8vIG1ldGhvZCAiZ2V0U3Rha2VkUG9vbHNGb3JBY2NvdW50KGFkZHJlc3MpKHVpbnQ2NCx1aW50NjQsdWludDY0KVtdIgoJcHVzaGJ5dGVzIDB4ODMwNTA1MDEgLy8gbWV0aG9kICJnZXRUb2tlblBheW91dFJhdGlvKHVpbnQ2NCkodWludDY0WzI0XSx1aW50NjQpIgoJcHVzaGJ5dGVzIDB4N2JiYjZjOGQgLy8gbWV0aG9kICJnZXROb2RlUG9vbEFzc2lnbm1lbnRzKHVpbnQ2NCkoKHVpbnQ2NFszXSlbOF0pIgoJcHVzaGJ5dGVzIDB4ZjgzOTQxNGEgLy8gbWV0aG9kICJnZXRORkRSZWdpc3RyeUlEKCl1aW50NjQiCglwdXNoYnl0ZXMgMHgwYzMxN2NmYiAvLyBtZXRob2QgImFkZFZhbGlkYXRvcihwYXksc3RyaW5nLCh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KSl1aW50NjQiCglwdXNoYnl0ZXMgMHgzZTI4ODk3MiAvLyBtZXRob2QgImNoYW5nZVZhbGlkYXRvck1hbmFnZXIodWludDY0LGFkZHJlc3Mpdm9pZCIKCXB1c2hieXRlcyAweGRkNWZhYWRhIC8vIG1ldGhvZCAiY2hhbmdlVmFsaWRhdG9yU3Vuc2V0SW5mbyh1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgoJcHVzaGJ5dGVzIDB4MThhYWM3YTcgLy8gbWV0aG9kICJjaGFuZ2VWYWxpZGF0b3JORkQodWludDY0LHVpbnQ2NCxzdHJpbmcpdm9pZCIKCXB1c2hieXRlcyAweGY5OWVmNTRkIC8vIG1ldGhvZCAiY2hhbmdlVmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3ModWludDY0LGFkZHJlc3Mpdm9pZCIKCXB1c2hieXRlcyAweDEwODA5ZDRkIC8vIG1ldGhvZCAiY2hhbmdlVmFsaWRhdG9yUmV3YXJkSW5mbyh1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCl2b2lkIgoJcHVzaGJ5dGVzIDB4ZTc3OGRkNWEgLy8gbWV0aG9kICJhZGRQb29sKHBheSx1aW50NjQsdWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCkiCglwdXNoYnl0ZXMgMHhiZjUyNTlkMCAvLyBtZXRob2QgImFkZFN0YWtlKHBheSx1aW50NjQsdWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCkiCglwdXNoYnl0ZXMgMHg0ZGY4ZDg2ZSAvLyBtZXRob2QgInNldFRva2VuUGF5b3V0UmF0aW8odWludDY0KSh1aW50NjRbMjRdLHVpbnQ2NCkiCglwdXNoYnl0ZXMgMHg0MThmY2VmYyAvLyBtZXRob2QgInN0YWtlVXBkYXRlZFZpYVJld2FyZHMoKHVpbnQ2NCx1aW50NjQsdWludDY0KSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKCXB1c2hieXRlcyAweGEyZGM1MWI1IC8vIG1ldGhvZCAic3Rha2VSZW1vdmVkKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyx1aW50NjQsdWludDY0LGJvb2wpdm9pZCIKCXB1c2hieXRlcyAweDI4NzNmNTA0IC8vIG1ldGhvZCAiZmluZFBvb2xGb3JTdGFrZXIodWludDY0LGFkZHJlc3MsdWludDY0KSgodWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYm9vbCkiCglwdXNoYnl0ZXMgMHgwNTQ3ZjRmZSAvLyBtZXRob2QgIm1vdmVQb29sVG9Ob2RlKHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCglwdXNoYnl0ZXMgMHhjYjY2ODM1OCAvLyBtZXRob2QgImVtcHR5VG9rZW5SZXdhcmRzKHVpbnQ2NCxhZGRyZXNzKXVpbnQ2NCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfaW5pdFN0YWtpbmdDb250cmFjdCAqYWJpX3JvdXRlX2xvYWRTdGFraW5nQ29udHJhY3REYXRhICphYmlfcm91dGVfZmluYWxpemVTdGFraW5nQ29udHJhY3QgKmFiaV9yb3V0ZV9nYXMgKmFiaV9yb3V0ZV9nZXRNYnJBbW91bnRzICphYmlfcm91dGVfZ2V0UHJvdG9jb2xDb25zdHJhaW50cyAqYWJpX3JvdXRlX2dldE51bVZhbGlkYXRvcnMgKmFiaV9yb3V0ZV9nZXRWYWxpZGF0b3JDb25maWcgKmFiaV9yb3V0ZV9nZXRWYWxpZGF0b3JTdGF0ZSAqYWJpX3JvdXRlX2dldFZhbGlkYXRvck93bmVyQW5kTWFuYWdlciAqYWJpX3JvdXRlX2dldFBvb2xzICphYmlfcm91dGVfZ2V0UG9vbEFwcElkICphYmlfcm91dGVfZ2V0UG9vbEluZm8gKmFiaV9yb3V0ZV9nZXRDdXJNYXhTdGFrZVBlclBvb2wgKmFiaV9yb3V0ZV9kb2VzU3Rha2VyTmVlZFRvUGF5TUJSICphYmlfcm91dGVfZ2V0U3Rha2VkUG9vbHNGb3JBY2NvdW50ICphYmlfcm91dGVfZ2V0VG9rZW5QYXlvdXRSYXRpbyAqYWJpX3JvdXRlX2dldE5vZGVQb29sQXNzaWdubWVudHMgKmFiaV9yb3V0ZV9nZXRORkRSZWdpc3RyeUlEICphYmlfcm91dGVfYWRkVmFsaWRhdG9yICphYmlfcm91dGVfY2hhbmdlVmFsaWRhdG9yTWFuYWdlciAqYWJpX3JvdXRlX2NoYW5nZVZhbGlkYXRvclN1bnNldEluZm8gKmFiaV9yb3V0ZV9jaGFuZ2VWYWxpZGF0b3JORkQgKmFiaV9yb3V0ZV9jaGFuZ2VWYWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyAqYWJpX3JvdXRlX2NoYW5nZVZhbGlkYXRvclJld2FyZEluZm8gKmFiaV9yb3V0ZV9hZGRQb29sICphYmlfcm91dGVfYWRkU3Rha2UgKmFiaV9yb3V0ZV9zZXRUb2tlblBheW91dFJhdGlvICphYmlfcm91dGVfc3Rha2VVcGRhdGVkVmlhUmV3YXJkcyAqYWJpX3JvdXRlX3N0YWtlUmVtb3ZlZCAqYWJpX3JvdXRlX2ZpbmRQb29sRm9yU3Rha2VyICphYmlfcm91dGVfbW92ZVBvb2xUb05vZGUgKmFiaV9yb3V0ZV9lbXB0eVRva2VuUmV3YXJkcwoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjYWxsIE5vT3AKCWVycg==","clear":"I3ByYWdtYSB2ZXJzaW9uIDEx"},"templateVariables":{"nfdRegistryAppId":{"type":"uint64"}},"scratchVariables":{"nfdRegistryAppId":{"type":"uint64","slot":200}}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never

// Type definitions for ARC-56 structs

export type ValidatorInfo = {
  config: {
    id: bigint
    owner: string
    manager: string
    nfdForInfo: bigint
    entryGatingType: number
    entryGatingAddress: string
    entryGatingAssets: [bigint, bigint, bigint, bigint]
    gatingAssetMinBalance: bigint
    rewardTokenId: bigint
    rewardPerPayout: bigint
    epochRoundLength: number
    percentToValidator: number
    validatorCommissionAddress: string
    minEntryStake: bigint
    maxAlgoPerPool: bigint
    poolsPerNode: number
    sunsettingOn: bigint
    sunsettingTo: bigint
  }
  state: {
    numPools: number
    totalStakers: bigint
    totalAlgoStaked: bigint
    rewardTokenHeldBack: bigint
  }
  pools: [
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
    [bigint, number, bigint],
  ]
  tokenPayoutRatio: {
    poolPctOfWhole: [
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
    ]
    updatedForPayout: bigint
  }
  nodePoolAssignments: {
    nodes: [
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
    ]
  }
}

/**
 * Converts the ABI tuple representation of a ValidatorInfo to the struct representation
 */
export function ValidatorInfoFromTuple(
  abiTuple: [
    [
      bigint,
      string,
      string,
      bigint,
      number,
      string,
      [bigint, bigint, bigint, bigint],
      bigint,
      bigint,
      bigint,
      number,
      number,
      string,
      bigint,
      bigint,
      number,
      bigint,
      bigint,
    ],
    [number, bigint, bigint, bigint],
    [
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
      [bigint, number, bigint],
    ],
    [
      [
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
      ],
      bigint,
    ],
    [
      [
        [[bigint, bigint, bigint]],
        [[bigint, bigint, bigint]],
        [[bigint, bigint, bigint]],
        [[bigint, bigint, bigint]],
        [[bigint, bigint, bigint]],
        [[bigint, bigint, bigint]],
        [[bigint, bigint, bigint]],
        [[bigint, bigint, bigint]],
      ],
    ],
  ],
) {
  const abiStructType = ABIStructType.fromStruct('ValidatorInfo', APP_SPEC.structs)
  return getStructValueFromTupleValue(abiStructType, abiTuple) as ValidatorInfo
}

export type MbrAmounts = {
  addValidatorMbr: bigint
  addPoolMbr: bigint
  poolInitMbr: bigint
  addStakerMbr: bigint
}

/**
 * Converts the ABI tuple representation of a MbrAmounts to the struct representation
 */
export function MbrAmountsFromTuple(abiTuple: [bigint, bigint, bigint, bigint]) {
  const abiStructType = ABIStructType.fromStruct('MbrAmounts', APP_SPEC.structs)
  return getStructValueFromTupleValue(abiStructType, abiTuple) as MbrAmounts
}

export type Constraints = {
  epochPayoutRoundsMin: bigint
  epochPayoutRoundsMax: bigint
  minPctToValidatorWFourDecimals: bigint
  maxPctToValidatorWFourDecimals: bigint
  minEntryStake: bigint
  maxAlgoPerPool: bigint
  maxAlgoPerValidator: bigint
  amtConsideredSaturated: bigint
  maxNodes: bigint
  maxPoolsPerNode: bigint
  maxStakersPerPool: bigint
}

/**
 * Converts the ABI tuple representation of a Constraints to the struct representation
 */
export function ConstraintsFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint]) {
  const abiStructType = ABIStructType.fromStruct('Constraints', APP_SPEC.structs)
  return getStructValueFromTupleValue(abiStructType, abiTuple) as Constraints
}

export type ValidatorConfig = {
  id: bigint
  owner: string
  manager: string
  nfdForInfo: bigint
  entryGatingType: number
  entryGatingAddress: string
  entryGatingAssets: [bigint, bigint, bigint, bigint]
  gatingAssetMinBalance: bigint
  rewardTokenId: bigint
  rewardPerPayout: bigint
  epochRoundLength: number
  percentToValidator: number
  validatorCommissionAddress: string
  minEntryStake: bigint
  maxAlgoPerPool: bigint
  poolsPerNode: number
  sunsettingOn: bigint
  sunsettingTo: bigint
}

/**
 * Converts the ABI tuple representation of a ValidatorConfig to the struct representation
 */
export function ValidatorConfigFromTuple(
  abiTuple: [
    bigint,
    string,
    string,
    bigint,
    number,
    string,
    [bigint, bigint, bigint, bigint],
    bigint,
    bigint,
    bigint,
    number,
    number,
    string,
    bigint,
    bigint,
    number,
    bigint,
    bigint,
  ],
) {
  const abiStructType = ABIStructType.fromStruct('ValidatorConfig', APP_SPEC.structs)
  return getStructValueFromTupleValue(abiStructType, abiTuple) as ValidatorConfig
}

export type ValidatorCurState = {
  numPools: number
  totalStakers: bigint
  totalAlgoStaked: bigint
  rewardTokenHeldBack: bigint
}

/**
 * Converts the ABI tuple representation of a ValidatorCurState to the struct representation
 */
export function ValidatorCurStateFromTuple(abiTuple: [number, bigint, bigint, bigint]) {
  const abiStructType = ABIStructType.fromStruct('ValidatorCurState', APP_SPEC.structs)
  return getStructValueFromTupleValue(abiStructType, abiTuple) as ValidatorCurState
}

export type PoolInfo = {
  poolAppId: bigint
  totalStakers: number
  totalAlgoStaked: bigint
}

/**
 * Converts the ABI tuple representation of a PoolInfo to the struct representation
 */
export function PoolInfoFromTuple(abiTuple: [bigint, number, bigint]) {
  const abiStructType = ABIStructType.fromStruct('PoolInfo', APP_SPEC.structs)
  return getStructValueFromTupleValue(abiStructType, abiTuple) as PoolInfo
}

export type ValidatorPoolKey = {
  id: bigint
  poolId: bigint
  poolAppId: bigint
}

/**
 * Converts the ABI tuple representation of a ValidatorPoolKey to the struct representation
 */
export function ValidatorPoolKeyFromTuple(abiTuple: [bigint, bigint, bigint]) {
  const abiStructType = ABIStructType.fromStruct('ValidatorPoolKey', APP_SPEC.structs)
  return getStructValueFromTupleValue(abiStructType, abiTuple) as ValidatorPoolKey
}

export type PoolTokenPayoutRatio = {
  poolPctOfWhole: [
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
  ]
  updatedForPayout: bigint
}

/**
 * Converts the ABI tuple representation of a PoolTokenPayoutRatio to the struct representation
 */
export function PoolTokenPayoutRatioFromTuple(
  abiTuple: [
    [
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
    ],
    bigint,
  ],
) {
  const abiStructType = ABIStructType.fromStruct('PoolTokenPayoutRatio', APP_SPEC.structs)
  return getStructValueFromTupleValue(abiStructType, abiTuple) as PoolTokenPayoutRatio
}

export type NodePoolAssignmentConfig = {
  nodes: [
    [[bigint, bigint, bigint]],
    [[bigint, bigint, bigint]],
    [[bigint, bigint, bigint]],
    [[bigint, bigint, bigint]],
    [[bigint, bigint, bigint]],
    [[bigint, bigint, bigint]],
    [[bigint, bigint, bigint]],
    [[bigint, bigint, bigint]],
  ]
}

/**
 * Converts the ABI tuple representation of a NodePoolAssignmentConfig to the struct representation
 */
export function NodePoolAssignmentConfigFromTuple(
  abiTuple: [
    [
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
      [[bigint, bigint, bigint]],
    ],
  ],
) {
  const abiStructType = ABIStructType.fromStruct('NodePoolAssignmentConfig', APP_SPEC.structs)
  return getStructValueFromTupleValue(abiStructType, abiTuple) as NodePoolAssignmentConfig
}

/**
 * Deploy-time template variables
 */
export type TemplateVariables = {
  nfdRegistryAppId: bigint | number
}

/**
 * The argument types for the ValidatorRegistry contract
 */
export type ValidatorRegistryArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'createApplication()void': Record<string, never>
    'initStakingContract(uint64)void': {
      approvalProgramSize: bigint | number
    }
    'loadStakingContractData(uint64,byte[])void': {
      offset: bigint | number
      data: Uint8Array
    }
    'finalizeStakingContract()void': Record<string, never>
    'gas()void': Record<string, never>
    'getMbrAmounts()(uint64,uint64,uint64,uint64)': Record<string, never>
    'getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': Record<string, never>
    'getNumValidators()uint64': Record<string, never>
    'getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)': {
      validatorId: bigint | number
    }
    'getValidatorState(uint64)(uint16,uint64,uint64,uint64)': {
      validatorId: bigint | number
    }
    'getValidatorOwnerAndManager(uint64)(address,address)': {
      validatorId: bigint | number
    }
    'getPools(uint64)(uint64,uint16,uint64)[]': {
      /**
      * PoolInfo[] - array of pools
      Not callable from other contracts because 1K return but can be called w/ simulate which bumps log returns

       */
      validatorId: bigint | number
    }
    'getPoolAppId(uint64,uint64)uint64': {
      validatorId: bigint | number
      poolId: bigint | number
    }
    'getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)': {
      poolKey: ValidatorPoolKey
    }
    'getCurMaxStakePerPool(uint64)uint64': {
      /**
       * The id of the validator.
       */
      validatorId: bigint | number
    }
    'doesStakerNeedToPayMBR(address)bool': {
      staker: string
    }
    'getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]': {
      /**
      * The account to retrieve staked pools for.
      ValidatorPoolKey[] - The array of staked pools for the account.

       */
      staker: string
    }
    'getTokenPayoutRatio(uint64)(uint64[24],uint64)': {
      /**
      * The id of the validator.
      PoolTokenPayoutRatio - The token payout ratio for the validator.

       */
      validatorId: bigint | number
    }
    'getNodePoolAssignments(uint64)((uint64[3])[8])': {
      validatorId: bigint | number
    }
    'getNFDRegistryID()uint64': Record<string, never>
    'addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64': {
      /**
       * payment from caller which covers mbr increase of new validator storage
       */
      mbrPayment: AppMethodCallTransactionArgument
      /**
       * (Optional) Name of nfd (used as double-check against id specified in config)
       */
      nfdName: string
      /**
       * ValidatorConfig struct
       */
      config: ValidatorConfig
    }
    'changeValidatorManager(uint64,address)void': {
      /**
       * The id of the validator to change the manager for.
       */
      validatorId: bigint | number
      /**
       * The new manager address.
       */
      manager: string
    }
    'changeValidatorSunsetInfo(uint64,uint64,uint64)void': {
      /**
       * The id of the validator to update.
       */
      validatorId: bigint | number
      /**
       * The new sunset timestamp.
       */
      sunsettingOn: bigint | number
      /**
       * The new sunset to validator id.
       */
      sunsettingTo: bigint | number
    }
    'changeValidatorNFD(uint64,uint64,string)void': {
      /**
       * The id of the validator to update.
       */
      validatorId: bigint | number
      /**
       * The application id of the NFD to assign to the validator.
       */
      nfdAppID: bigint | number
      /**
       * The name of the NFD (which must match)
       */
      nfdName: string
    }
    'changeValidatorCommissionAddress(uint64,address)void': {
      validatorId: bigint | number
      commissionAddress: string
    }
    'changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void': {
      validatorId: bigint | number
      EntryGatingType: bigint | number
      EntryGatingAddress: string
      EntryGatingAssets: [bigint | number, bigint | number, bigint | number, bigint | number]
      GatingAssetMinBalance: bigint | number
      RewardPerPayout: bigint | number
    }
    'addPool(pay,uint64,uint64)(uint64,uint64,uint64)': {
      /**
       * payment from caller which covers mbr increase of adding a new pool
       */
      mbrPayment: AppMethodCallTransactionArgument
      /**
       * is id of validator to pool to (must be owner or manager)
       */
      validatorId: bigint | number
      /**
       * is node number to add to
       */
      nodeNum: bigint | number
    }
    'addStake(pay,uint64,uint64)(uint64,uint64,uint64)': {
      /**
       * payment coming from staker to place into a pool
       */
      stakedAmountPayment: AppMethodCallTransactionArgument
      /**
       * The id of the validator.
       */
      validatorId: bigint | number
      /**
      * only if validator has gating to enter - this is asset id or nfd id that corresponds to gating.
      Txn sender is factored in as well if that is part of gating.
      *

       */
      valueToVerify: bigint | number
    }
    'setTokenPayoutRatio(uint64)(uint64[24],uint64)': {
      /**
       * validator id (and thus pool) calling us.  Verified so that sender MUST be pool 1 of this validator.
       */
      validatorId: bigint | number
    }
    'stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void': {
      /**
       * ValidatorPoolKey type
       */
      poolKey: ValidatorPoolKey
      /**
       * amount this validator's total stake increased via rewards
       */
      algoToAdd: bigint | number
      /**
       * amount this validator's total stake increased via rewards (that should be
       */
      rewardTokenAmountReserved: bigint | number
      /**
       * the commission amount the validator was paid, if any
       */
      validatorCommission: bigint | number
      /**
      * if the pool was in saturated state, the amount sent back to the fee sink.
      seen as 'accounted for/pending spent')

       */
      saturatedBurnToFeeSink: bigint | number
    }
    'stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void': {
      /**
       * calling us from which stake was removed
       */
      poolKey: ValidatorPoolKey
      staker: string
      /**
       * algo amount removed
       */
      amountRemoved: bigint | number
      /**
       * if applicable, amount of token reward removed (by pool 1 caller) or TO remove and pay out (via pool 1 from different pool caller)
       */
      rewardRemoved: bigint | number
      stakerRemoved: boolean
    }
    'findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)': {
      /**
       * The id of the validator.
       */
      validatorId: bigint | number
      /**
       * The address of the staker.
       */
      staker: string
      /**
       * The amount to stake.
       */
      amountToStake: bigint | number
    }
    'movePoolToNode(uint64,uint64,uint64)void': {
      /**
       * The id of the validator.
       */
      validatorId: bigint | number
      poolAppId: bigint | number
      nodeNum: bigint | number
    }
    'emptyTokenRewards(uint64,address)uint64': {
      /**
       * The id of the validator.
       */
      validatorId: bigint | number
      /**
       * the account to send the tokens to (must already be opted-in to the reward token)
       */
      receiver: string
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'createApplication()void': []
    'initStakingContract(uint64)void': [approvalProgramSize: bigint | number]
    'loadStakingContractData(uint64,byte[])void': [offset: bigint | number, data: Uint8Array]
    'finalizeStakingContract()void': []
    'gas()void': []
    'getMbrAmounts()(uint64,uint64,uint64,uint64)': []
    'getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': []
    'getNumValidators()uint64': []
    'getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)': [
      validatorId: bigint | number,
    ]
    'getValidatorState(uint64)(uint16,uint64,uint64,uint64)': [validatorId: bigint | number]
    'getValidatorOwnerAndManager(uint64)(address,address)': [validatorId: bigint | number]
    'getPools(uint64)(uint64,uint16,uint64)[]': [validatorId: bigint | number]
    'getPoolAppId(uint64,uint64)uint64': [validatorId: bigint | number, poolId: bigint | number]
    'getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)': [poolKey: ValidatorPoolKey]
    'getCurMaxStakePerPool(uint64)uint64': [validatorId: bigint | number]
    'doesStakerNeedToPayMBR(address)bool': [staker: string]
    'getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]': [staker: string]
    'getTokenPayoutRatio(uint64)(uint64[24],uint64)': [validatorId: bigint | number]
    'getNodePoolAssignments(uint64)((uint64[3])[8])': [validatorId: bigint | number]
    'getNFDRegistryID()uint64': []
    'addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64': [
      mbrPayment: AppMethodCallTransactionArgument,
      nfdName: string,
      config: ValidatorConfig,
    ]
    'changeValidatorManager(uint64,address)void': [validatorId: bigint | number, manager: string]
    'changeValidatorSunsetInfo(uint64,uint64,uint64)void': [
      validatorId: bigint | number,
      sunsettingOn: bigint | number,
      sunsettingTo: bigint | number,
    ]
    'changeValidatorNFD(uint64,uint64,string)void': [validatorId: bigint | number, nfdAppID: bigint | number, nfdName: string]
    'changeValidatorCommissionAddress(uint64,address)void': [validatorId: bigint | number, commissionAddress: string]
    'changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void': [
      validatorId: bigint | number,
      EntryGatingType: bigint | number,
      EntryGatingAddress: string,
      EntryGatingAssets: [bigint | number, bigint | number, bigint | number, bigint | number],
      GatingAssetMinBalance: bigint | number,
      RewardPerPayout: bigint | number,
    ]
    'addPool(pay,uint64,uint64)(uint64,uint64,uint64)': [
      mbrPayment: AppMethodCallTransactionArgument,
      validatorId: bigint | number,
      nodeNum: bigint | number,
    ]
    'addStake(pay,uint64,uint64)(uint64,uint64,uint64)': [
      stakedAmountPayment: AppMethodCallTransactionArgument,
      validatorId: bigint | number,
      valueToVerify: bigint | number,
    ]
    'setTokenPayoutRatio(uint64)(uint64[24],uint64)': [validatorId: bigint | number]
    'stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void': [
      poolKey: ValidatorPoolKey,
      algoToAdd: bigint | number,
      rewardTokenAmountReserved: bigint | number,
      validatorCommission: bigint | number,
      saturatedBurnToFeeSink: bigint | number,
    ]
    'stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void': [
      poolKey: ValidatorPoolKey,
      staker: string,
      amountRemoved: bigint | number,
      rewardRemoved: bigint | number,
      stakerRemoved: boolean,
    ]
    'findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)': [
      validatorId: bigint | number,
      staker: string,
      amountToStake: bigint | number,
    ]
    'movePoolToNode(uint64,uint64,uint64)void': [validatorId: bigint | number, poolAppId: bigint | number, nodeNum: bigint | number]
    'emptyTokenRewards(uint64,address)uint64': [validatorId: bigint | number, receiver: string]
  }
}

/**
 * The return type for each method
 */
export type ValidatorRegistryReturns = {
  'createApplication()void': void
  'initStakingContract(uint64)void': void
  'loadStakingContractData(uint64,byte[])void': void
  'finalizeStakingContract()void': void
  'gas()void': void
  'getMbrAmounts()(uint64,uint64,uint64,uint64)': MbrAmounts
  'getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': Constraints
  'getNumValidators()uint64': bigint
  'getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)': ValidatorConfig
  'getValidatorState(uint64)(uint16,uint64,uint64,uint64)': ValidatorCurState
  'getValidatorOwnerAndManager(uint64)(address,address)': [string, string]
  'getPools(uint64)(uint64,uint16,uint64)[]': [bigint, number, bigint][]
  'getPoolAppId(uint64,uint64)uint64': bigint
  'getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)': PoolInfo
  'getCurMaxStakePerPool(uint64)uint64': bigint
  'doesStakerNeedToPayMBR(address)bool': boolean
  'getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]': [bigint, bigint, bigint][]
  'getTokenPayoutRatio(uint64)(uint64[24],uint64)': PoolTokenPayoutRatio
  'getNodePoolAssignments(uint64)((uint64[3])[8])': NodePoolAssignmentConfig
  'getNFDRegistryID()uint64': bigint
  'addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64': bigint
  'changeValidatorManager(uint64,address)void': void
  'changeValidatorSunsetInfo(uint64,uint64,uint64)void': void
  'changeValidatorNFD(uint64,uint64,string)void': void
  'changeValidatorCommissionAddress(uint64,address)void': void
  'changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void': void
  'addPool(pay,uint64,uint64)(uint64,uint64,uint64)': ValidatorPoolKey
  'addStake(pay,uint64,uint64)(uint64,uint64,uint64)': ValidatorPoolKey
  'setTokenPayoutRatio(uint64)(uint64[24],uint64)': PoolTokenPayoutRatio
  'stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void': void
  'stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void': void
  'findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)': [[bigint, bigint, bigint], boolean, boolean]
  'movePoolToNode(uint64,uint64,uint64)void': void
  'emptyTokenRewards(uint64,address)uint64': bigint
}

/**
 * Defines the types of available calls and state of the ValidatorRegistry smart contract.
 */
export type ValidatorRegistryTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods: Record<
    'createApplication()void' | 'createApplication',
    {
      argsObj: ValidatorRegistryArgs['obj']['createApplication()void']
      argsTuple: ValidatorRegistryArgs['tuple']['createApplication()void']
      returns: ValidatorRegistryReturns['createApplication()void']
    }
  > &
    Record<
      'initStakingContract(uint64)void' | 'initStakingContract',
      {
        argsObj: ValidatorRegistryArgs['obj']['initStakingContract(uint64)void']
        argsTuple: ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']
        returns: ValidatorRegistryReturns['initStakingContract(uint64)void']
      }
    > &
    Record<
      'loadStakingContractData(uint64,byte[])void' | 'loadStakingContractData',
      {
        argsObj: ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void']
        argsTuple: ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']
        returns: ValidatorRegistryReturns['loadStakingContractData(uint64,byte[])void']
      }
    > &
    Record<
      'finalizeStakingContract()void' | 'finalizeStakingContract',
      {
        argsObj: ValidatorRegistryArgs['obj']['finalizeStakingContract()void']
        argsTuple: ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']
        returns: ValidatorRegistryReturns['finalizeStakingContract()void']
      }
    > &
    Record<
      'gas()void' | 'gas',
      {
        argsObj: ValidatorRegistryArgs['obj']['gas()void']
        argsTuple: ValidatorRegistryArgs['tuple']['gas()void']
        returns: ValidatorRegistryReturns['gas()void']
      }
    > &
    Record<
      'getMbrAmounts()(uint64,uint64,uint64,uint64)' | 'getMbrAmounts',
      {
        argsObj: ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
        argsTuple: ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
        returns: ValidatorRegistryReturns['getMbrAmounts()(uint64,uint64,uint64,uint64)']
      }
    > &
    Record<
      'getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)' | 'getProtocolConstraints',
      {
        argsObj: ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
        argsTuple: ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
        returns: ValidatorRegistryReturns['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
      }
    > &
    Record<
      'getNumValidators()uint64' | 'getNumValidators',
      {
        argsObj: ValidatorRegistryArgs['obj']['getNumValidators()uint64']
        argsTuple: ValidatorRegistryArgs['tuple']['getNumValidators()uint64']
        returns: ValidatorRegistryReturns['getNumValidators()uint64']
      }
    > &
    Record<
      | 'getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)'
      | 'getValidatorConfig',
      {
        argsObj: ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
        argsTuple: ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
        returns: ValidatorRegistryReturns['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
      }
    > &
    Record<
      'getValidatorState(uint64)(uint16,uint64,uint64,uint64)' | 'getValidatorState',
      {
        argsObj: ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
        argsTuple: ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
        returns: ValidatorRegistryReturns['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
      }
    > &
    Record<
      'getValidatorOwnerAndManager(uint64)(address,address)' | 'getValidatorOwnerAndManager',
      {
        argsObj: ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)']
        argsTuple: ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']
        returns: ValidatorRegistryReturns['getValidatorOwnerAndManager(uint64)(address,address)']
      }
    > &
    Record<
      'getPools(uint64)(uint64,uint16,uint64)[]' | 'getPools',
      {
        argsObj: ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]']
        argsTuple: ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']
        returns: ValidatorRegistryReturns['getPools(uint64)(uint64,uint16,uint64)[]']
      }
    > &
    Record<
      'getPoolAppId(uint64,uint64)uint64' | 'getPoolAppId',
      {
        argsObj: ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64']
        argsTuple: ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']
        returns: ValidatorRegistryReturns['getPoolAppId(uint64,uint64)uint64']
      }
    > &
    Record<
      'getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)' | 'getPoolInfo',
      {
        argsObj: ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
        argsTuple: ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
        returns: ValidatorRegistryReturns['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
      }
    > &
    Record<
      'getCurMaxStakePerPool(uint64)uint64' | 'getCurMaxStakePerPool',
      {
        argsObj: ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64']
        argsTuple: ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']
        returns: ValidatorRegistryReturns['getCurMaxStakePerPool(uint64)uint64']
      }
    > &
    Record<
      'doesStakerNeedToPayMBR(address)bool' | 'doesStakerNeedToPayMBR',
      {
        argsObj: ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool']
        argsTuple: ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']
        returns: ValidatorRegistryReturns['doesStakerNeedToPayMBR(address)bool']
      }
    > &
    Record<
      'getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]' | 'getStakedPoolsForAccount',
      {
        argsObj: ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
        argsTuple: ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
        returns: ValidatorRegistryReturns['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
      }
    > &
    Record<
      'getTokenPayoutRatio(uint64)(uint64[24],uint64)' | 'getTokenPayoutRatio',
      {
        argsObj: ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
        argsTuple: ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
        returns: ValidatorRegistryReturns['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
      }
    > &
    Record<
      'getNodePoolAssignments(uint64)((uint64[3])[8])' | 'getNodePoolAssignments',
      {
        argsObj: ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])']
        argsTuple: ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']
        returns: ValidatorRegistryReturns['getNodePoolAssignments(uint64)((uint64[3])[8])']
      }
    > &
    Record<
      'getNFDRegistryID()uint64' | 'getNFDRegistryID',
      {
        argsObj: ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64']
        argsTuple: ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']
        returns: ValidatorRegistryReturns['getNFDRegistryID()uint64']
      }
    > &
    Record<
      | 'addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64'
      | 'addValidator',
      {
        argsObj: ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
        argsTuple: ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
        /**
         * uint64 validator id
         */
        returns: ValidatorRegistryReturns['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
      }
    > &
    Record<
      'changeValidatorManager(uint64,address)void' | 'changeValidatorManager',
      {
        argsObj: ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void']
        argsTuple: ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']
        returns: ValidatorRegistryReturns['changeValidatorManager(uint64,address)void']
      }
    > &
    Record<
      'changeValidatorSunsetInfo(uint64,uint64,uint64)void' | 'changeValidatorSunsetInfo',
      {
        argsObj: ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
        argsTuple: ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
        returns: ValidatorRegistryReturns['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
      }
    > &
    Record<
      'changeValidatorNFD(uint64,uint64,string)void' | 'changeValidatorNFD',
      {
        argsObj: ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void']
        argsTuple: ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']
        returns: ValidatorRegistryReturns['changeValidatorNFD(uint64,uint64,string)void']
      }
    > &
    Record<
      'changeValidatorCommissionAddress(uint64,address)void' | 'changeValidatorCommissionAddress',
      {
        argsObj: ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void']
        argsTuple: ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']
        returns: ValidatorRegistryReturns['changeValidatorCommissionAddress(uint64,address)void']
      }
    > &
    Record<
      'changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void' | 'changeValidatorRewardInfo',
      {
        argsObj: ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
        argsTuple: ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
        returns: ValidatorRegistryReturns['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
      }
    > &
    Record<
      'addPool(pay,uint64,uint64)(uint64,uint64,uint64)' | 'addPool',
      {
        argsObj: ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
        argsTuple: ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
        /**
         * ValidatorPoolKey pool key to created pool
         */
        returns: ValidatorRegistryReturns['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
      }
    > &
    Record<
      'addStake(pay,uint64,uint64)(uint64,uint64,uint64)' | 'addStake',
      {
        argsObj: ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
        argsTuple: ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
        /**
         * ValidatorPoolKey - The key of the validator pool.
         */
        returns: ValidatorRegistryReturns['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
      }
    > &
    Record<
      'setTokenPayoutRatio(uint64)(uint64[24],uint64)' | 'setTokenPayoutRatio',
      {
        argsObj: ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
        argsTuple: ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
        /**
         * PoolTokenPayoutRatio - the finished ratio data
         */
        returns: ValidatorRegistryReturns['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
      }
    > &
    Record<
      'stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void' | 'stakeUpdatedViaRewards',
      {
        argsObj: ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
        argsTuple: ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
        returns: ValidatorRegistryReturns['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
      }
    > &
    Record<
      'stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void' | 'stakeRemoved',
      {
        argsObj: ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
        argsTuple: ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
        returns: ValidatorRegistryReturns['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
      }
    > &
    Record<
      'findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)' | 'findPoolForStaker',
      {
        argsObj: ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
        argsTuple: ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
        /**
      * ValidatorPoolKey, boolean, boolean - The pool for the staker, true/false on whether the staker is 'new'
      to this VALIDATOR, and true/false if staker is new to the protocol.

       */
        returns: ValidatorRegistryReturns['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
      }
    > &
    Record<
      'movePoolToNode(uint64,uint64,uint64)void' | 'movePoolToNode',
      {
        argsObj: ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void']
        argsTuple: ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']
        returns: ValidatorRegistryReturns['movePoolToNode(uint64,uint64,uint64)void']
      }
    > &
    Record<
      'emptyTokenRewards(uint64,address)uint64' | 'emptyTokenRewards',
      {
        argsObj: ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64']
        argsTuple: ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']
        /**
         * uint64 the amount of reward token sent
         */
        returns: ValidatorRegistryReturns['emptyTokenRewards(uint64,address)uint64']
      }
    >
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        stakingPoolInitialized: boolean
        numValidators: bigint
        numStakers: bigint
        totalAlgoStaked: bigint
      }
      maps: {}
    }
    box: {
      keys: {
        stakingPoolApprovalProgram: BinaryState
      }
      maps: {
        validatorList: Map<bigint | number, ValidatorInfo>
        stakerPoolSet: Map<
          string,
          [
            [bigint, bigint, bigint],
            [bigint, bigint, bigint],
            [bigint, bigint, bigint],
            [bigint, bigint, bigint],
            [bigint, bigint, bigint],
            [bigint, bigint, bigint],
          ]
        >
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type ValidatorRegistrySignatures = keyof ValidatorRegistryTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type ValidatorRegistryNonVoidMethodSignatures = keyof ValidatorRegistryTypes['methods'] extends infer T
  ? T extends keyof ValidatorRegistryTypes['methods']
    ? MethodReturn<T> extends void
      ? never
      : T
    : never
  : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>
  }
>
/**
 * Maps a method signature from the ValidatorRegistry smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends ValidatorRegistrySignatures> = ValidatorRegistryTypes['methods'][TSignature][
  | 'argsObj'
  | 'argsTuple']
/**
 * Maps a method signature from the ValidatorRegistry smart contract to the method's return type
 */
export type MethodReturn<TSignature extends ValidatorRegistrySignatures> = ValidatorRegistryTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = ValidatorRegistryTypes['state']['global']['keys']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = ValidatorRegistryTypes['state']['box']['keys']

/**
 * Defines supported create method params for this smart contract
 */
export type ValidatorRegistryCreateCallParams =
  | Expand<
      CallParams<ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']> & {
        method: 'createApplication'
      } & { onComplete?: OnApplicationComplete.NoOp } & CreateSchema
    >
  | Expand<
      CallParams<ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']> & {
        method: 'createApplication()void'
      } & { onComplete?: OnApplicationComplete.NoOp } & CreateSchema
    >
/**
 * Defines arguments required for the deploy method.
 */
export type ValidatorRegistryDeployParams = Expand<
  Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: ValidatorRegistryCreateCallParams
  }
>

/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the ValidatorRegistry smart contract
 */
export abstract class ValidatorRegistryParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod<TParams extends ValidatorRegistryCreateCallParams & { method: string }>(params: TParams) {
        switch (params.method) {
          case 'createApplication':
          case 'createApplication()void':
            return ValidatorRegistryParamsFactory.create.createApplication(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs create ABI call params for the ValidatorRegistry smart contract using the createApplication()void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      createApplication(
        params: CallParams<
          ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']
        > &
          AppClientCompilationParams & { onComplete?: OnApplicationComplete.NoOp },
      ): AppClientMethodCallParams & AppClientCompilationParams & { onComplete?: OnApplicationComplete.NoOp } {
        return {
          ...params,
          method: 'createApplication()void' as const,
          args: Array.isArray(params.args) ? params.args : [],
        }
      },
    }
  }

  /**
   * Constructs a no op call for the initStakingContract(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initStakingContract(
    params: CallParams<
      ValidatorRegistryArgs['obj']['initStakingContract(uint64)void'] | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'initStakingContract(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.approvalProgramSize],
    }
  }
  /**
   * Constructs a no op call for the loadStakingContractData(uint64,byte[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static loadStakingContractData(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void']
      | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'loadStakingContractData(uint64,byte[])void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.offset, params.args.data],
    }
  }
  /**
   * Constructs a no op call for the finalizeStakingContract()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static finalizeStakingContract(
    params: CallParams<
      ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'finalizeStakingContract()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the gas()void ABI method
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static gas(
    params: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']> & CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'gas()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the getMbrAmounts()(uint64,uint64,uint64,uint64) ABI method
   *
  * Returns the MBR amounts needed for various actions:
  [
  addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
  addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
  poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
  addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
  ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getMbrAmounts(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getMbrAmounts()(uint64,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getProtocolConstraints(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the getNumValidators()uint64 ABI method
   *
   * Returns the current number of validators
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getNumValidators(
    params: CallParams<
      ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getNumValidators()uint64' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getValidatorConfig(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method:
        'getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getValidatorState(uint64)(uint16,uint64,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getValidatorState(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getValidatorState(uint64)(uint16,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getValidatorOwnerAndManager(uint64)(address,address) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getValidatorOwnerAndManager(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)']
      | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getValidatorOwnerAndManager(uint64)(address,address)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getPools(uint64)(uint64,uint16,uint64)[] ABI method
   *
   * Return list of all pools for this validator.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getPools(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]']
      | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getPools(uint64)(uint64,uint16,uint64)[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getPoolAppId(uint64,uint64)uint64 ABI method
   *
  * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
  want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
  (which contains reward tokens if being used) so that the amount available can be determined.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getPoolAppId(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64']
      | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getPoolAppId(uint64,uint64)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.poolId],
    }
  }
  /**
   * Constructs a no op call for the getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getPoolInfo(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
      | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.poolKey],
    }
  }
  /**
   * Constructs a no op call for the getCurMaxStakePerPool(uint64)uint64 ABI method
   *
  * Calculate the maximum stake per pool for a given validator.
  Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
  as pools are added the max allowed per pool can reduce.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getCurMaxStakePerPool(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64']
      | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getCurMaxStakePerPool(uint64)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the doesStakerNeedToPayMBR(address)bool ABI method
   *
   * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static doesStakerNeedToPayMBR(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool']
      | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'doesStakerNeedToPayMBR(address)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.staker],
    }
  }
  /**
   * Constructs a no op call for the getStakedPoolsForAccount(address)(uint64,uint64,uint64)[] ABI method
   *
   * Retrieves the staked pools for an account.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getStakedPoolsForAccount(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
      | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.staker],
    }
  }
  /**
   * Constructs a no op call for the getTokenPayoutRatio(uint64)(uint64[24],uint64) ABI method
   *
  * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
  payouts across pools can be based on a stable snaphost of stake.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getTokenPayoutRatio(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
      | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getTokenPayoutRatio(uint64)(uint64[24],uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getNodePoolAssignments(uint64)((uint64[3])[8]) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getNodePoolAssignments(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])']
      | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getNodePoolAssignments(uint64)((uint64[3])[8])' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getNFDRegistryID()uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getNFDRegistryID(
    params: CallParams<
      ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getNFDRegistryID()uint64' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64 ABI method
   *
  * Adds a new validator
  Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addValidator(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
      | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method:
        'addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.mbrPayment, params.args.nfdName, params.args.config],
    }
  }
  /**
   * Constructs a no op call for the changeValidatorManager(uint64,address)void ABI method
   *
  * Changes the Validator manager for a specific Validator id.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static changeValidatorManager(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void']
      | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'changeValidatorManager(uint64,address)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.manager],
    }
  }
  /**
   * Constructs a no op call for the changeValidatorSunsetInfo(uint64,uint64,uint64)void ABI method
   *
  * Updates the sunset information for a given validator.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static changeValidatorSunsetInfo(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
      | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'changeValidatorSunsetInfo(uint64,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.sunsettingOn, params.args.sunsettingTo],
    }
  }
  /**
   * Constructs a no op call for the changeValidatorNFD(uint64,uint64,string)void ABI method
   *
  * Changes the NFD for a validator in the validatorList contract.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static changeValidatorNFD(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void']
      | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'changeValidatorNFD(uint64,uint64,string)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.nfdAppID, params.args.nfdName],
    }
  }
  /**
   * Constructs a no op call for the changeValidatorCommissionAddress(uint64,address)void ABI method
   *
  * Change the commission address that validator rewards are sent to.
      [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static changeValidatorCommissionAddress(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void']
      | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'changeValidatorCommissionAddress(uint64,address)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.commissionAddress],
    }
  }
  /**
   * Constructs a no op call for the changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void ABI method
   *
  * Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static changeValidatorRewardInfo(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
      | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void' as const,
      args: Array.isArray(params.args)
        ? params.args
        : [
            params.args.validatorId,
            params.args.EntryGatingType,
            params.args.EntryGatingAddress,
            params.args.EntryGatingAssets,
            params.args.GatingAssetMinBalance,
            params.args.RewardPerPayout,
          ],
    }
  }
  /**
   * Constructs a no op call for the addPool(pay,uint64,uint64)(uint64,uint64,uint64) ABI method
   *
  * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
  The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
  
  
  [ ONLY OWNER OR MANAGER CAN call ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addPool(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addPool(pay,uint64,uint64)(uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.mbrPayment, params.args.validatorId, params.args.nodeNum],
    }
  }
  /**
   * Constructs a no op call for the addStake(pay,uint64,uint64)(uint64,uint64,uint64) ABI method
   *
   * Adds stake to a validator pool.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addStake(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addStake(pay,uint64,uint64)(uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args)
        ? params.args
        : [params.args.stakedAmountPayment, params.args.validatorId, params.args.valueToVerify],
    }
  }
  /**
   * Constructs a no op call for the setTokenPayoutRatio(uint64)(uint64[24],uint64) ABI method
   *
  * setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
  of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
  in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
  pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
  It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
  their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
  during the epoch updates across pools)
  
  
  Multiple pools will call us via pool 1 (pool2-pool1-validator, etc.) so don't assert on pool1 calling multiple
  times in same epoch.  Just return.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setTokenPayoutRatio(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
      | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'setTokenPayoutRatio(uint64)(uint64[24],uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void ABI method
   *
  * stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
  stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
  The calling App id is validated against our pool list as well.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static stakeUpdatedViaRewards(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
      | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void' as const,
      args: Array.isArray(params.args)
        ? params.args
        : [
            params.args.poolKey,
            params.args.algoToAdd,
            params.args.rewardTokenAmountReserved,
            params.args.validatorCommission,
            params.args.saturatedBurnToFeeSink,
          ],
    }
  }
  /**
   * Constructs a no op call for the stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void ABI method
   *
  * stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
  from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
  If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
  The calling App id is validated against our pool list as well.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static stakeRemoved(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
      | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void' as const,
      args: Array.isArray(params.args)
        ? params.args
        : [params.args.poolKey, params.args.staker, params.args.amountRemoved, params.args.rewardRemoved, params.args.stakerRemoved],
    }
  }
  /**
   * Constructs a no op call for the findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool) ABI method
   *
  * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
  First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
  to new pool if necessary.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static findPoolForStaker(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
      | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.staker, params.args.amountToStake],
    }
  }
  /**
   * Constructs a no op call for the movePoolToNode(uint64,uint64,uint64)void ABI method
   *
  * Find the specified pool (in any node number) and move it to the specified node.
  The pool account is forced offline if moved so prior node will still run for 320 rounds but
  new key goes online on new node soon after (320 rounds after it goes online)
  No-op if success, asserts if not found or can't move  (no space in target)
  [ ONLY OWNER OR MANAGER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static movePoolToNode(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void']
      | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'movePoolToNode(uint64,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.poolAppId, params.args.nodeNum],
    }
  }
  /**
   * Constructs a no op call for the emptyTokenRewards(uint64,address)uint64 ABI method
   *
  * Sends the reward tokens held in pool 1 to specified receiver.
  This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
  the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
  NOT be sent as they must be held back for stakers to later claim.
  [ ONLY OWNER CAN CALL]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static emptyTokenRewards(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64']
      | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']
    > &
      CallOnComplete,
  ): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'emptyTokenRewards(uint64,address)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.receiver],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the ValidatorRegistry smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class ValidatorRegistryFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `ValidatorRegistryFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }

  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }

  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }

  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }

  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new ValidatorRegistryClient(this.appFactory.getAppClientById(params))
  }

  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams) {
    return new ValidatorRegistryClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the ValidatorRegistry smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: ValidatorRegistryDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
      createParams: params.createParams?.method
        ? ValidatorRegistryParamsFactory.create._resolveByMethod(params.createParams)
        : params.createParams
          ? (params.createParams as ValidatorRegistryCreateCallParams & { args: Uint8Array[] })
          : undefined,
    })
    return { result: result.result, appClient: new ValidatorRegistryClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ValidatorRegistry smart contract using the createApplication()void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      createApplication: (
        params: CallParams<
          ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']
        > &
          AppClientCompilationParams &
          CreateSchema & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
      ) => {
        return this.appFactory.params.create(ValidatorRegistryParamsFactory.create.createApplication(params))
      },
    },
  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ValidatorRegistry smart contract using the createApplication()void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      createApplication: (
        params: CallParams<
          ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']
        > &
          AppClientCompilationParams &
          CreateSchema & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
      ) => {
        return this.appFactory.createTransaction.create(ValidatorRegistryParamsFactory.create.createApplication(params))
      },
    },
  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ValidatorRegistry smart contract using an ABI method call using the createApplication()void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      createApplication: async (
        params: CallParams<
          ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']
        > &
          AppClientCompilationParams &
          CreateSchema &
          SendParams & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
      ) => {
        const result = await this.appFactory.send.create(ValidatorRegistryParamsFactory.create.createApplication(params))
        return {
          result: {
            ...result.result,
            return: result.result.return as unknown as undefined | ValidatorRegistryReturns['createApplication()void'],
          },
          appClient: new ValidatorRegistryClient(result.appClient),
        }
      },
    },
  }
}
/**
 * A client to make calls to the ValidatorRegistry smart contract
 */
export class ValidatorRegistryClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `ValidatorRegistryClient`
   *
   * @param appClient An `AppClient` instance which has been created with the ValidatorRegistry app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `ValidatorRegistryClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient =
      appClientOrParams instanceof _AppClient
        ? appClientOrParams
        : new _AppClient({
            ...appClientOrParams,
            appSpec: APP_SPEC,
          })
  }

  /**
   * Returns a new `ValidatorRegistryClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<ValidatorRegistryClient> {
    return new ValidatorRegistryClient(await _AppClient.fromCreatorAndName({ ...params, appSpec: APP_SPEC }))
  }

  /**
   * Returns an `ValidatorRegistryClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params: Omit<ResolveAppClientByNetwork, 'appSpec'>): Promise<ValidatorRegistryClient> {
    return new ValidatorRegistryClient(await _AppClient.fromNetwork({ ...params, appSpec: APP_SPEC }))
  }

  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }

  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }

  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }

  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }

  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Makes a clear_state call to an existing instance of the ValidatorRegistry smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `initStakingContract(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initStakingContract: (
      params: CallParams<
        ValidatorRegistryArgs['obj']['initStakingContract(uint64)void'] | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.initStakingContract(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `loadStakingContractData(uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    loadStakingContractData: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void']
        | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.loadStakingContractData(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `finalizeStakingContract()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    finalizeStakingContract: (
      params: CallParams<
        ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']
      > & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.finalizeStakingContract(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `gas()void` ABI method.
     *
     * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    gas: (
      params: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']> & {
        onComplete?: OnApplicationComplete.NoOp
      } = { args: [] },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.gas(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getMbrAmounts()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the MBR amounts needed for various actions:
    [
    addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
    addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
    poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
    addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
    ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getMbrAmounts: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getMbrAmounts(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getProtocolConstraints: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getProtocolConstraints(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNumValidators()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current number of validators
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getNumValidators: (
      params: CallParams<
        ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']
      > & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getNumValidators(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getValidatorConfig: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getValidatorConfig(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorState(uint64)(uint16,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getValidatorState: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getValidatorState(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorOwnerAndManager(uint64)(address,address)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getValidatorOwnerAndManager: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)']
        | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getValidatorOwnerAndManager(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPools(uint64)(uint64,uint16,uint64)[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Return list of all pools for this validator.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getPools: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]']
        | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getPools(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolAppId(uint64,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
    want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
    (which contains reward tokens if being used) so that the amount available can be determined.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getPoolAppId: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64']
        | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getPoolAppId(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getPoolInfo: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
        | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getPoolInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getCurMaxStakePerPool(uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Calculate the maximum stake per pool for a given validator.
    Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
    as pools are added the max allowed per pool can reduce.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getCurMaxStakePerPool: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64']
        | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getCurMaxStakePerPool(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `doesStakerNeedToPayMBR(address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    doesStakerNeedToPayMBR: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool']
        | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.doesStakerNeedToPayMBR(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Retrieves the staked pools for an account.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getStakedPoolsForAccount: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
        | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getStakedPoolsForAccount(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
    payouts across pools can be based on a stable snaphost of stake.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getTokenPayoutRatio: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
        | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getTokenPayoutRatio(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNodePoolAssignments(uint64)((uint64[3])[8])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getNodePoolAssignments: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])']
        | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getNodePoolAssignments(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNFDRegistryID()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getNFDRegistryID: (
      params: CallParams<
        ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']
      > & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getNFDRegistryID(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64` ABI method.
     *
    * Adds a new validator
    Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.

     *
     * @param params The params for the smart contract call
     * @returns The call params: uint64 validator id
     */
    addValidator: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
        | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.addValidator(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorManager(uint64,address)void` ABI method.
     *
    * Changes the Validator manager for a specific Validator id.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    changeValidatorManager: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.changeValidatorManager(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorSunsetInfo(uint64,uint64,uint64)void` ABI method.
     *
    * Updates the sunset information for a given validator.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    changeValidatorSunsetInfo: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.changeValidatorSunsetInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorNFD(uint64,uint64,string)void` ABI method.
     *
    * Changes the NFD for a validator in the validatorList contract.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    changeValidatorNFD: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.changeValidatorNFD(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorCommissionAddress(uint64,address)void` ABI method.
     *
    * Change the commission address that validator rewards are sent to.
        [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    changeValidatorCommissionAddress: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.changeValidatorCommissionAddress(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void` ABI method.
     *
    * Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    changeValidatorRewardInfo: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.changeValidatorRewardInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addPool(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
    * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
    The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
    
    
    [ ONLY OWNER OR MANAGER CAN call ]

     *
     * @param params The params for the smart contract call
     * @returns The call params: ValidatorPoolKey pool key to created pool
     */
    addPool: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.addPool(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addStake(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
     * Adds stake to a validator pool.
     *
     * @param params The params for the smart contract call
     * @returns The call params: ValidatorPoolKey - The key of the validator pool.
     */
    addStake: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.addStake(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `setTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     *
    * setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
    of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
    in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
    pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
    It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
    their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
    during the epoch updates across pools)
    
    
    Multiple pools will call us via pool 1 (pool2-pool1-validator, etc.) so don't assert on pool1 calling multiple
    times in same epoch.  Just return.

     *
     * @param params The params for the smart contract call
     * @returns The call params: PoolTokenPayoutRatio - the finished ratio data
     */
    setTokenPayoutRatio: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
        | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.setTokenPayoutRatio(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void` ABI method.
     *
    * stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
    stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    stakeUpdatedViaRewards: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.stakeUpdatedViaRewards(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void` ABI method.
     *
    * stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
    from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    stakeRemoved: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
        | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.stakeRemoved(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
    First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
    to new pool if necessary.

     *
     * @param params The params for the smart contract call
    * @returns The call params: ValidatorPoolKey, boolean, boolean - The pool for the staker, true/false on whether the staker is 'new'
    to this VALIDATOR, and true/false if staker is new to the protocol.

     */
    findPoolForStaker: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
        | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.findPoolForStaker(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `movePoolToNode(uint64,uint64,uint64)void` ABI method.
     *
    * Find the specified pool (in any node number) and move it to the specified node.
    The pool account is forced offline if moved so prior node will still run for 320 rounds but
    new key goes online on new node soon after (320 rounds after it goes online)
    No-op if success, asserts if not found or can't move  (no space in target)
    [ ONLY OWNER OR MANAGER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    movePoolToNode: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.movePoolToNode(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `emptyTokenRewards(uint64,address)uint64` ABI method.
     *
    * Sends the reward tokens held in pool 1 to specified receiver.
    This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
    the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
    NOT be sent as they must be held back for stakers to later claim.
    [ ONLY OWNER CAN CALL]

     *
     * @param params The params for the smart contract call
     * @returns The call params: uint64 the amount of reward token sent
     */
    emptyTokenRewards: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64']
        | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.emptyTokenRewards(params))
    },
  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the ValidatorRegistry smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `initStakingContract(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initStakingContract: (
      params: CallParams<
        ValidatorRegistryArgs['obj']['initStakingContract(uint64)void'] | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.initStakingContract(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `loadStakingContractData(uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    loadStakingContractData: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void']
        | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.loadStakingContractData(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `finalizeStakingContract()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    finalizeStakingContract: (
      params: CallParams<
        ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']
      > & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.finalizeStakingContract(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `gas()void` ABI method.
     *
     * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    gas: (
      params: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']> & {
        onComplete?: OnApplicationComplete.NoOp
      } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.gas(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getMbrAmounts()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the MBR amounts needed for various actions:
    [
    addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
    addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
    poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
    addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
    ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getMbrAmounts: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getMbrAmounts(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getProtocolConstraints: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getProtocolConstraints(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNumValidators()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current number of validators
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getNumValidators: (
      params: CallParams<
        ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']
      > & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getNumValidators(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getValidatorConfig: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getValidatorConfig(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorState(uint64)(uint16,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getValidatorState: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getValidatorState(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorOwnerAndManager(uint64)(address,address)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getValidatorOwnerAndManager: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)']
        | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getValidatorOwnerAndManager(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPools(uint64)(uint64,uint16,uint64)[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Return list of all pools for this validator.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getPools: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]']
        | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getPools(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolAppId(uint64,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
    want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
    (which contains reward tokens if being used) so that the amount available can be determined.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getPoolAppId: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64']
        | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getPoolAppId(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getPoolInfo: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
        | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getPoolInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getCurMaxStakePerPool(uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Calculate the maximum stake per pool for a given validator.
    Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
    as pools are added the max allowed per pool can reduce.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getCurMaxStakePerPool: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64']
        | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getCurMaxStakePerPool(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `doesStakerNeedToPayMBR(address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    doesStakerNeedToPayMBR: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool']
        | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.doesStakerNeedToPayMBR(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Retrieves the staked pools for an account.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getStakedPoolsForAccount: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
        | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getStakedPoolsForAccount(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
    payouts across pools can be based on a stable snaphost of stake.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getTokenPayoutRatio: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
        | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getTokenPayoutRatio(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNodePoolAssignments(uint64)((uint64[3])[8])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getNodePoolAssignments: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])']
        | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getNodePoolAssignments(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNFDRegistryID()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getNFDRegistryID: (
      params: CallParams<
        ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']
      > & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getNFDRegistryID(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64` ABI method.
     *
    * Adds a new validator
    Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: uint64 validator id
     */
    addValidator: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
        | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.addValidator(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorManager(uint64,address)void` ABI method.
     *
    * Changes the Validator manager for a specific Validator id.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    changeValidatorManager: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.changeValidatorManager(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorSunsetInfo(uint64,uint64,uint64)void` ABI method.
     *
    * Updates the sunset information for a given validator.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    changeValidatorSunsetInfo: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.changeValidatorSunsetInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorNFD(uint64,uint64,string)void` ABI method.
     *
    * Changes the NFD for a validator in the validatorList contract.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    changeValidatorNFD: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.changeValidatorNFD(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorCommissionAddress(uint64,address)void` ABI method.
     *
    * Change the commission address that validator rewards are sent to.
        [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    changeValidatorCommissionAddress: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.changeValidatorCommissionAddress(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void` ABI method.
     *
    * Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    changeValidatorRewardInfo: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.changeValidatorRewardInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addPool(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
    * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
    The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
    
    
    [ ONLY OWNER OR MANAGER CAN call ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: ValidatorPoolKey pool key to created pool
     */
    addPool: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.addPool(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addStake(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
     * Adds stake to a validator pool.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: ValidatorPoolKey - The key of the validator pool.
     */
    addStake: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.addStake(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `setTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     *
    * setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
    of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
    in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
    pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
    It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
    their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
    during the epoch updates across pools)
    
    
    Multiple pools will call us via pool 1 (pool2-pool1-validator, etc.) so don't assert on pool1 calling multiple
    times in same epoch.  Just return.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: PoolTokenPayoutRatio - the finished ratio data
     */
    setTokenPayoutRatio: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
        | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.setTokenPayoutRatio(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void` ABI method.
     *
    * stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
    stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    stakeUpdatedViaRewards: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.stakeUpdatedViaRewards(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void` ABI method.
     *
    * stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
    from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    stakeRemoved: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
        | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.stakeRemoved(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
    First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
    to new pool if necessary.

     *
     * @param params The params for the smart contract call
    * @returns The call transaction: ValidatorPoolKey, boolean, boolean - The pool for the staker, true/false on whether the staker is 'new'
    to this VALIDATOR, and true/false if staker is new to the protocol.

     */
    findPoolForStaker: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
        | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.findPoolForStaker(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `movePoolToNode(uint64,uint64,uint64)void` ABI method.
     *
    * Find the specified pool (in any node number) and move it to the specified node.
    The pool account is forced offline if moved so prior node will still run for 320 rounds but
    new key goes online on new node soon after (320 rounds after it goes online)
    No-op if success, asserts if not found or can't move  (no space in target)
    [ ONLY OWNER OR MANAGER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    movePoolToNode: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.movePoolToNode(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `emptyTokenRewards(uint64,address)uint64` ABI method.
     *
    * Sends the reward tokens held in pool 1 to specified receiver.
    This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
    the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
    NOT be sent as they must be held back for stakers to later claim.
    [ ONLY OWNER CAN CALL]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: uint64 the amount of reward token sent
     */
    emptyTokenRewards: (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64']
        | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']
      > & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.emptyTokenRewards(params))
    },
  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Makes a clear_state call to an existing instance of the ValidatorRegistry smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `initStakingContract(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initStakingContract: async (
      params: CallParams<
        ValidatorRegistryArgs['obj']['initStakingContract(uint64)void'] | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.initStakingContract(params))
      return { ...result, return: result.return as unknown as undefined | ValidatorRegistryReturns['initStakingContract(uint64)void'] }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `loadStakingContractData(uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    loadStakingContractData: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void']
        | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.loadStakingContractData(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['loadStakingContractData(uint64,byte[])void'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `finalizeStakingContract()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    finalizeStakingContract: async (
      params: CallParams<
        ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.finalizeStakingContract(params))
      return { ...result, return: result.return as unknown as undefined | ValidatorRegistryReturns['finalizeStakingContract()void'] }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `gas()void` ABI method.
     *
     * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    gas: async (
      params: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']> &
        SendParams & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.gas(params))
      return { ...result, return: result.return as unknown as undefined | ValidatorRegistryReturns['gas()void'] }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getMbrAmounts()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the MBR amounts needed for various actions:
    [
    addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
    addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
    poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
    addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
    ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getMbrAmounts: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getMbrAmounts(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['getMbrAmounts()(uint64,uint64,uint64,uint64)'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getProtocolConstraints: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getProtocolConstraints(params))
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | ValidatorRegistryReturns['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNumValidators()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current number of validators
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getNumValidators: async (
      params: CallParams<
        ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNumValidators(params))
      return { ...result, return: result.return as unknown as undefined | ValidatorRegistryReturns['getNumValidators()uint64'] }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getValidatorConfig: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorConfig(params))
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | ValidatorRegistryReturns['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorState(uint64)(uint16,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getValidatorState: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorState(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['getValidatorState(uint64)(uint16,uint64,uint64,uint64)'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorOwnerAndManager(uint64)(address,address)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getValidatorOwnerAndManager: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)']
        | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorOwnerAndManager(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['getValidatorOwnerAndManager(uint64)(address,address)'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPools(uint64)(uint64,uint16,uint64)[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Return list of all pools for this validator.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getPools: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]']
        | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPools(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['getPools(uint64)(uint64,uint16,uint64)[]'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolAppId(uint64,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
    want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
    (which contains reward tokens if being used) so that the amount available can be determined.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getPoolAppId: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64']
        | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPoolAppId(params))
      return { ...result, return: result.return as unknown as undefined | ValidatorRegistryReturns['getPoolAppId(uint64,uint64)uint64'] }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getPoolInfo: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
        | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPoolInfo(params))
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | ValidatorRegistryReturns['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getCurMaxStakePerPool(uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Calculate the maximum stake per pool for a given validator.
    Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
    as pools are added the max allowed per pool can reduce.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getCurMaxStakePerPool: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64']
        | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getCurMaxStakePerPool(params))
      return { ...result, return: result.return as unknown as undefined | ValidatorRegistryReturns['getCurMaxStakePerPool(uint64)uint64'] }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `doesStakerNeedToPayMBR(address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    doesStakerNeedToPayMBR: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool']
        | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.doesStakerNeedToPayMBR(params))
      return { ...result, return: result.return as unknown as undefined | ValidatorRegistryReturns['doesStakerNeedToPayMBR(address)bool'] }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Retrieves the staked pools for an account.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getStakedPoolsForAccount: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
        | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getStakedPoolsForAccount(params))
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | ValidatorRegistryReturns['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
    payouts across pools can be based on a stable snaphost of stake.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getTokenPayoutRatio: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
        | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getTokenPayoutRatio(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['getTokenPayoutRatio(uint64)(uint64[24],uint64)'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNodePoolAssignments(uint64)((uint64[3])[8])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getNodePoolAssignments: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])']
        | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNodePoolAssignments(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['getNodePoolAssignments(uint64)((uint64[3])[8])'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNFDRegistryID()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getNFDRegistryID: async (
      params: CallParams<
        ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp } = { args: [] },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNFDRegistryID(params))
      return { ...result, return: result.return as unknown as undefined | ValidatorRegistryReturns['getNFDRegistryID()uint64'] }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64` ABI method.
     *
    * Adds a new validator
    Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.

     *
     * @param params The params for the smart contract call
     * @returns The call result: uint64 validator id
     */
    addValidator: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
        | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.addValidator(params))
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | ValidatorRegistryReturns['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorManager(uint64,address)void` ABI method.
     *
    * Changes the Validator manager for a specific Validator id.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    changeValidatorManager: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.changeValidatorManager(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['changeValidatorManager(uint64,address)void'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorSunsetInfo(uint64,uint64,uint64)void` ABI method.
     *
    * Updates the sunset information for a given validator.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    changeValidatorSunsetInfo: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.changeValidatorSunsetInfo(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['changeValidatorSunsetInfo(uint64,uint64,uint64)void'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorNFD(uint64,uint64,string)void` ABI method.
     *
    * Changes the NFD for a validator in the validatorList contract.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    changeValidatorNFD: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.changeValidatorNFD(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['changeValidatorNFD(uint64,uint64,string)void'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorCommissionAddress(uint64,address)void` ABI method.
     *
    * Change the commission address that validator rewards are sent to.
        [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    changeValidatorCommissionAddress: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.changeValidatorCommissionAddress(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['changeValidatorCommissionAddress(uint64,address)void'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void` ABI method.
     *
    * Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    changeValidatorRewardInfo: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.changeValidatorRewardInfo(params))
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | ValidatorRegistryReturns['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addPool(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
    * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
    The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
    
    
    [ ONLY OWNER OR MANAGER CAN call ]

     *
     * @param params The params for the smart contract call
     * @returns The call result: ValidatorPoolKey pool key to created pool
     */
    addPool: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.addPool(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['addPool(pay,uint64,uint64)(uint64,uint64,uint64)'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addStake(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
     * Adds stake to a validator pool.
     *
     * @param params The params for the smart contract call
     * @returns The call result: ValidatorPoolKey - The key of the validator pool.
     */
    addStake: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
        | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.addStake(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['addStake(pay,uint64,uint64)(uint64,uint64,uint64)'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `setTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     *
    * setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
    of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
    in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
    pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
    It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
    their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
    during the epoch updates across pools)
    
    
    Multiple pools will call us via pool 1 (pool2-pool1-validator, etc.) so don't assert on pool1 calling multiple
    times in same epoch.  Just return.

     *
     * @param params The params for the smart contract call
     * @returns The call result: PoolTokenPayoutRatio - the finished ratio data
     */
    setTokenPayoutRatio: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
        | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.setTokenPayoutRatio(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['setTokenPayoutRatio(uint64)(uint64[24],uint64)'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void` ABI method.
     *
    * stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
    stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stakeUpdatedViaRewards: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.stakeUpdatedViaRewards(params))
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | ValidatorRegistryReturns['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void` ABI method.
     *
    * stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
    from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stakeRemoved: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
        | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.stakeRemoved(params))
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | ValidatorRegistryReturns['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
    First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
    to new pool if necessary.

     *
     * @param params The params for the smart contract call
    * @returns The call result: ValidatorPoolKey, boolean, boolean - The pool for the staker, true/false on whether the staker is 'new'
    to this VALIDATOR, and true/false if staker is new to the protocol.

     */
    findPoolForStaker: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
        | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.findPoolForStaker(params))
      return {
        ...result,
        return: result.return as unknown as
          | undefined
          | ValidatorRegistryReturns['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `movePoolToNode(uint64,uint64,uint64)void` ABI method.
     *
    * Find the specified pool (in any node number) and move it to the specified node.
    The pool account is forced offline if moved so prior node will still run for 320 rounds but
    new key goes online on new node soon after (320 rounds after it goes online)
    No-op if success, asserts if not found or can't move  (no space in target)
    [ ONLY OWNER OR MANAGER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    movePoolToNode: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void']
        | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.movePoolToNode(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['movePoolToNode(uint64,uint64,uint64)void'],
      }
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `emptyTokenRewards(uint64,address)uint64` ABI method.
     *
    * Sends the reward tokens held in pool 1 to specified receiver.
    This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
    the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
    NOT be sent as they must be held back for stakers to later claim.
    [ ONLY OWNER CAN CALL]

     *
     * @param params The params for the smart contract call
     * @returns The call result: uint64 the amount of reward token sent
     */
    emptyTokenRewards: async (
      params: CallParams<
        | ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64']
        | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']
      > &
        SendParams & { onComplete?: OnApplicationComplete.NoOp },
    ) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.emptyTokenRewards(params))
      return {
        ...result,
        return: result.return as unknown as undefined | ValidatorRegistryReturns['emptyTokenRewards(uint64,address)uint64'],
      }
    },
  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new ValidatorRegistryClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getMbrAmounts()(uint64,uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Returns the MBR amounts needed for various actions:
  [
  addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
  addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
  poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
  addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
  ]

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getMbrAmounts(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getMbrAmounts(params))
    return result.return as unknown as ValidatorRegistryReturns['getMbrAmounts()(uint64,uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getProtocolConstraints(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getProtocolConstraints(params))
    return result.return as unknown as ValidatorRegistryReturns['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getNumValidators()uint64` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the current number of validators
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getNumValidators(
    params: CallParams<
      ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNumValidators(params))
    return result.return as unknown as ValidatorRegistryReturns['getNumValidators()uint64']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getValidatorConfig(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorConfig(params))
    return result.return as unknown as ValidatorRegistryReturns['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getValidatorState(uint64)(uint16,uint64,uint64,uint64)` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getValidatorState(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorState(params))
    return result.return as unknown as ValidatorRegistryReturns['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getValidatorOwnerAndManager(uint64)(address,address)` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getValidatorOwnerAndManager(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)']
      | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorOwnerAndManager(params))
    return result.return as unknown as ValidatorRegistryReturns['getValidatorOwnerAndManager(uint64)(address,address)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getPools(uint64)(uint64,uint16,uint64)[]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Return list of all pools for this validator.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getPools(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]']
      | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPools(params))
    return result.return as unknown as ValidatorRegistryReturns['getPools(uint64)(uint64,uint16,uint64)[]']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getPoolAppId(uint64,uint64)uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
  want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
  (which contains reward tokens if being used) so that the amount available can be determined.

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getPoolAppId(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64']
      | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPoolAppId(params))
    return result.return as unknown as ValidatorRegistryReturns['getPoolAppId(uint64,uint64)uint64']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getPoolInfo(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
      | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPoolInfo(params))
    return result.return as unknown as ValidatorRegistryReturns['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getCurMaxStakePerPool(uint64)uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Calculate the maximum stake per pool for a given validator.
  Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
  as pools are added the max allowed per pool can reduce.

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getCurMaxStakePerPool(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64']
      | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getCurMaxStakePerPool(params))
    return result.return as unknown as ValidatorRegistryReturns['getCurMaxStakePerPool(uint64)uint64']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `doesStakerNeedToPayMBR(address)bool` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async doesStakerNeedToPayMBR(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool']
      | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.doesStakerNeedToPayMBR(params))
    return result.return as unknown as ValidatorRegistryReturns['doesStakerNeedToPayMBR(address)bool']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Retrieves the staked pools for an account.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getStakedPoolsForAccount(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
      | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getStakedPoolsForAccount(params))
    return result.return as unknown as ValidatorRegistryReturns['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
  payouts across pools can be based on a stable snaphost of stake.

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getTokenPayoutRatio(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
      | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getTokenPayoutRatio(params))
    return result.return as unknown as ValidatorRegistryReturns['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getNodePoolAssignments(uint64)((uint64[3])[8])` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getNodePoolAssignments(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])']
      | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNodePoolAssignments(params))
    return result.return as unknown as ValidatorRegistryReturns['getNodePoolAssignments(uint64)((uint64[3])[8])']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getNFDRegistryID()uint64` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getNFDRegistryID(
    params: CallParams<
      ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']
    > = { args: [] },
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNFDRegistryID(params))
    return result.return as unknown as ValidatorRegistryReturns['getNFDRegistryID()uint64']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
  First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
  to new pool if necessary.

   *
   * @param params The params for the smart contract call
  * @returns The call result: ValidatorPoolKey, boolean, boolean - The pool for the staker, true/false on whether the staker is 'new'
  to this VALIDATOR, and true/false if staker is new to the protocol.

   */
  async findPoolForStaker(
    params: CallParams<
      | ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
      | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
    >,
  ) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.findPoolForStaker(params))
    return result.return as unknown as ValidatorRegistryReturns['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
  }

  /**
   * Methods to access state for the current ValidatorRegistry app
   */
  state = {
    /**
     * Methods to access global state for the current ValidatorRegistry app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
          stakingPoolInitialized: result.stakingPoolInitialized,
          numValidators: result.numValidators,
          numStakers: result.numStakers,
          totalAlgoStaked: result.totalAlgoStaked,
        }
      },
      /**
       * Get the current value of the stakingPoolInitialized key in global state
       */
      stakingPoolInitialized: async (): Promise<boolean | undefined> => {
        return (await this.appClient.state.global.getValue('stakingPoolInitialized')) as boolean | undefined
      },
      /**
       * Get the current value of the numValidators key in global state
       */
      numValidators: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue('numValidators')) as bigint | undefined
      },
      /**
       * Get the current value of the numStakers key in global state
       */
      numStakers: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue('numStakers')) as bigint | undefined
      },
      /**
       * Get the current value of the totalAlgoStaked key in global state
       */
      totalAlgoStaked: async (): Promise<bigint | undefined> => {
        return (await this.appClient.state.global.getValue('totalAlgoStaked')) as bigint | undefined
      },
    },
    /**
     * Methods to access box state for the current ValidatorRegistry app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
          stakingPoolApprovalProgram: new BinaryStateValue(result.stakingPoolApprovalProgram),
        }
      },
      /**
       * Get the current value of the stakingPoolApprovalProgram key in box state
       */
      stakingPoolApprovalProgram: async (): Promise<BinaryState> => {
        return new BinaryStateValue((await this.appClient.state.box.getValue('stakingPoolApprovalProgram')) as Uint8Array | undefined)
      },
      /**
       * Get values from the validatorList map in box state
       */
      validatorList: {
        /**
         * Get all current values of the validatorList map in box state
         */
        getMap: async (): Promise<Map<bigint, ValidatorInfo>> => {
          return (await this.appClient.state.box.getMap('validatorList')) as Map<bigint, ValidatorInfo>
        },
        /**
         * Get a current value of the validatorList map by key from box state
         */
        value: async (key: bigint | number): Promise<ValidatorInfo | undefined> => {
          return (await this.appClient.state.box.getMapValue('validatorList', key)) as ValidatorInfo | undefined
        },
      },
      /**
       * Get values from the stakerPoolSet map in box state
       */
      stakerPoolSet: {
        /**
         * Get all current values of the stakerPoolSet map in box state
         */
        getMap: async (): Promise<
          Map<
            string,
            [
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
            ]
          >
        > => {
          return (await this.appClient.state.box.getMap('stakerPoolSet')) as Map<
            string,
            [
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
            ]
          >
        },
        /**
         * Get a current value of the stakerPoolSet map by key from box state
         */
        value: async (
          key: string,
        ): Promise<
          | [
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
              [bigint, bigint, bigint],
            ]
          | undefined
        > => {
          return (await this.appClient.state.box.getMapValue('stakerPoolSet', key)) as
            | [
                [bigint, bigint, bigint],
                [bigint, bigint, bigint],
                [bigint, bigint, bigint],
                [bigint, bigint, bigint],
                [bigint, bigint, bigint],
                [bigint, bigint, bigint],
              ]
            | undefined
        },
      },
    },
  }

  public newGroup(composerConfig?: TransactionComposerConfig): ValidatorRegistryComposer {
    const client = this
    const composer = this.algorand.newGroup(composerConfig)
    let promiseChain: Promise<unknown> = Promise.resolve()
    return {
      /**
       * Add a initStakingContract(uint64)void method call against the ValidatorRegistry contract
       */
      initStakingContract(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['initStakingContract(uint64)void']
          | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.initStakingContract(params)))
        return this
      },
      /**
       * Add a loadStakingContractData(uint64,byte[])void method call against the ValidatorRegistry contract
       */
      loadStakingContractData(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void']
          | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.loadStakingContractData(params)))
        return this
      },
      /**
       * Add a finalizeStakingContract()void method call against the ValidatorRegistry contract
       */
      finalizeStakingContract(
        params: CallParams<
          ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalizeStakingContract(params)))
        return this
      },
      /**
       * Add a gas()void method call against the ValidatorRegistry contract
       */
      gas(
        params: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']> & {
          onComplete?: OnApplicationComplete.NoOp
        },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.gas(params)))
        return this
      },
      /**
       * Add a getMbrAmounts()(uint64,uint64,uint64,uint64) method call against the ValidatorRegistry contract
       */
      getMbrAmounts(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
          | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getMbrAmounts(params)))
        return this
      },
      /**
       * Add a getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) method call against the ValidatorRegistry contract
       */
      getProtocolConstraints(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
          | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getProtocolConstraints(params)))
        return this
      },
      /**
       * Add a getNumValidators()uint64 method call against the ValidatorRegistry contract
       */
      getNumValidators(
        params: CallParams<
          ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getNumValidators(params)))
        return this
      },
      /**
       * Add a getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64) method call against the ValidatorRegistry contract
       */
      getValidatorConfig(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
          | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getValidatorConfig(params)))
        return this
      },
      /**
       * Add a getValidatorState(uint64)(uint16,uint64,uint64,uint64) method call against the ValidatorRegistry contract
       */
      getValidatorState(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
          | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getValidatorState(params)))
        return this
      },
      /**
       * Add a getValidatorOwnerAndManager(uint64)(address,address) method call against the ValidatorRegistry contract
       */
      getValidatorOwnerAndManager(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)']
          | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getValidatorOwnerAndManager(params)))
        return this
      },
      /**
       * Add a getPools(uint64)(uint64,uint16,uint64)[] method call against the ValidatorRegistry contract
       */
      getPools(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]']
          | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getPools(params)))
        return this
      },
      /**
       * Add a getPoolAppId(uint64,uint64)uint64 method call against the ValidatorRegistry contract
       */
      getPoolAppId(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64']
          | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getPoolAppId(params)))
        return this
      },
      /**
       * Add a getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64) method call against the ValidatorRegistry contract
       */
      getPoolInfo(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
          | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getPoolInfo(params)))
        return this
      },
      /**
       * Add a getCurMaxStakePerPool(uint64)uint64 method call against the ValidatorRegistry contract
       */
      getCurMaxStakePerPool(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64']
          | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getCurMaxStakePerPool(params)))
        return this
      },
      /**
       * Add a doesStakerNeedToPayMBR(address)bool method call against the ValidatorRegistry contract
       */
      doesStakerNeedToPayMBR(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool']
          | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.doesStakerNeedToPayMBR(params)))
        return this
      },
      /**
       * Add a getStakedPoolsForAccount(address)(uint64,uint64,uint64)[] method call against the ValidatorRegistry contract
       */
      getStakedPoolsForAccount(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
          | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getStakedPoolsForAccount(params)))
        return this
      },
      /**
       * Add a getTokenPayoutRatio(uint64)(uint64[24],uint64) method call against the ValidatorRegistry contract
       */
      getTokenPayoutRatio(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
          | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getTokenPayoutRatio(params)))
        return this
      },
      /**
       * Add a getNodePoolAssignments(uint64)((uint64[3])[8]) method call against the ValidatorRegistry contract
       */
      getNodePoolAssignments(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])']
          | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getNodePoolAssignments(params)))
        return this
      },
      /**
       * Add a getNFDRegistryID()uint64 method call against the ValidatorRegistry contract
       */
      getNFDRegistryID(
        params: CallParams<
          ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getNFDRegistryID(params)))
        return this
      },
      /**
       * Add a addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64 method call against the ValidatorRegistry contract
       */
      addValidator(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
          | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addValidator(params)))
        return this
      },
      /**
       * Add a changeValidatorManager(uint64,address)void method call against the ValidatorRegistry contract
       */
      changeValidatorManager(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void']
          | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.changeValidatorManager(params)))
        return this
      },
      /**
       * Add a changeValidatorSunsetInfo(uint64,uint64,uint64)void method call against the ValidatorRegistry contract
       */
      changeValidatorSunsetInfo(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
          | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.changeValidatorSunsetInfo(params)))
        return this
      },
      /**
       * Add a changeValidatorNFD(uint64,uint64,string)void method call against the ValidatorRegistry contract
       */
      changeValidatorNFD(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void']
          | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.changeValidatorNFD(params)))
        return this
      },
      /**
       * Add a changeValidatorCommissionAddress(uint64,address)void method call against the ValidatorRegistry contract
       */
      changeValidatorCommissionAddress(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void']
          | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () =>
          composer.addAppCallMethodCall(await client.params.changeValidatorCommissionAddress(params)),
        )
        return this
      },
      /**
       * Add a changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void method call against the ValidatorRegistry contract
       */
      changeValidatorRewardInfo(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
          | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.changeValidatorRewardInfo(params)))
        return this
      },
      /**
       * Add a addPool(pay,uint64,uint64)(uint64,uint64,uint64) method call against the ValidatorRegistry contract
       */
      addPool(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
          | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addPool(params)))
        return this
      },
      /**
       * Add a addStake(pay,uint64,uint64)(uint64,uint64,uint64) method call against the ValidatorRegistry contract
       */
      addStake(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
          | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addStake(params)))
        return this
      },
      /**
       * Add a setTokenPayoutRatio(uint64)(uint64[24],uint64) method call against the ValidatorRegistry contract
       */
      setTokenPayoutRatio(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
          | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setTokenPayoutRatio(params)))
        return this
      },
      /**
       * Add a stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void method call against the ValidatorRegistry contract
       */
      stakeUpdatedViaRewards(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
          | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.stakeUpdatedViaRewards(params)))
        return this
      },
      /**
       * Add a stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void method call against the ValidatorRegistry contract
       */
      stakeRemoved(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
          | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.stakeRemoved(params)))
        return this
      },
      /**
       * Add a findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool) method call against the ValidatorRegistry contract
       */
      findPoolForStaker(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
          | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.findPoolForStaker(params)))
        return this
      },
      /**
       * Add a movePoolToNode(uint64,uint64,uint64)void method call against the ValidatorRegistry contract
       */
      movePoolToNode(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void']
          | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.movePoolToNode(params)))
        return this
      },
      /**
       * Add a emptyTokenRewards(uint64,address)uint64 method call against the ValidatorRegistry contract
       */
      emptyTokenRewards(
        params: CallParams<
          | ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64']
          | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']
        > & { onComplete?: OnApplicationComplete.NoOp },
      ) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.emptyTokenRewards(params)))
        return this
      },
      /**
       * Add a clear state call to the ValidatorRegistry contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val) => val.returnValue),
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val) => val.returnValue),
        }
      },
    } as unknown as ValidatorRegistryComposer
  }
}
export type ValidatorRegistryComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the initStakingContract(uint64)void ABI method.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  initStakingContract(
    params?: CallParams<
      ValidatorRegistryArgs['obj']['initStakingContract(uint64)void'] | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['initStakingContract(uint64)void'] | undefined]>

  /**
   * Calls the loadStakingContractData(uint64,byte[])void ABI method.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  loadStakingContractData(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void']
      | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['loadStakingContractData(uint64,byte[])void'] | undefined]>

  /**
   * Calls the finalizeStakingContract()void ABI method.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  finalizeStakingContract(
    params?: CallParams<
      ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['finalizeStakingContract()void'] | undefined]>

  /**
   * Calls the gas()void ABI method.
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  gas(
    params?: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']>,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['gas()void'] | undefined]>

  /**
   * Calls the getMbrAmounts()(uint64,uint64,uint64,uint64) ABI method.
   *
  * Returns the MBR amounts needed for various actions:
  [
  addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
  addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
  poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
  addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
  ]

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getMbrAmounts(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getMbrAmounts()(uint64,uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getProtocolConstraints(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
    >,
  ): ValidatorRegistryComposer<
    [
      ...TReturns,
      (
        | ValidatorRegistryReturns['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
        | undefined
      ),
    ]
  >

  /**
   * Calls the getNumValidators()uint64 ABI method.
   *
   * Returns the current number of validators
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getNumValidators(
    params?: CallParams<
      ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getNumValidators()uint64'] | undefined]>

  /**
   * Calls the getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64) ABI method.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getValidatorConfig(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
    >,
  ): ValidatorRegistryComposer<
    [
      ...TReturns,
      (
        | ValidatorRegistryReturns['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
        | undefined
      ),
    ]
  >

  /**
   * Calls the getValidatorState(uint64)(uint16,uint64,uint64,uint64) ABI method.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getValidatorState(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
    >,
  ): ValidatorRegistryComposer<
    [...TReturns, ValidatorRegistryReturns['getValidatorState(uint64)(uint16,uint64,uint64,uint64)'] | undefined]
  >

  /**
   * Calls the getValidatorOwnerAndManager(uint64)(address,address) ABI method.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getValidatorOwnerAndManager(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)']
      | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getValidatorOwnerAndManager(uint64)(address,address)'] | undefined]>

  /**
   * Calls the getPools(uint64)(uint64,uint16,uint64)[] ABI method.
   *
   * Return list of all pools for this validator.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPools(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]']
      | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getPools(uint64)(uint64,uint16,uint64)[]'] | undefined]>

  /**
   * Calls the getPoolAppId(uint64,uint64)uint64 ABI method.
   *
  * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
  want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
  (which contains reward tokens if being used) so that the amount available can be determined.

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPoolAppId(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64']
      | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getPoolAppId(uint64,uint64)uint64'] | undefined]>

  /**
   * Calls the getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64) ABI method.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPoolInfo(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
      | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
    >,
  ): ValidatorRegistryComposer<
    [...TReturns, ValidatorRegistryReturns['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)'] | undefined]
  >

  /**
   * Calls the getCurMaxStakePerPool(uint64)uint64 ABI method.
   *
  * Calculate the maximum stake per pool for a given validator.
  Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
  as pools are added the max allowed per pool can reduce.

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getCurMaxStakePerPool(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64']
      | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getCurMaxStakePerPool(uint64)uint64'] | undefined]>

  /**
   * Calls the doesStakerNeedToPayMBR(address)bool ABI method.
   *
   * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  doesStakerNeedToPayMBR(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool']
      | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['doesStakerNeedToPayMBR(address)bool'] | undefined]>

  /**
   * Calls the getStakedPoolsForAccount(address)(uint64,uint64,uint64)[] ABI method.
   *
   * Retrieves the staked pools for an account.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getStakedPoolsForAccount(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
      | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
    >,
  ): ValidatorRegistryComposer<
    [...TReturns, ValidatorRegistryReturns['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]'] | undefined]
  >

  /**
   * Calls the getTokenPayoutRatio(uint64)(uint64[24],uint64) ABI method.
   *
  * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
  payouts across pools can be based on a stable snaphost of stake.

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getTokenPayoutRatio(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
      | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getTokenPayoutRatio(uint64)(uint64[24],uint64)'] | undefined]>

  /**
   * Calls the getNodePoolAssignments(uint64)((uint64[3])[8]) ABI method.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getNodePoolAssignments(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])']
      | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getNodePoolAssignments(uint64)((uint64[3])[8])'] | undefined]>

  /**
   * Calls the getNFDRegistryID()uint64 ABI method.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getNFDRegistryID(
    params?: CallParams<
      ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getNFDRegistryID()uint64'] | undefined]>

  /**
   * Calls the addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64 ABI method.
   *
  * Adds a new validator
  Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addValidator(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
      | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
    >,
  ): ValidatorRegistryComposer<
    [
      ...TReturns,
      (
        | ValidatorRegistryReturns['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
        | undefined
      ),
    ]
  >

  /**
   * Calls the changeValidatorManager(uint64,address)void ABI method.
   *
  * Changes the Validator manager for a specific Validator id.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  changeValidatorManager(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void']
      | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['changeValidatorManager(uint64,address)void'] | undefined]>

  /**
   * Calls the changeValidatorSunsetInfo(uint64,uint64,uint64)void ABI method.
   *
  * Updates the sunset information for a given validator.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  changeValidatorSunsetInfo(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
      | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['changeValidatorSunsetInfo(uint64,uint64,uint64)void'] | undefined]>

  /**
   * Calls the changeValidatorNFD(uint64,uint64,string)void ABI method.
   *
  * Changes the NFD for a validator in the validatorList contract.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  changeValidatorNFD(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void']
      | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['changeValidatorNFD(uint64,uint64,string)void'] | undefined]>

  /**
   * Calls the changeValidatorCommissionAddress(uint64,address)void ABI method.
   *
  * Change the commission address that validator rewards are sent to.
      [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  changeValidatorCommissionAddress(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void']
      | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['changeValidatorCommissionAddress(uint64,address)void'] | undefined]>

  /**
   * Calls the changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void ABI method.
   *
  * Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  changeValidatorRewardInfo(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
      | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
    >,
  ): ValidatorRegistryComposer<
    [...TReturns, ValidatorRegistryReturns['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void'] | undefined]
  >

  /**
   * Calls the addPool(pay,uint64,uint64)(uint64,uint64,uint64) ABI method.
   *
  * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
  The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
  
  
  [ ONLY OWNER OR MANAGER CAN call ]

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addPool(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['addPool(pay,uint64,uint64)(uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the addStake(pay,uint64,uint64)(uint64,uint64,uint64) ABI method.
   *
   * Adds stake to a validator pool.
   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addStake(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
      | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['addStake(pay,uint64,uint64)(uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the setTokenPayoutRatio(uint64)(uint64[24],uint64) ABI method.
   *
  * setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
  of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
  in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
  pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
  It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
  their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
  during the epoch updates across pools)
  
  
  Multiple pools will call us via pool 1 (pool2-pool1-validator, etc.) so don't assert on pool1 calling multiple
  times in same epoch.  Just return.

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setTokenPayoutRatio(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
      | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['setTokenPayoutRatio(uint64)(uint64[24],uint64)'] | undefined]>

  /**
   * Calls the stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void ABI method.
   *
  * stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
  stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
  The calling App id is validated against our pool list as well.

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stakeUpdatedViaRewards(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
      | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
    >,
  ): ValidatorRegistryComposer<
    [...TReturns, ValidatorRegistryReturns['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void'] | undefined]
  >

  /**
   * Calls the stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void ABI method.
   *
  * stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
  from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
  If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
  The calling App id is validated against our pool list as well.

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stakeRemoved(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
      | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
    >,
  ): ValidatorRegistryComposer<
    [...TReturns, ValidatorRegistryReturns['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void'] | undefined]
  >

  /**
   * Calls the findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool) ABI method.
   *
  * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
  First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
  to new pool if necessary.

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  findPoolForStaker(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
      | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
    >,
  ): ValidatorRegistryComposer<
    [...TReturns, ValidatorRegistryReturns['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)'] | undefined]
  >

  /**
   * Calls the movePoolToNode(uint64,uint64,uint64)void ABI method.
   *
  * Find the specified pool (in any node number) and move it to the specified node.
  The pool account is forced offline if moved so prior node will still run for 320 rounds but
  new key goes online on new node soon after (320 rounds after it goes online)
  No-op if success, asserts if not found or can't move  (no space in target)
  [ ONLY OWNER OR MANAGER CAN CHANGE ]

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  movePoolToNode(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void']
      | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['movePoolToNode(uint64,uint64,uint64)void'] | undefined]>

  /**
   * Calls the emptyTokenRewards(uint64,address)uint64 ABI method.
   *
  * Sends the reward tokens held in pool 1 to specified receiver.
  This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
  the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
  NOT be sent as they must be held back for stakers to later claim.
  [ ONLY OWNER CAN CALL]

   *
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  emptyTokenRewards(
    params?: CallParams<
      | ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64']
      | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']
    >,
  ): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['emptyTokenRewards(uint64,address)uint64'] | undefined]>

  /**
   * Makes a clear_state call to an existing instance of the ValidatorRegistry smart contract.
   *
   * @param params Any additional parameters for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): ValidatorRegistryComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): ValidatorRegistryComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<ValidatorRegistryComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(
    options: SkipSignaturesSimulateOptions,
  ): Promise<ValidatorRegistryComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<ValidatorRegistryComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<ValidatorRegistryComposerResults<TReturns>>
}
export type ValidatorRegistryComposerResults<TReturns extends [...any[]]> = Expand<
  SendTransactionComposerResults & {
    returns: TReturns
  }
>

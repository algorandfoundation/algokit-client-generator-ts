/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'

export const APP_SPEC: Arc56Contract = {"name":"NFDInstance","desc":"","methods":[{"name":"createApplication","args":[{"name":"nfdName","type":"string"},{"name":"seller","type":"address"},{"name":"buyer","type":"address"},{"name":"purchaseAmount","type":"uint64"},{"name":"expTime","type":"uint64"},{"name":"commission1Addr","type":"address"},{"name":"commission1Pct","type":"uint64"},{"name":"commission2Addr","type":"address"},{"name":"commission2Pct","type":"uint64"},{"name":"segmentRootAppId","type":"uint64"},{"name":"segmentRootCommissionAddr","type":"address"}],"returns":{"type":"void"},"actions":{"create":["NoOp"],"call":[]}},{"name":"updateApplication","args":[{"name":"versionNum","type":"string"}],"returns":{"type":"void"},"actions":{"create":[],"call":["UpdateApplication"]}},{"name":"gas","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"mintAsa","args":[{"name":"nfdName","type":"string"},{"name":"url","type":"string"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"deleteFields","args":[{"name":"fieldNames","type":"byte[][]"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"updateSegmentCount","args":[{"name":"childNfdName","type":"string"},{"name":"childNfdAppID","type":"uint64"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getFieldUpdateCost","readonly":true,"args":[{"name":"fieldAndVals","type":"byte[][]"}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]}},{"name":"updateFields","args":[{"name":"fieldAndVals","type":"byte[][]"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"readField","readonly":true,"args":[{"name":"fieldName","type":"byte[]"}],"returns":{"type":"byte[]"},"actions":{"create":[],"call":["NoOp"]}},{"name":"offerForSale","args":[{"name":"sellAmount","type":"uint64"},{"name":"reservedFor","type":"address"}],"returns":{"type":"void"},"events":[{"name":"nfd_offerForSale","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"seller","type":"address"},{"name":"amount","type":"uint64"},{"name":"reservedFor","type":"address"}],"desc":""}],"actions":{"create":[],"call":["NoOp"]}},{"name":"cancelSale","args":[],"returns":{"type":"void"},"events":[{"name":"nfd_saleCancelled","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"}],"desc":""}],"actions":{"create":[],"call":["NoOp"]}},{"name":"postOffer","args":[{"name":"offer","type":"uint64"},{"name":"note","type":"string"}],"returns":{"type":"void"},"events":[{"name":"nfd_postedOffer","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"sender","type":"address"},{"name":"amount","type":"uint64"},{"name":"note","type":"string"}],"desc":""}],"actions":{"create":[],"call":["NoOp"]}},{"name":"mintPayout","args":[{"name":"oneYearPrice","type":"uint64"},{"name":"segmentPlatformCostInAlgo","type":"uint64"}],"returns":{"type":"(uint64,address,uint64,address,uint64)","struct":"PayoutInfo"},"actions":{"create":[],"call":["NoOp"]}},{"name":"purchase","args":[{"name":"payment","type":"pay"}],"returns":{"type":"void"},"events":[{"name":"nfd_purchased","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"seller","type":"address"},{"name":"buyer","type":"address"},{"name":"sellAmount","type":"uint64"},{"name":"offerAmount","type":"uint64"},{"name":"overpaymentRefund","type":"uint64"},{"name":"convFeeAddr","type":"address"},{"name":"convFeeAmount","type":"uint64"}],"desc":""}],"actions":{"create":[],"call":["NoOp"]}},{"name":"isAddressInField","readonly":true,"args":[{"name":"fieldName","type":"string"},{"name":"address","type":"address"}],"returns":{"type":"bool"},"actions":{"create":[],"call":["NoOp"]}},{"name":"getRenewPrice","readonly":true,"args":[],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]}},{"name":"updateHash","args":[{"name":"hash","type":"byte[]"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"contractLock","args":[{"name":"lock","type":"bool"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"segmentLock","args":[{"name":"lock","type":"bool"},{"name":"usdPrice","type":"uint64"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"vaultOptInLock","args":[{"name":"lock","type":"bool"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"vaultOptIn","args":[{"name":"assets","type":"uint64[]"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"vaultSend","args":[{"name":"amount","type":"uint64"},{"name":"receiver","type":"address"},{"name":"note","type":"string"},{"name":"asset","type":"uint64"},{"name":"otherAssets","type":"uint64[]"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"renew","desc":"Renew adds more time to an existing NFDs expiration, or renews it if expired.\n\n\nAs part of v2-v3 upgrade, the NFDs are converted from lifetime NFDs to renewal NFDs. The v2 contract is upgraded\nto v3, then renew is called on the (now v3) nfd to turn it into a renewal (note the if curExpiration === 0 check)\n\n\nIf already renewal, then it extends the current expiration time by the time specified (minimum 1 yr) (365 / price paid * mint price)\nExpirations can never be more than NFD_MAX_EXPIRATION_DAYS days in the future.\n\n\nIF the NFD is expired:\n    x The current owner can take it back over at base price - and NFD metadata doesn't have to be cleared - they\n    get it back as-is.\n    x If not current owner, then the price goes from high of base price * 10,000 down to base price over 24 hrs where\n    'buyer' has to pay at least that price.  The NFD MUST ALREADY HAVE ITS METADATA CLEARED!","args":[{"name":"payment","type":"pay","desc":"The payment transaction from which the renewal period is determined.."}],"returns":{"type":"void"},"events":[{"name":"nfd_saleCancelled","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"}],"desc":""},{"name":"nfd_renewed","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"origOwner","type":"address"},{"name":"buyer","type":"address"},{"name":"priceOneYear","type":"uint64"},{"name":"renewAmount","type":"uint64"},{"name":"expTime","type":"uint64"}],"desc":""}],"actions":{"create":[],"call":["NoOp"]}},{"name":"setPrimaryAddress","args":[{"name":"fieldName","type":"string"},{"name":"address","type":"address"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]}},{"name":"registryAddingVerifiedAddress","desc":"Approved call from registry instructing us to move the specified u.cav.xx field and add to the specified\nverified field.","args":[{"name":"fieldBeingVerified","type":"string","desc":"- MUST START with u.cav. (!)\ngets 'added' to 'set' in next arg - must be fixed-sized bytes"},{"name":"fieldSetName","type":"string","desc":"(must BE v.ca[...].as)"}],"returns":{"type":"bool","desc":"true if added or already present, false otherwise"},"events":[{"name":"nfd_addressLinked","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"address","type":"address"}],"desc":""}],"actions":{"create":[],"call":["NoOp"]}},{"name":"registryRemovingVerifiedAddress","desc":"Approved call from registry instructing us to REMOVE an address from the specified verified address set","args":[{"name":"fieldBeingChanged","type":"string","desc":"The field being changed in the address registry."},{"name":"address","type":"address","desc":"The address to be removed from the field."},{"name":"mbrRefundDest","type":"address","desc":"the address to send reclaimed MBR (if any)\n boolean - true if valid removed"}],"returns":{"type":"bool"},"events":[{"name":"nfd_addressUnlinked","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"address","type":"address"}],"desc":""}],"actions":{"create":[],"call":["NoOp"]}}],"events":[{"name":"nfd_offerForSale","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"seller","type":"address"},{"name":"amount","type":"uint64"},{"name":"reservedFor","type":"address"}],"desc":""},{"name":"nfd_saleCancelled","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"}],"desc":""},{"name":"nfd_postedOffer","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"sender","type":"address"},{"name":"amount","type":"uint64"},{"name":"note","type":"string"}],"desc":""},{"name":"nfd_purchased","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"seller","type":"address"},{"name":"buyer","type":"address"},{"name":"sellAmount","type":"uint64"},{"name":"offerAmount","type":"uint64"},{"name":"overpaymentRefund","type":"uint64"},{"name":"convFeeAddr","type":"address"},{"name":"convFeeAmount","type":"uint64"}],"desc":""},{"name":"nfd_renewed","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"origOwner","type":"address"},{"name":"buyer","type":"address"},{"name":"priceOneYear","type":"uint64"},{"name":"renewAmount","type":"uint64"},{"name":"expTime","type":"uint64"}],"desc":""},{"name":"nfd_addressLinked","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"address","type":"address"}],"desc":""},{"name":"nfd_addressUnlinked","args":[{"name":"appId","type":"uint64"},{"name":"name","type":"string"},{"name":"address","type":"address"}],"desc":""}],"arcs":[4,56],"structs":{"PayoutInfo":[{"name":"amountToSeller","type":"uint64"},{"name":"commissionAddress","type":"address"},{"name":"amountToCommission","type":"uint64"},{"name":"segmentRootOwner","type":"address"},{"name":"amountToSegmentRoot","type":"uint64"}]},"state":{"schema":{"global":{"bytes":30,"ints":0},"local":{"bytes":0,"ints":0}},"keys":{"global":{},"local":{},"box":{}},"maps":{"global":{"globalState":{"keyType":"AVMBytes","valueType":"AVMBytes"}},"local":{},"box":{"boxes":{"keyType":"AVMBytes","valueType":"AVMBytes"}}}},"bareActions":{"create":[],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[36],"errorMessage":"The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?","teal":25},{"pc":[44],"errorMessage":"argument 0 (segmentRootCommissionAddr) for createApplication must be a address","teal":37},{"pc":[60],"errorMessage":"argument 3 (commission2Addr) for createApplication must be a address","teal":55},{"pc":[72],"errorMessage":"argument 5 (commission1Addr) for createApplication must be a address","teal":69},{"pc":[88],"errorMessage":"argument 8 (buyer) for createApplication must be a address","teal":87},{"pc":[96],"errorMessage":"argument 9 (seller) for createApplication must be a address","teal":97},{"pc":[117],"errorMessage":"caller must be NFD registry!","teal":122},{"pc":[217],"errorMessage":"commission must be between 1 and 50%","teal":224},{"pc":[251],"errorMessage":"commission must be between 1 and 50%","teal":262},{"pc":[382],"errorMessage":"parent commission address must be set if parent app id is set and parent is unlocked","teal":370},{"pc":[393],"errorMessage":"the segment commission agent should be the parent nfd's seller","teal":384},{"pc":[420],"errorMessage":"contract must be unlocked to upgrade","teal":420},{"pc":[426],"errorMessage":"caller must be NFD registry!","teal":429},{"pc":[449],"errorMessage":"can't still be in minting state","teal":459},{"pc":[467],"errorMessage":"NFD can't be expired for these v1/v2 operations","teal":481},{"pc":[731],"errorMessage":"unknown method","teal":677},{"pc":[768],"errorMessage":"caller must be NFD registry!","teal":721},{"pc":[959],"errorMessage":"field not removable or no permissions to remove","teal":942},{"pc":[963],"errorMessage":"box value does not exist: this.boxes(name).size","teal":950},{"pc":[1067],"errorMessage":"field not removable or no permissions to remove","teal":1075},{"pc":[1111],"errorMessage":"caller must be NFD registry!","teal":1130},{"pc":[1121],"errorMessage":"child NFD MUST still be in pre-claim state!","teal":1144},{"pc":[1144],"errorMessage":"passed in child name must match name in created nfd state","teal":1172},{"pc":[1177],"errorMessage":"parent must be suffix of child","teal":1209},{"pc":[1346],"errorMessage":"box value does not exist: this.boxes(name).size","teal":1381},{"pc":[1386],"errorMessage":"box value does not exist: this.boxes(name).size","teal":1423},{"pc":[1487],"errorMessage":"can't update fields if NFD expired","teal":1537},{"pc":[1615],"errorMessage":"invalid update call by registry","teal":1644},{"pc":[1717],"errorMessage":"field not updatable or no permissions to update","teal":1738},{"pc":[1763],"errorMessage":"can't update fields if NFD expired","teal":1799},{"pc":[1803],"errorMessage":"field not updatable or no permissions to update","teal":1844},{"pc":[1902],"errorMessage":"must be user-defined or verified field to fetch","teal":1953},{"pc":[1914],"errorMessage":"box value does not exist: this.boxes(fieldName).value","teal":1971},{"pc":[1944],"errorMessage":"box value does not exist: this.boxes(boxName).value","teal":2005},{"pc":[1994],"errorMessage":"box value does not exist: this.boxes(boxName).value","teal":2057},{"pc":[2021],"errorMessage":"argument 0 (reservedFor) for offerForSale must be a address","teal":2093},{"pc":[2039],"errorMessage":"can't sell if NFD expired","teal":2117},{"pc":[2089],"errorMessage":"can only be sold if no user-defined or verified properties remain","teal":2165},{"pc":[2106],"errorMessage":"must be sold for at least MIN amount","teal":2185},{"pc":[2252],"errorMessage":"can't update fields if NFD expired","teal":2323},{"pc":[2265],"errorMessage":"must be for sale","teal":2340},{"pc":[2420],"errorMessage":"caller must be NFD registry!","teal":2484},{"pc":[2652],"errorMessage":"argument 0 (payment) for purchase must be a pay transaction","teal":2751},{"pc":[2677],"errorMessage":"can't be expired","teal":2782},{"pc":[2681],"errorMessage":"must be for sale","teal":2789},{"pc":[2733],"errorMessage":"payment sender must be same as purchase caller","teal":2830},{"pc":[2749],"errorMessage":"Reserved owner set, but sender isn't the reserved address","teal":2853},{"pc":[2795],"errorMessage":"offer must be at least min amount","teal":2900},{"pc":[2801],"errorMessage":"offer must be at least sell amount","teal":2910},{"pc":[2823],"errorMessage":"transaction verification failed: {\"txn\":\"payment\",\"field\":\"amount\",\"expected\":\"origOfferamt\"}","teal":2935},{"pc":[2831],"errorMessage":"transaction verification failed: {\"txn\":\"payment\",\"field\":\"receiver\",\"expected\":\"this.app.address\"}","teal":2944},{"pc":[3291],"errorMessage":"argument 0 (address) for isAddressInField must be a address","teal":3406},{"pc":[3336],"errorMessage":"box value does not exist: this.boxes(fieldName).value","teal":3458},{"pc":[3553],"errorMessage":"must pass 32-byte hash that isn't 0","teal":3711},{"pc":[3567],"errorMessage":"only txnlab or owner can request an nfd nft hash update","teal":3729},{"pc":[3603],"errorMessage":"argument 0 (lock) for contractLock must be a bool","teal":3782},{"pc":[3649],"errorMessage":"argument 1 (lock) for segmentLock must be a bool","teal":3835},{"pc":[3732],"errorMessage":"amount must be at least NFD_MIN_SEGMENT_USD dollars in algo","teal":3930},{"pc":[3747],"errorMessage":"argument 0 (lock) for vaultOptInLock must be a bool","teal":3952},{"pc":[3812],"errorMessage":"sender must be owner when vault locked","teal":4032},{"pc":[3817],"errorMessage":"part of opt-in for new asset, must have prior txn paying MBR","teal":4042},{"pc":[3830],"errorMessage":"transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"typeEnum\",\"expected\":\"pay\"}","teal":4061},{"pc":[3838],"errorMessage":"transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"receiver\",\"expected\":\"this.app.address\"}","teal":4070},{"pc":[3853],"errorMessage":"transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"amount\",\"expected\":\"100_000 * assets.length\"}","teal":4084},{"pc":[3954],"errorMessage":"argument 3 (receiver) for vaultSend must be a address","teal":4198},{"pc":[3994],"errorMessage":"can't specify other assets if sending algo from vault","teal":4247},{"pc":[4061],"errorMessage":"can only send one asset if amount == 0","teal":4329},{"pc":[4128],"errorMessage":"receiver must be owner","teal":4402},{"pc":[4246],"errorMessage":"argument 0 (payment) for renew must be a pay transaction","teal":4545},{"pc":[4265],"errorMessage":"transaction verification failed: {\"txn\":\"payment\",\"field\":\"receiver\",\"expected\":\"this.app.address\"}","teal":4585},{"pc":[4395],"errorMessage":"can't claim expired nfd unless all metadata is cleared","teal":4714},{"pc":[4403],"errorMessage":"must pay at least minimum renewal price","teal":4727},{"pc":[4559],"errorMessage":"global state value does not exist: parentAppId.globalState(NFD_KEY_OWNER)","teal":4900},{"pc":[4725],"errorMessage":"argument 0 (address) for setPrimaryAddress must be a address","teal":5047},{"pc":[4811],"errorMessage":"caller must be NFD registry!","teal":5134},{"pc":[4829],"errorMessage":"field being verified MUST START with u.cav","teal":5148},{"pc":[4838],"errorMessage":"destination field MUST START with v.ca[....]","teal":5158},{"pc":[4853],"errorMessage":"destination field must end END with .as","teal":5173},{"pc":[4859],"errorMessage":"referenced field to add as verified address must have value in box storage","teal":5186},{"pc":[4868],"errorMessage":"box value does not exist: this.boxes(fieldBeingVerified).value","teal":5201},{"pc":[4933],"errorMessage":"argument 0 (mbrRefundDest) for registryRemovingVerifiedAddress must be a address","teal":5261},{"pc":[4941],"errorMessage":"argument 1 (address) for registryRemovingVerifiedAddress must be a address","teal":5271},{"pc":[4971],"errorMessage":"caller must be NFD registry!","teal":5310},{"pc":[4983],"errorMessage":"can't be for sale","teal":5326},{"pc":[4992],"errorMessage":"verified field MUST START with v.ca[....]","teal":5337},{"pc":[5007],"errorMessage":"verified field must end END with .as","teal":5355},{"pc":[5016],"errorMessage":"box value does not exist: this.boxes(fieldBeingChanged).size","teal":5370},{"pc":[5184],"errorMessage":"sender must be owner","teal":5550},{"pc":[5189],"errorMessage":"part of opt-in for new asset, must have prior txn paying MBR","teal":5560},{"pc":[5202],"errorMessage":"transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"typeEnum\",\"expected\":\"pay\"}","teal":5579},{"pc":[5210],"errorMessage":"transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"receiver\",\"expected\":\"this.app.address\"}","teal":5588},{"pc":[5223],"errorMessage":"transaction verification failed: {\"txn\":\"this.txnGroup[this.txn.groupIndex - 1]\",\"field\":\"amount\",\"expected\":\"100_000 * (this.txn.numAppArgs - 1)\"}","teal":5601},{"pc":[5326],"errorMessage":"global state value does not exist: AppID.fromUint64(appId).globalState(key)","teal":5738},{"pc":[5380],"errorMessage":"internal fields can never be deleted","teal":5804},{"pc":[5397],"errorMessage":"must be owned","teal":5828},{"pc":[5409],"errorMessage":"can't be for sale","teal":5844},{"pc":[5466],"errorMessage":"internal fields can never be updated","teal":5906},{"pc":[5521],"errorMessage":"must be owned","teal":5963},{"pc":[5526],"errorMessage":"can't be for sale","teal":5971},{"pc":[5532],"errorMessage":"sender must be owner","teal":5981},{"pc":[5562],"errorMessage":"updating v.caAlgo field isn't allowed via regular field update","teal":6017},{"pc":[5683],"errorMessage":"can't be for sale","teal":6162},{"pc":[5688],"errorMessage":"can't be expired","teal":6170},{"pc":[5773],"errorMessage":"max expiration exceeded parameters defined by registry","teal":6282},{"pc":[5941],"errorMessage":"box value does not exist: this.boxes(key).value","teal":6515},{"pc":[5956],"errorMessage":"address 'set' should already have at least two values","teal":6533},{"pc":[6024],"errorMessage":"address must be found in set in order to move it","teal":6615},{"pc":[6090],"errorMessage":"box value does not exist: this.boxes(key).value","teal":6698},{"pc":[6109],"errorMessage":"existing set must be multiple of key being added","teal":6719},{"pc":[6216],"errorMessage":"box value does not exist: this.boxes(key).value","teal":6855},{"pc":[6385],"errorMessage":"sender must be owner","teal":7064},{"pc":[6400],"errorMessage":"this contract does not implement the given ABI method for create NoOp","teal":7073},{"pc":[6616],"errorMessage":"this contract does not implement the given ABI method for call UpdateApplication","teal":7114}],"pcOffsetMethod":"cblocks"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAwIDEgMiAzMiBUTVBMX3JlZ2lzdHJ5QXBwSWQgOCAzIDYgMzY1IDQwMCA0IDEwIDI1MDAgNSA4NjQwMCAxMDAwMDAwIDEwMF8wMDAgNTAwIDEwMDAgMjAwIFRNUExfYWRtaW5Bc2FJZApieXRlY2Jsb2NrIDB4ICJpLm93bmVyLmEiICJpLnRpbWVDaGFuZ2VkIiAiaS5taW50aW5nIiAiaS5uYW1lIiAiaS5jb21taXNzaW9uMUFnZW50LmEiICJpLnNlbGxhbXQiICJpLmNvbW1pc3Npb24xIiAiaS5yZXNlcnZlZE93bmVyLmEiICJpLnNlZ21lbnRBZ2VudC5hIiAiaS5zZWxsZXIuYSIgMHgxNTFmN2M3NSAiaS5taW50aW5nS2lja29mZkNyZWF0b3IuYSIgImkubWludGluZ0tpY2tvZmZBbW91bnQiIDB4MGE4MTAxIDB4MzEgImkuY29tbWlzc2lvbjJBZ2VudC5hIiAiaS5leHBpcmF0aW9uVGltZSIgImkuYXNhaWQiICIxIiAiaS52YXVsdE9wdEluTG9ja2VkIiAiaS5zZWdtZW50TG9ja2VkIiAiaS5jb21taXNzaW9uMiIgMHgzMCAiMCIgImkuY29udHJhY3RMb2NrZWQiICJpLmhpZ2hlc3RTb2xkQW10IiAiaS5wYXJlbnRBcHBJRCIgMHgyZSAweDAwICIyIiAweDYyNmY3ODUyNjU2Njc1NmU2NCAiaS5zZWdtZW50UHJpY2VVc2QiIDB4NzYyZTYzNjE0MTZjNjc2ZiAiaS50aW1lUHVyY2hhc2VkIiAiaS5zZWdtZW50Q291bnQiIDB4NDM2NWVkOTAgMHg3MDNiOGNlNyAweDc2MmU2MzYxIDB4MmU2MTczICJpLnZlciIgMHgwMDBhIDB4MDAyYQoKLy8gVGhpcyBURUFMIHdhcyBnZW5lcmF0ZWQgYnkgVEVBTFNjcmlwdCB2MC4xMDUuNQovLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmRmb3VuZGF0aW9uL1RFQUxTY3JpcHQKCi8vICEhISEgV0FSTklORzogVGhpcyBjb250cmFjdCBpcyAqTk9UKiBBUkM0IGNvbXBsaWFudC4gSXQgbWF5IGNvbnRhaW4gQUJJIG1ldGhvZHMsIGJ1dCBpdCBhbHNvIGFsbG93cyBhcHAgY2FsbHMgd2hlcmUgdGhlIGZpcnN0IGFyZ3VtZW50IGRvZXMgTk9UIG1hdGNoIGFuIEFCSSBzZWxlY3RvcgoKLy8gVGhlIGZvbGxvd2luZyB0ZW4gbGluZXMgb2YgVEVBTCBoYW5kbGUgaW5pdGlhbCBwcm9ncmFtIGZsb3cKLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgdG8gbWFrZSBpdCBlYXN5IGZvciBhbnlvbmUgdG8gcGFyc2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGFuZCBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBhY3Rpb24gaXMgYWxsb3dlZAovLyBIZXJlLCBhY3Rpb24gcmVmZXJzIHRvIHRoZSBPbkNvbXBsZXRlIGluIGNvbWJpbmF0aW9uIHdpdGggd2hldGhlciB0aGUgYXBwIGlzIGJlaW5nIGNyZWF0ZWQgb3IgY2FsbGVkCi8vIEV2ZXJ5IHBvc3NpYmxlIGFjdGlvbiBmb3IgdGhpcyBjb250cmFjdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudAovLyBJZiB0aGUgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgY29udHJhY3QsIGl0cyByZXNwZWN0aXZlIGJyYW5jaCB3aWxsIGJlICIqTk9UX0lNUExFTUVOVEVEIiB3aGljaCBqdXN0IGNvbnRhaW5zICJlcnIiCnR4biBBcHBsaWNhdGlvbklECiEKaW50YyA3IC8vIDYKKgp0eG4gT25Db21wbGV0aW9uCisKc3dpdGNoICpjYWxsX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNhbGxfVXBkYXRlQXBwbGljYXRpb24gKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKHN0cmluZyxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CgkvLyBzZWdtZW50Um9vdENvbW1pc3Npb25BZGRyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxMQoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChzZWdtZW50Um9vdENvbW1pc3Npb25BZGRyKSBmb3IgY3JlYXRlQXBwbGljYXRpb24gbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIHNlZ21lbnRSb290QXBwSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMTAKCWJ0b2kKCgkvLyBjb21taXNzaW9uMlBjdDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA5CglidG9pCgoJLy8gY29tbWlzc2lvbjJBZGRyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA4CglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDMgKGNvbW1pc3Npb24yQWRkcikgZm9yIGNyZWF0ZUFwcGxpY2F0aW9uIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBjb21taXNzaW9uMVBjdDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA3CglidG9pCgoJLy8gY29tbWlzc2lvbjFBZGRyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA2CglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDUgKGNvbW1pc3Npb24xQWRkcikgZm9yIGNyZWF0ZUFwcGxpY2F0aW9uIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleHBUaW1lOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWJ0b2kKCgkvLyBwdXJjaGFzZUFtb3VudDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglidG9pCgoJLy8gYnV5ZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnRjIDMgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgOCAoYnV5ZXIpIGZvciBjcmVhdGVBcHBsaWNhdGlvbiBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gc2VsbGVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDkgKHNlbGxlcikgZm9yIGNyZWF0ZUFwcGxpY2F0aW9uIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBuZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbihzdHJpbmcsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBjcmVhdGVBcHBsaWNhdGlvbgoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gY3JlYXRlQXBwbGljYXRpb24obmZkTmFtZTogc3RyaW5nLCBzZWxsZXI6IEFkZHJlc3MsIGJ1eWVyOiBBZGRyZXNzLCBwdXJjaGFzZUFtb3VudDogdWludDY0LCBleHBUaW1lOiB1aW50NjQsIGNvbW1pc3Npb24xQWRkcjogQWRkcmVzcywgY29tbWlzc2lvbjFQY3Q6IHVpbnQ2NCwgY29tbWlzc2lvbjJBZGRyOiBBZGRyZXNzLCBjb21taXNzaW9uMlBjdDogdWludDY0LCBzZWdtZW50Um9vdEFwcElkOiB1aW50NjQsIHNlZ21lbnRSb290Q29tbWlzc2lvbkFkZHI6IEFkZHJlc3MpOiB2b2lkCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMTEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDUKCS8vIGFzc2VydChnbG9iYWxzLmNhbGxlckFwcGxpY2F0aW9uSUQgPT09IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKSwgJ2NhbGxlciBtdXN0IGJlIE5GRCByZWdpc3RyeSEnKQoJZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uSUQKCWludGMgNCAvLyBUTVBMX3JlZ2lzdHJ5QXBwSWQKCT09CgoJLy8gY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDYKCS8vIGFzc2VydChwdXJjaGFzZUFtb3VudCA+IDApCglmcmFtZV9kaWcgLTQgLy8gcHVyY2hhc2VBbW91bnQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT4KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ4CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfSVNMT0NLRUQpLnZhbHVlID0gTkZEX0xPQ0tFRF9WQUxfRkFMU0UKCWJ5dGVjIDI1IC8vICJpLmNvbnRyYWN0TG9ja2VkIgoJYnl0ZWMgMjQgLy8gIjAiCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ5CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVkVSU0lPTikudmFsdWUgPSBORkRfQ1VSUkVOVF9WRVJTSU9OCglieXRlYyA0MCAvLyAiaS52ZXIiCglwdXNoYnl0ZXMgIjMuOCIKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTAKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS52YWx1ZSA9IE5GRF9NSU5USU5HX1NUQVRFX1BSRUFTQQoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYnl0ZWMgMTkgLy8gIjEiCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUxCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNSRUFURUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCXB1c2hieXRlcyAiaS50aW1lQ3JlYXRlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTIKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FQ0hBTkdFRCkudmFsdWUgPSBpdG9iKGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wKQoJYnl0ZWMgMiAvLyAiaS50aW1lQ2hhbmdlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTMKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FUFVSQ0hBU0VEKS52YWx1ZSA9IGl0b2IoZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXApCglieXRlYyAzNCAvLyAiaS50aW1lUHVyY2hhc2VkIgoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJaXRvYgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0lTU0VHTUVOVExPQ0tFRCkudmFsdWUgPSBORkRfTE9DS0VEX1ZBTF9UUlVFCglieXRlYyAyMSAvLyAiaS5zZWdtZW50TG9ja2VkIgoJYnl0ZWMgMTkgLy8gIjEiCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTkFNRSkudmFsdWUgPSBuZmROYW1lCglieXRlYyA0IC8vICJpLm5hbWUiCglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogc3RyaW5nCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU2CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlID0gcmF3Qnl0ZXMoYnV5ZXIpCglieXRlYyAxIC8vICJpLm93bmVyLmEiCglmcmFtZV9kaWcgLTMgLy8gYnV5ZXI6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTcKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMRVIpLnZhbHVlID0gcmF3Qnl0ZXMoc2VsbGVyKQoJYnl0ZWMgMTAgLy8gImkuc2VsbGVyLmEiCglmcmFtZV9kaWcgLTIgLy8gc2VsbGVyOiBBZGRyZXNzCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU4CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfU0VMTF9BTU9VTlQpLnZhbHVlID0gaXRvYihwdXJjaGFzZUFtb3VudCkKCWJ5dGVjIDYgLy8gImkuc2VsbGFtdCIKCWZyYW1lX2RpZyAtNCAvLyBwdXJjaGFzZUFtb3VudDogdWludDY0CglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1OQoJLy8gY29tbWlzc2lvbjFBZGRyICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzCglmcmFtZV9kaWcgLTYgLy8gY29tbWlzc2lvbjFBZGRyOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9CglieiAqaWYwX2VuZAoKCS8vICppZjBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjAKCS8vIGFzc2VydChjb21taXNzaW9uMVBjdCA+PSAxICYmIGNvbW1pc3Npb24xUGN0IDw9IDUwMCwgJ2NvbW1pc3Npb24gbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDUwJScpCglmcmFtZV9kaWcgLTcgLy8gY29tbWlzc2lvbjFQY3Q6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCT49CglkdXAKCWJ6ICpza2lwX2FuZDAKCWZyYW1lX2RpZyAtNyAvLyBjb21taXNzaW9uMVBjdDogdWludDY0CglpbnRjIDE3IC8vIDUwMAoJPD0KCSYmCgoqc2tpcF9hbmQwOgoJLy8gY29tbWlzc2lvbiBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xX0FHRU5UKS52YWx1ZSA9IHJhd0J5dGVzKGNvbW1pc3Npb24xQWRkcikKCWJ5dGVjIDUgLy8gImkuY29tbWlzc2lvbjFBZ2VudC5hIgoJZnJhbWVfZGlnIC02IC8vIGNvbW1pc3Npb24xQWRkcjogQWRkcmVzcwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xKS52YWx1ZSA9IGl0b2IoY29tbWlzc2lvbjFQY3QpCglieXRlYyA3IC8vICJpLmNvbW1pc3Npb24xIgoJZnJhbWVfZGlnIC03IC8vIGNvbW1pc3Npb24xUGN0OiB1aW50NjQKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gKmlmMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYzCgkvLyBjb21taXNzaW9uMkFkZHIgIT09IGdsb2JhbHMuemVyb0FkZHJlc3MKCWZyYW1lX2RpZyAtOCAvLyBjb21taXNzaW9uMkFkZHI6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWJ6ICppZjFfZW5kCgoJLy8gKmlmMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NAoJLy8gYXNzZXJ0KGNvbW1pc3Npb24yUGN0ID49IDEgJiYgY29tbWlzc2lvbjJQY3QgPD0gNTAwLCAnY29tbWlzc2lvbiBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAlJykKCWZyYW1lX2RpZyAtOSAvLyBjb21taXNzaW9uMlBjdDogdWludDY0CglpbnRjIDEgLy8gMQoJPj0KCWR1cAoJYnogKnNraXBfYW5kMQoJZnJhbWVfZGlnIC05IC8vIGNvbW1pc3Npb24yUGN0OiB1aW50NjQKCWludGMgMTcgLy8gNTAwCgk8PQoJJiYKCipza2lwX2FuZDE6CgkvLyBjb21taXNzaW9uIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA1MCUKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQ09NTUlTU0lPTjJfQUdFTlQpLnZhbHVlID0gcmF3Qnl0ZXMoY29tbWlzc2lvbjJBZGRyKQoJYnl0ZWMgMTYgLy8gImkuY29tbWlzc2lvbjJBZ2VudC5hIgoJZnJhbWVfZGlnIC04IC8vIGNvbW1pc3Npb24yQWRkcjogQWRkcmVzcwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04yKS52YWx1ZSA9IGl0b2IoY29tbWlzc2lvbjJQY3QpCglieXRlYyAyMiAvLyAiaS5jb21taXNzaW9uMiIKCWZyYW1lX2RpZyAtOSAvLyBjb21taXNzaW9uMlBjdDogdWludDY0CglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKKmlmMV9lbmQ6CgoqaWYwX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY5CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQ0FURUdPUlkpLnZhbHVlID0gJ2NvbW1vbicKCXB1c2hieXRlcyAiaS5jYXRlZ29yeSIKCXB1c2hieXRlcyAweDYzNmY2ZDZkNmY2ZSAvLyAiY29tbW9uIgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NBTEVUWVBFKS52YWx1ZSA9ICdidXlJdE5vdycKCXB1c2hieXRlcyAiaS5zYWxlVHlwZSIKCXB1c2hieXRlcyAweDYyNzU3OTQ5NzQ0ZTZmNzcgLy8gImJ1eUl0Tm93IgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0VYUElSQVRJT05USU1FKS52YWx1ZSA9IGl0b2IoZXhwVGltZSkKCWJ5dGVjIDE3IC8vICJpLmV4cGlyYXRpb25UaW1lIgoJZnJhbWVfZGlnIC01IC8vIGV4cFRpbWU6IHVpbnQ2NAoJaXRvYgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3NQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0lTVkFVTFRPUFRJTkxPQ0tFRCkudmFsdWUgPSBORkRfTE9DS0VEX1ZBTF9GQUxTRQoJYnl0ZWMgMjAgLy8gImkudmF1bHRPcHRJbkxvY2tlZCIKCWJ5dGVjIDI0IC8vICIwIgoJYXBwX2dsb2JhbF9wdXQKCgkvLyAqaWYyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzcKCS8vIHNlZ21lbnRSb290QXBwSWQgIT09IDAKCWZyYW1lX2RpZyAtMTAgLy8gc2VnbWVudFJvb3RBcHBJZDogdWludDY0CglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjJfZW5kCgoJLy8gKmlmMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3OAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1BBUkVOVF9JRCkudmFsdWUgPSBpdG9iKHNlZ21lbnRSb290QXBwSWQpCglieXRlYyAyNyAvLyAiaS5wYXJlbnRBcHBJRCIKCWZyYW1lX2RpZyAtMTAgLy8gc2VnbWVudFJvb3RBcHBJZDogdWludDY0CglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgxCgkvLyBwYXJlbnROYW1lID0gdGhpcy5zYWZlR2xvYmFsQnl0ZUdldEV4KHNlZ21lbnRSb290QXBwSWQsIE5GRF9LRVlfTkFNRSkKCWJ5dGVjIDQgLy8gImkubmFtZSIKCWZyYW1lX2RpZyAtMTAgLy8gc2VnbWVudFJvb3RBcHBJZDogdWludDY0CgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0RXgKCWZyYW1lX2J1cnkgMCAvLyBwYXJlbnROYW1lOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NAoJLy8gYXNzZXJ0KGV4dHJhY3QzKG5mZE5hbWUsIGxlbihuZmROYW1lKSAtIGxlbihwYXJlbnROYW1lKSAtIDEsIGxlbihwYXJlbnROYW1lKSArIDEpID09PSAnLicgKyBwYXJlbnROYW1lKQoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJbGVuCglmcmFtZV9kaWcgMCAvLyBwYXJlbnROYW1lOiBieXRlW10KCWxlbgoJLQoJaW50YyAxIC8vIDEKCS0KCWZyYW1lX2RpZyAwIC8vIHBhcmVudE5hbWU6IGJ5dGVbXQoJbGVuCglpbnRjIDEgLy8gMQoJKwoJZXh0cmFjdDMKCWJ5dGVjIDI4IC8vICAiLiIKCWZyYW1lX2RpZyAwIC8vIHBhcmVudE5hbWU6IGJ5dGVbXQoJY29uY2F0Cgk9PQoJYXNzZXJ0CgoJLy8gKmlmM19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjg4CgkvLyB0aGlzLnNhZmVHbG9iYWxCeXRlR2V0RXgoc2VnbWVudFJvb3RBcHBJZCwgTkZEX0tFWV9JU1NFR01FTlRMT0NLRUQpID09PSBORkRfTE9DS0VEX1ZBTF9GQUxTRQoJYnl0ZWMgMjEgLy8gImkuc2VnbWVudExvY2tlZCIKCWZyYW1lX2RpZyAtMTAgLy8gc2VnbWVudFJvb3RBcHBJZDogdWludDY0CgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0RXgKCWJ5dGVjIDI0IC8vICIwIgoJPT0KCWJ6ICppZjNfZW5kCgoJLy8gKmlmM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5MAoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgICAgICBzZWdtZW50Um9vdENvbW1pc3Npb25BZGRyICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzLAoJLy8gICAgICAgICAgICAgICAgICAgICAncGFyZW50IGNvbW1pc3Npb24gYWRkcmVzcyBtdXN0IGJlIHNldCBpZiBwYXJlbnQgYXBwIGlkIGlzIHNldCBhbmQgcGFyZW50IGlzIHVubG9ja2VkJywKCS8vICAgICAgICAgICAgICAgICApCglmcmFtZV9kaWcgLTExIC8vIHNlZ21lbnRSb290Q29tbWlzc2lvbkFkZHI6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCgkvLyBwYXJlbnQgY29tbWlzc2lvbiBhZGRyZXNzIG11c3QgYmUgc2V0IGlmIHBhcmVudCBhcHAgaWQgaXMgc2V0IGFuZCBwYXJlbnQgaXMgdW5sb2NrZWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk3CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXRFeChzZWdtZW50Um9vdEFwcElkLCBORkRfS0VZX1NFTExFUikgPT09IHJhd0J5dGVzKHNlZ21lbnRSb290Q29tbWlzc2lvbkFkZHIpLAoJLy8gICAgICAgICAgICAgICAgICAgICAidGhlIHNlZ21lbnQgY29tbWlzc2lvbiBhZ2VudCBzaG91bGQgYmUgdGhlIHBhcmVudCBuZmQncyBzZWxsZXIiLAoJLy8gICAgICAgICAgICAgICAgICkKCWJ5dGVjIDEwIC8vICJpLnNlbGxlci5hIgoJZnJhbWVfZGlnIC0xMCAvLyBzZWdtZW50Um9vdEFwcElkOiB1aW50NjQKCWNhbGxzdWIgc2FmZUdsb2JhbEJ5dGVHZXRFeAoJZnJhbWVfZGlnIC0xMSAvLyBzZWdtZW50Um9vdENvbW1pc3Npb25BZGRyOiBBZGRyZXNzCgk9PQoKCS8vIHRoZSBzZWdtZW50IGNvbW1pc3Npb24gYWdlbnQgc2hvdWxkIGJlIHRoZSBwYXJlbnQgbmZkJ3Mgc2VsbGVyCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDEKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UX0NPTU1JU1NJT05fQUdFTlQpLnZhbHVlID0gcmF3Qnl0ZXMoc2VnbWVudFJvb3RDb21taXNzaW9uQWRkcikKCWJ5dGVjIDkgLy8gImkuc2VnbWVudEFnZW50LmEiCglmcmFtZV9kaWcgLTExIC8vIHNlZ21lbnRSb290Q29tbWlzc2lvbkFkZHI6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CgoqaWYzX2VuZDoKCippZjJfZW5kOgoJcmV0c3ViCgovLyB1cGRhdGVBcHBsaWNhdGlvbihzdHJpbmcpdm9pZAoqYWJpX3JvdXRlX3VwZGF0ZUFwcGxpY2F0aW9uOgoJLy8gdmVyc2lvbk51bTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdXBkYXRlQXBwbGljYXRpb24oc3RyaW5nKXZvaWQKCWNhbGxzdWIgdXBkYXRlQXBwbGljYXRpb24KCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHVwZGF0ZUFwcGxpY2F0aW9uKHZlcnNpb25OdW06IHN0cmluZyk6IHZvaWQKdXBkYXRlQXBwbGljYXRpb246Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTAKCS8vIGFzc2VydCh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfSVNMT0NLRUQpLnZhbHVlICE9PSBORkRfTE9DS0VEX1ZBTF9UUlVFLCAnY29udHJhY3QgbXVzdCBiZSB1bmxvY2tlZCB0byB1cGdyYWRlJykKCWJ5dGVjIDI1IC8vICJpLmNvbnRyYWN0TG9ja2VkIgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGVjIDE5IC8vICIxIgoJIT0KCgkvLyBjb250cmFjdCBtdXN0IGJlIHVubG9ja2VkIHRvIHVwZ3JhZGUKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExMwoJLy8gYXNzZXJ0KGdsb2JhbHMuY2FsbGVyQXBwbGljYXRpb25JRCA9PT0gQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpLCAnY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IScpCglnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAoJaW50YyA0IC8vIFRNUExfcmVnaXN0cnlBcHBJZAoJPT0KCgkvLyBjYWxsZXIgbXVzdCBiZSBORkQgcmVnaXN0cnkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTQKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9WRVJTSU9OKS52YWx1ZSA9IHZlcnNpb25OdW0KCWJ5dGVjIDQwIC8vICJpLnZlciIKCWZyYW1lX2RpZyAtMSAvLyB2ZXJzaW9uTnVtOiBzdHJpbmcKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTE1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBvbkNhbGwoKTogdm9pZApvbkNhbGw6Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjAKCS8vIGFzc2VydCghdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX01JTlRJTkcpLmV4aXN0cywgImNhbid0IHN0aWxsIGJlIGluIG1pbnRpbmcgc3RhdGUiKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoKCS8vIGNhbid0IHN0aWxsIGJlIGluIG1pbnRpbmcgc3RhdGUKCWFzc2VydAoKCS8vICppZjRfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjEKCS8vIHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMF0gPT09ICdnYXMnCgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCXB1c2hieXRlcyAweDY3NjE3MyAvLyAiZ2FzIgoJPT0KCWJ6ICppZjRfZW5kCgoJLy8gKmlmNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjEKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY0X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNQoJLy8gYXNzZXJ0KCF0aGlzLmlzRXhwaXJlZCgpLCAiTkZEIGNhbid0IGJlIGV4cGlyZWQgZm9yIHRoZXNlIHYxL3YyIG9wZXJhdGlvbnMiKQoJY2FsbHN1YiBpc0V4cGlyZWQKCSEKCgkvLyBORkQgY2FuJ3QgYmUgZXhwaXJlZCBmb3IgdGhlc2UgdjEvdjIgb3BlcmF0aW9ucwoJYXNzZXJ0CgoJLy8gKmlmNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNwoJLy8gdGhpcy50eG4ubnVtQXBwQXJncyA+PSAzICYmIHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMF0gPT09IE5GRF9DQUxMX1VQREFURV9GSUVMRAoJdHhuIE51bUFwcEFyZ3MKCWludGMgNiAvLyAzCgk+PQoJZHVwCglieiAqc2tpcF9hbmQyCgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCXB1c2hieXRlcyAidXBkYXRlX2ZpZWxkIgoJPT0KCSYmCgoqc2tpcF9hbmQyOgoJYnogKmlmNV9lbmQKCgkvLyAqaWY1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzMwoJLy8gdGhpcy51cGRhdGVGaWVsZHNGcm9tQXJncygpCgljYWxsc3ViIHVwZGF0ZUZpZWxkc0Zyb21BcmdzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM0CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmNV9lbmQ6CgkvLyAqaWY2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM2CgkvLyB0aGlzLnR4bi5udW1BcHBBcmdzID49IDEgJiYgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVswXSA9PT0gTkZEX0NBTExfREVMRVRFX0ZJRUxECgl0eG4gTnVtQXBwQXJncwoJaW50YyAxIC8vIDEKCT49CglkdXAKCWJ6ICpza2lwX2FuZDMKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMAoJcHVzaGJ5dGVzICJkZWxldGVfZmllbGQiCgk9PQoJJiYKCipza2lwX2FuZDM6CglieiAqaWY2X2VuZAoKCS8vICppZjZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQxCgkvLyB0aGlzLmRlbGV0ZUZpZWxkc0Zyb21BcmdzKCkKCWNhbGxzdWIgZGVsZXRlRmllbGRzRnJvbUFyZ3MKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDIKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY2X2VuZDoKCS8vICppZjdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDQKCS8vIHRoaXMudHhuLm51bUFwcEFyZ3MgPT09IDIgJiYgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVswXSA9PT0gTkZEX0NBTExfUkVBRF9QUk9QRVJUWQoJdHhuIE51bUFwcEFyZ3MKCWludGMgMiAvLyAyCgk9PQoJZHVwCglieiAqc2tpcF9hbmQ0Cgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCXB1c2hieXRlcyAicmVhZF9wcm9wZXJ0eSIKCT09CgkmJgoKKnNraXBfYW5kNDoKCWJ6ICppZjdfZW5kCgoJLy8gKmlmN19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDkKCS8vIGxvZyh0aGlzLnJlYWRGaWVsZCh0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzFdIGFzIGJ5dGVzKSkKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMQoJY2FsbHN1YiByZWFkRmllbGQKCWxvZwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MAoJLy8gcmV0dXJuCglyZXRzdWIKCippZjdfZW5kOgoJLy8gKmlmOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MwoJLy8gdGhpcy50eG4ubnVtQXBwQXJncyA9PT0gMiAmJiB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzBdID09PSBORkRfQ0FMTF9VUERBVEVfSEFTSAoJdHhuIE51bUFwcEFyZ3MKCWludGMgMiAvLyAyCgk9PQoJZHVwCglieiAqc2tpcF9hbmQ1Cgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCXB1c2hieXRlcyAidXBkYXRlX2hhc2giCgk9PQoJJiYKCipza2lwX2FuZDU6CglieiAqaWY4X2VuZAoKCS8vICppZjhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0CgkvLyB0aGlzLnVwZGF0ZUhhc2godGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsxXSBhcyBieXRlcykKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMQoJY2FsbHN1YiB1cGRhdGVIYXNoCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU1CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmOF9lbmQ6CgkvLyAqaWY5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU5CgkvLyB0aGlzLnR4bi5udW1BcHBBcmdzID09PSAyICYmIHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMF0gPT09IE5GRF9DQUxMX0NPTlRSQUNUX0xPQ0sKCXR4biBOdW1BcHBBcmdzCglpbnRjIDIgLy8gMgoJPT0KCWR1cAoJYnogKnNraXBfYW5kNgoJdHhuIEFwcGxpY2F0aW9uQXJncyAwCglwdXNoYnl0ZXMgImNvbnRyYWN0X2xvY2siCgk9PQoJJiYKCipza2lwX2FuZDY6CglieiAqaWY5X2VuZAoKCS8vICppZjlfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTYwCgkvLyB0aGlzLmNvbnRyYWN0TG9jayh0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzFdID09PSAnMScpCgl0eG4gQXBwbGljYXRpb25BcmdzIDEKCWJ5dGVjIDE1IC8vICAiMSIKCT09CgljYWxsc3ViIGNvbnRyYWN0TG9jawoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE2MQoJLy8gcmV0dXJuCglyZXRzdWIKCippZjlfZW5kOgoJLy8gKmlmMTBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNjYKCS8vIHRoaXMudHhuLm51bUFwcEFyZ3MgPT09IDMgJiYgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVswXSA9PT0gTkZEX0NBTExfU0VHTUVOVF9MT0NLCgl0eG4gTnVtQXBwQXJncwoJaW50YyA2IC8vIDMKCT09CglkdXAKCWJ6ICpza2lwX2FuZDcKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMAoJcHVzaGJ5dGVzICJzZWdtZW50X2xvY2siCgk9PQoJJiYKCipza2lwX2FuZDc6CglieiAqaWYxMF9lbmQKCgkvLyAqaWYxMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNjcKCS8vIHRoaXMuc2VnbWVudExvY2sodGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsxXSA9PT0gJzEnLCBidG9pKHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMl0pKQoJdHhuIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgl0eG4gQXBwbGljYXRpb25BcmdzIDEKCWJ5dGVjIDE1IC8vICAiMSIKCT09CgljYWxsc3ViIHNlZ21lbnRMb2NrCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTY4CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmMTBfZW5kOgoJLy8gKmlmMTFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNzUKCS8vIHRoaXMudHhuLm51bUFwcEFyZ3MgPj0gMiAmJiB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzBdID09PSBORkRfQ0FMTF9WQVVMVF9PUFRJTgoJdHhuIE51bUFwcEFyZ3MKCWludGMgMiAvLyAyCgk+PQoJZHVwCglieiAqc2tpcF9hbmQ4Cgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCXB1c2hieXRlcyAidmF1bHRfb3B0aW4iCgk9PQoJJiYKCipza2lwX2FuZDg6CglieiAqaWYxMV9lbmQKCgkvLyAqaWYxMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNzYKCS8vIHRoaXMudmF1bHRPcHRJbkZyb21BcmdzKCkKCWNhbGxzdWIgdmF1bHRPcHRJbkZyb21BcmdzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTc3CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmMTFfZW5kOgoJLy8gdW5rbm93biBtZXRob2QKCWVycgoJcmV0c3ViCgovLyBnYXMoKXZvaWQKKmFiaV9yb3V0ZV9nYXM6CgkvLyBleGVjdXRlIGdhcygpdm9pZAoJY2FsbHN1YiBnYXMKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdhcygpOiB2b2lkCmdhczoKCXByb3RvIDAgMAoJcmV0c3ViCgovLyBtaW50QXNhKHN0cmluZyxzdHJpbmcpdm9pZAoqYWJpX3JvdXRlX21pbnRBc2E6CgkvLyB1cmw6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyBuZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBtaW50QXNhKHN0cmluZyxzdHJpbmcpdm9pZAoJY2FsbHN1YiBtaW50QXNhCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBtaW50QXNhKG5mZE5hbWU6IHN0cmluZywgdXJsOiBzdHJpbmcpOiB2b2lkCm1pbnRBc2E6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE5MAoJLy8gYXNzZXJ0KGdsb2JhbHMuY2FsbGVyQXBwbGljYXRpb25JRCA9PT0gQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpLCAnY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IScpCglnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAoJaW50YyA0IC8vIFRNUExfcmVnaXN0cnlBcHBJZAoJPT0KCgkvLyBjYWxsZXIgbXVzdCBiZSBORkQgcmVnaXN0cnkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTEKCS8vIGFzc2VydCh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElORykudmFsdWUgPT09IE5GRF9NSU5USU5HX1NUQVRFX1BSRUFTQSkKCWJ5dGVjIDMgLy8gImkubWludGluZyIKCWFwcF9nbG9iYWxfZ2V0CglieXRlYyAxOSAvLyAiMSIKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTMKCS8vIGFzc2V0ID0gc2VuZEFzc2V0Q3JlYXRpb24oewoJLy8gICAgICAgICAgICAgY29uZmlnQXNzZXRVbml0TmFtZTogJ05GRCcsCgkvLyAgICAgICAgICAgICBjb25maWdBc3NldE5hbWU6IG5mZE5hbWUsCgkvLyAgICAgICAgICAgICBjb25maWdBc3NldFRvdGFsOiAxLAoJLy8gICAgICAgICAgICAgY29uZmlnQXNzZXREZWNpbWFsczogMCwKCS8vICAgICAgICAgICAgIGNvbmZpZ0Fzc2V0RGVmYXVsdEZyb3plbjogMSwKCS8vICAgICAgICAgICAgIGNvbmZpZ0Fzc2V0VVJMOiB1cmwsCgkvLyAgICAgICAgICAgICBjb25maWdBc3NldE1hbmFnZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgICAgICBjb25maWdBc3NldFJlc2VydmU6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgICAgICBjb25maWdBc3NldENsYXdiYWNrOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyA2IC8vICBhY2ZnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTk0CgkvLyBjb25maWdBc3NldFVuaXROYW1lOiAnTkZEJwoJcHVzaGJ5dGVzIDB4NGU0NjQ0IC8vICJORkQiCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTUKCS8vIGNvbmZpZ0Fzc2V0TmFtZTogbmZkTmFtZQoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJaXR4bl9maWVsZCBDb25maWdBc3NldE5hbWUKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTYKCS8vIGNvbmZpZ0Fzc2V0VG90YWw6IDEKCWludGMgMSAvLyAxCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VG90YWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTcKCS8vIGNvbmZpZ0Fzc2V0RGVjaW1hbHM6IDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVjaW1hbHMKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxOTgKCS8vIGNvbmZpZ0Fzc2V0RGVmYXVsdEZyb3plbjogMQoJaW50YyAxIC8vIDEKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXREZWZhdWx0RnJvemVuCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTk5CgkvLyBjb25maWdBc3NldFVSTDogdXJsCglmcmFtZV9kaWcgLTIgLy8gdXJsOiBzdHJpbmcKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRVUkwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMDAKCS8vIGNvbmZpZ0Fzc2V0TWFuYWdlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRNYW5hZ2VyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjAxCgkvLyBjb25maWdBc3NldFJlc2VydmU6IHRoaXMuYXBwLmFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0UmVzZXJ2ZQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIwMgoJLy8gY29uZmlnQXNzZXRDbGF3YmFjazogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRDbGF3YmFjawoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gQ3JlYXRlZEFzc2V0SUQKCWZyYW1lX2J1cnkgMCAvLyBhc3NldDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjA0CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQVNBSUQpLnZhbHVlID0gaXRvYihhc3NldC5pZCkKCWJ5dGVjIDE4IC8vICJpLmFzYWlkIgoJZnJhbWVfZGlnIDAgLy8gYXNzZXQ6IHVpbnQ2NAoJaXRvYgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMDUKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS52YWx1ZSA9IE5GRF9NSU5USU5HX1NUQVRFX1BPU1RBU0EKCWJ5dGVjIDMgLy8gImkubWludGluZyIKCWJ5dGVjIDMwIC8vICIyIgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMDYKCS8vIGxvZyhpdG9iKGFzc2V0LmlkKSkKCWZyYW1lX2RpZyAwIC8vIGFzc2V0OiB1aW50NjQKCWl0b2IKCWxvZwoJcmV0c3ViCgovLyBkZWxldGVGaWVsZHMoYnl0ZVtdW10pdm9pZAoqYWJpX3JvdXRlX2RlbGV0ZUZpZWxkczoKCS8vIGZpZWxkTmFtZXM6IGJ5dGVbXVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCgoJLy8gZXhlY3V0ZSBkZWxldGVGaWVsZHMoYnl0ZVtdW10pdm9pZAoJY2FsbHN1YiBkZWxldGVGaWVsZHMKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGRlbGV0ZUZpZWxkcyhmaWVsZE5hbWVzOiBieXRlc1tdKTogdm9pZApkZWxldGVGaWVsZHM6Cglwcm90byAxIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiA0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjE0CgkvLyBhc3NlcnQoIXRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS5leGlzdHMpCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMTUKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FQ0hBTkdFRCkudmFsdWUgPSBpdG9iKGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wKQoJYnl0ZWMgMiAvLyAiaS50aW1lQ2hhbmdlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjE3CgkvLyBhZG1pblJpZ2h0cyA9IHRoaXMuaXNDdXJyZW50VHhuQ29udHJhY3RBdXRob3JpdHkoKQoJY2FsbHN1YiBpc0N1cnJlbnRUeG5Db250cmFjdEF1dGhvcml0eQoJZnJhbWVfYnVyeSAwIC8vIGFkbWluUmlnaHRzOiBib29sCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjE4CgkvLyBib3hDb3N0cyA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDEgLy8gYm94Q29zdHM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIxOQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCipmb3JfMDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIxOQoJLy8gaSA8IGZpZWxkTmFtZXMubGVuZ3RoCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZE5hbWVzOiBieXRlc1tdCglpbnRjIDAgLy8gMAoJZXh0cmFjdF91aW50MTYKCTwKCWJ6ICpmb3JfMF9lbmQKCgkvLyAqaWYxMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIyMAoJLy8gZ2xvYmFscy5vcGNvZGVCdWRnZXQgPCAyMDAKCWdsb2JhbCBPcGNvZGVCdWRnZXQKCWludGMgMTkgLy8gMjAwCgk8CglieiAqaWYxMl9lbmQKCgkvLyAqaWYxMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMjEKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCglieXRlYyAxNCAvLyAgI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50YyAxMyAvLyAgRGVsZXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMTJfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjIzCgkvLyBuYW1lID0gZmllbGROYW1lc1tpXQoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkTmFtZXM6IGJ5dGVzW10KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDAgLy8gIGluaXRpYWwgb2Zmc2V0CglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMiAvLyAyCgkqIC8vIGFjYyAqIDIKCSsKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglkdXAgLy8gZHVwbGljYXRlIHN0YXJ0IG9mIGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWV4dHJhY3RfdWludDE2IC8vIGdldCBudW1iZXIgb2YgZWxlbWVudHMKCWludGMgMSAvLyAgZ2V0IHR5cGUgbGVuZ3RoCgkqIC8vIG11bHRpcGx5IGJ5IHR5cGUgbGVuZ3RoCglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWV4dHJhY3QzCglleHRyYWN0IDIgMAoJZnJhbWVfYnVyeSAzIC8vIG5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIyNAoJLy8gYXNzZXJ0KHRoaXMuaXNGaWVsZERlbGV0ZUFsbG93ZWQobmFtZSwgYWRtaW5SaWdodHMpLCAnZmllbGQgbm90IHJlbW92YWJsZSBvciBubyBwZXJtaXNzaW9ucyB0byByZW1vdmUnKQoJZnJhbWVfZGlnIDAgLy8gYWRtaW5SaWdodHM6IGJvb2wKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ZpZWxkRGVsZXRlQWxsb3dlZAoKCS8vIGZpZWxkIG5vdCByZW1vdmFibGUgb3Igbm8gcGVybWlzc2lvbnMgdG8gcmVtb3ZlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMjUKCS8vIGJveFNpemUgPSB0aGlzLmJveGVzKG5hbWUpLnNpemUKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2xlbgoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhuYW1lKS5zaXplCglhc3NlcnQKCWZyYW1lX2J1cnkgNCAvLyBib3hTaXplOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMjYKCS8vIHRoaXMuYm94ZXMobmFtZSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIyNwoJLy8gYm94Q29zdHMgKz0gU0NCT1hfUEVSQk9YICsgKG5hbWUubGVuZ3RoICsgYm94U2l6ZSkgKiBTQ0JPWF9QRVJCWVRFCglmcmFtZV9kaWcgMSAvLyBib3hDb3N0czogdWludDY0CglpbnRjIDEyIC8vIDI1MDAKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJbGVuCglmcmFtZV9kaWcgNCAvLyBib3hTaXplOiB1aW50NjQKCSsKCWludGMgOSAvLyA0MDAKCSoKCSsKCSsKCWZyYW1lX2J1cnkgMSAvLyBib3hDb3N0czogdWludDY0CgoqZm9yXzBfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyMTkKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzAKCipmb3JfMF9lbmQ6CgkvLyAqaWYxM19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIyOQoJLy8gYm94Q29zdHMgPiAwCglmcmFtZV9kaWcgMSAvLyBib3hDb3N0czogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJYnogKmlmMTNfZW5kCgoJLy8gKmlmMTNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjMwCgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICAgICAgYW1vdW50OiBib3hDb3N0cywKCS8vICAgICAgICAgICAgICAgICByZWNlaXZlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgICAgICAgICAgIG5vdGU6ICdib3hSZWZ1bmQnLAoJLy8gICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjMxCgkvLyBhbW91bnQ6IGJveENvc3RzCglmcmFtZV9kaWcgMSAvLyBib3hDb3N0czogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIzMgoJLy8gcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlcgoJdHhuIFNlbmRlcgoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIzMwoJLy8gbm90ZTogJ2JveFJlZnVuZCcKCWJ5dGVjIDMxIC8vICAiYm94UmVmdW5kIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMTNfZW5kOgoJcmV0c3ViCgovLyBkZWxldGVGaWVsZHNGcm9tQXJncygpOiB2b2lkCmRlbGV0ZUZpZWxkc0Zyb21BcmdzOgoJcHJvdG8gMCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gMgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjIzOQoJLy8gYXNzZXJ0KCF0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElORykuZXhpc3RzKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjQxCgkvLyBhZG1pblJpZ2h0cyA9IHRoaXMuaXNDdXJyZW50VHhuQ29udHJhY3RBdXRob3JpdHkoKQoJY2FsbHN1YiBpc0N1cnJlbnRUeG5Db250cmFjdEF1dGhvcml0eQoJZnJhbWVfYnVyeSAwIC8vIGFkbWluUmlnaHRzOiBib29sCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjQyCgkvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAxOyBpIDwgdGhpcy50eG4ubnVtQXBwQXJnczsgaSArPSAxKQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCipmb3JfMToKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI0MgoJLy8gaSA8IHRoaXMudHhuLm51bUFwcEFyZ3MKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJdHhuIE51bUFwcEFyZ3MKCTwKCWJ6ICpmb3JfMV9lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNDMKCS8vIG5hbWUgPSB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhW2ldIGFzIGJ5dGVzCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCXR4bmFzIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfYnVyeSAyIC8vIG5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI0NAoJLy8gYXNzZXJ0KHRoaXMuaXNGaWVsZERlbGV0ZUFsbG93ZWQobmFtZSwgYWRtaW5SaWdodHMpLCAnZmllbGQgbm90IHJlbW92YWJsZSBvciBubyBwZXJtaXNzaW9ucyB0byByZW1vdmUnKQoJZnJhbWVfZGlnIDAgLy8gYWRtaW5SaWdodHM6IGJvb2wKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ZpZWxkRGVsZXRlQWxsb3dlZAoKCS8vIGZpZWxkIG5vdCByZW1vdmFibGUgb3Igbm8gcGVybWlzc2lvbnMgdG8gcmVtb3ZlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNDUKCS8vIHRoaXMuYm94ZXMobmFtZSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2RlbAoKKmZvcl8xX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjQyCgkvLyBpICs9IDEKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgKmZvcl8xCgoqZm9yXzFfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjQ3CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyB1cGRhdGVTZWdtZW50Q291bnQoc3RyaW5nLHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfdXBkYXRlU2VnbWVudENvdW50OgoJLy8gY2hpbGROZmRBcHBJRDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gY2hpbGROZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSB1cGRhdGVTZWdtZW50Q291bnQoc3RyaW5nLHVpbnQ2NCl2b2lkCgljYWxsc3ViIHVwZGF0ZVNlZ21lbnRDb3VudAoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gdXBkYXRlU2VnbWVudENvdW50KGNoaWxkTmZkTmFtZTogc3RyaW5nLCBjaGlsZE5mZEFwcElEOiB1aW50NjQpOiB2b2lkCnVwZGF0ZVNlZ21lbnRDb3VudDoKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNTgKCS8vIGFzc2VydChnbG9iYWxzLmNhbGxlckFwcGxpY2F0aW9uSUQgPT09IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKSwgJ2NhbGxlciBtdXN0IGJlIE5GRCByZWdpc3RyeSEnKQoJZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uSUQKCWludGMgNCAvLyBUTVBMX3JlZ2lzdHJ5QXBwSWQKCT09CgoJLy8gY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjU5CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICB0aGlzLnNhZmVHbG9iYWxCeXRlR2V0RXgoY2hpbGROZmRBcHBJRCwgTkZEX0tFWV9NSU5USU5HKSA9PT0gTkZEX01JTlRJTkdfU1RBVEVfUE9TVEFTQSwKCS8vICAgICAgICAgICAgICdjaGlsZCBORkQgTVVTVCBzdGlsbCBiZSBpbiBwcmUtY2xhaW0gc3RhdGUhJywKCS8vICAgICAgICAgKQoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJZnJhbWVfZGlnIC0yIC8vIGNoaWxkTmZkQXBwSUQ6IHVpbnQ2NAoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldEV4CglieXRlYyAzMCAvLyAiMiIKCT09CgoJLy8gY2hpbGQgTkZEIE1VU1Qgc3RpbGwgYmUgaW4gcHJlLWNsYWltIHN0YXRlIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjYzCgkvLyBhc3NlcnQoIXRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS5leGlzdHMpCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNjQKCS8vIHRoaXMubm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIG5vdEZvclNhbGVPckV4cGlyZWQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNjYKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXRFeChjaGlsZE5mZEFwcElELCBORkRfS0VZX05BTUUpID09PSBjaGlsZE5mZE5hbWUsCgkvLyAgICAgICAgICAgICAncGFzc2VkIGluIGNoaWxkIG5hbWUgbXVzdCBtYXRjaCBuYW1lIGluIGNyZWF0ZWQgbmZkIHN0YXRlJywKCS8vICAgICAgICAgKQoJYnl0ZWMgNCAvLyAiaS5uYW1lIgoJZnJhbWVfZGlnIC0yIC8vIGNoaWxkTmZkQXBwSUQ6IHVpbnQ2NAoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldEV4CglmcmFtZV9kaWcgLTEgLy8gY2hpbGROZmROYW1lOiBzdHJpbmcKCT09CgoJLy8gcGFzc2VkIGluIGNoaWxkIG5hbWUgbXVzdCBtYXRjaCBuYW1lIGluIGNyZWF0ZWQgbmZkIHN0YXRlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNzAKCS8vIHRoaXNQYXJlbnROYW1lID0gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlCglieXRlYyA0IC8vICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSAwIC8vIHRoaXNQYXJlbnROYW1lOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyNzUKCS8vIGluZGV4Q2hlY2tTdG9wID0gbGVuKGNoaWxkTmZkTmFtZSkgLSBsZW4odGhpc1BhcmVudE5hbWUpIC0gMQoJZnJhbWVfZGlnIC0xIC8vIGNoaWxkTmZkTmFtZTogc3RyaW5nCglsZW4KCWZyYW1lX2RpZyAwIC8vIHRoaXNQYXJlbnROYW1lOiBieXRlW10KCWxlbgoJLQoJaW50YyAxIC8vIDEKCS0KCWZyYW1lX2J1cnkgMSAvLyBpbmRleENoZWNrU3RvcDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mjc2CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICBleHRyYWN0MyhjaGlsZE5mZE5hbWUsIGluZGV4Q2hlY2tTdG9wLCBsZW4odGhpc1BhcmVudE5hbWUpICsgMSkgPT09ICcuJyArIHRoaXNQYXJlbnROYW1lLAoJLy8gICAgICAgICAgICAgJ3BhcmVudCBtdXN0IGJlIHN1ZmZpeCBvZiBjaGlsZCcsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAtMSAvLyBjaGlsZE5mZE5hbWU6IHN0cmluZwoJZnJhbWVfZGlnIDEgLy8gaW5kZXhDaGVja1N0b3A6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gdGhpc1BhcmVudE5hbWU6IGJ5dGVbXQoJbGVuCglpbnRjIDEgLy8gMQoJKwoJZXh0cmFjdDMKCWJ5dGVjIDI4IC8vICAiLiIKCWZyYW1lX2RpZyAwIC8vIHRoaXNQYXJlbnROYW1lOiBieXRlW10KCWNvbmNhdAoJPT0KCgkvLyBwYXJlbnQgbXVzdCBiZSBzdWZmaXggb2YgY2hpbGQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI4MAoJLy8gYXNzZXJ0KHRoaXMubm9QZXJpb2RCZWZvcmVJbmRleChjaGlsZE5mZE5hbWUsIGluZGV4Q2hlY2tTdG9wKSkKCWZyYW1lX2RpZyAxIC8vIGluZGV4Q2hlY2tTdG9wOiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBjaGlsZE5mZE5hbWU6IHN0cmluZwoJY2FsbHN1YiBub1BlcmlvZEJlZm9yZUluZGV4Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyODEKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UQ09VTlQpLnZhbHVlID0gaXRvYih0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9TRUdNRU5UQ09VTlQpICsgMSkKCWJ5dGVjIDM1IC8vICJpLnNlZ21lbnRDb3VudCIKCWR1cAoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglpbnRjIDEgLy8gMQoJKwoJaXRvYgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyODIKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FQ0hBTkdFRCkudmFsdWUgPSBpdG9iKGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wKQoJYnl0ZWMgMiAvLyAiaS50aW1lQ2hhbmdlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdldEZpZWxkVXBkYXRlQ29zdChieXRlW11bXSl1aW50NjQKKmFiaV9yb3V0ZV9nZXRGaWVsZFVwZGF0ZUNvc3Q6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDExIC8vIDB4MTUxZjdjNzUKCgkvLyBmaWVsZEFuZFZhbHM6IGJ5dGVbXVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCgoJLy8gZXhlY3V0ZSBnZXRGaWVsZFVwZGF0ZUNvc3QoYnl0ZVtdW10pdWludDY0CgljYWxsc3ViIGdldEZpZWxkVXBkYXRlQ29zdAoJaXRvYgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldEZpZWxkVXBkYXRlQ29zdChmaWVsZEFuZFZhbHM6IGJ5dGVzW10pOiB1aW50NjQKZ2V0RmllbGRVcGRhdGVDb3N0OgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gNgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI4NwoJLy8gY29zdCA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDAgLy8gY29zdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mjg4CgkvLyByZW1vdmVkQ29zdCA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDEgLy8gcmVtb3ZlZENvc3Q6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI5MAoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZEFuZFZhbHMubGVuZ3RoOyBpICs9IDIpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoKKmZvcl8yOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjkwCgkvLyBpIDwgZmllbGRBbmRWYWxzLmxlbmd0aAoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gZmllbGRBbmRWYWxzOiBieXRlc1tdCglpbnRjIDAgLy8gMAoJZXh0cmFjdF91aW50MTYKCTwKCWJ6ICpmb3JfMl9lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyOTEKCS8vIG5hbWUgPSBmaWVsZEFuZFZhbHNbaV0KCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEFuZFZhbHM6IGJ5dGVzW10KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDAgLy8gIGluaXRpYWwgb2Zmc2V0CglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMiAvLyAyCgkqIC8vIGFjYyAqIDIKCSsKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglkdXAgLy8gZHVwbGljYXRlIHN0YXJ0IG9mIGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWV4dHJhY3RfdWludDE2IC8vIGdldCBudW1iZXIgb2YgZWxlbWVudHMKCWludGMgMSAvLyAgZ2V0IHR5cGUgbGVuZ3RoCgkqIC8vIG11bHRpcGx5IGJ5IHR5cGUgbGVuZ3RoCglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWV4dHJhY3QzCglleHRyYWN0IDIgMAoJZnJhbWVfYnVyeSAzIC8vIG5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI5MgoJLy8gdmFsdWUgPSBmaWVsZEFuZFZhbHNbaSArIDFdCglmcmFtZV9kaWcgLTEgLy8gZmllbGRBbmRWYWxzOiBieXRlc1tdCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAwIC8vICBpbml0aWFsIG9mZnNldAoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJaW50YyAyIC8vIDIKCSogLy8gYWNjICogMgoJKwoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cgl1bmNvdmVyIDIKCWV4dHJhY3RfdWludDE2CglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWR1cCAvLyBkdXBsaWNhdGUgc3RhcnQgb2YgZWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJZXh0cmFjdF91aW50MTYgLy8gZ2V0IG51bWJlciBvZiBlbGVtZW50cwoJaW50YyAxIC8vICBnZXQgdHlwZSBsZW5ndGgKCSogLy8gbXVsdGlwbHkgYnkgdHlwZSBsZW5ndGgKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJZXh0cmFjdDMKCWV4dHJhY3QgMiAwCglmcmFtZV9idXJ5IDQgLy8gdmFsdWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI5MwoJLy8gZXhpc3RzID0gdGhpcy5ib3hlcyhuYW1lKS5leGlzdHMKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2xlbgoJc3dhcAoJcG9wCglmcmFtZV9idXJ5IDUgLy8gZXhpc3RzOiBib29sCgoJLy8gKmlmMTRfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoyOTUKCS8vIGxlbih2YWx1ZSkgPT09IDAKCWZyYW1lX2RpZyA0IC8vIHZhbHVlOiBieXRlW10KCWxlbgoJaW50YyAwIC8vIDAKCT09CglieiAqaWYxNF9lbmQKCgkvLyAqaWYxNF9jb25zZXF1ZW50CgkvLyAqaWYxNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI5NgoJLy8gZXhpc3RzCglmcmFtZV9kaWcgNSAvLyBleGlzdHM6IGJvb2wKCWJ6ICppZjE1X2VuZAoKCS8vICppZjE1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjI5OAoJLy8gcmVtb3ZlZENvc3QgKz0gU0NCT1hfUEVSQk9YICsgU0NCT1hfUEVSQllURSAqIChsZW4obmFtZSkgKyB0aGlzLmJveGVzKG5hbWUpLnNpemUpCglmcmFtZV9kaWcgMSAvLyByZW1vdmVkQ29zdDogdWludDY0CglpbnRjIDEyIC8vIDI1MDAKCWludGMgOSAvLyA0MDAKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJbGVuCglmcmFtZV9kaWcgMyAvLyBuYW1lOiBieXRlW10KCWJveF9sZW4KCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMobmFtZSkuc2l6ZQoJYXNzZXJ0CgkrCgkqCgkrCgkrCglmcmFtZV9idXJ5IDEgLy8gcmVtb3ZlZENvc3Q6IHVpbnQ2NAoKKmlmMTVfZW5kOgoJYiAqZm9yXzJfY29udGludWUKCippZjE0X2VuZDoKCS8vICppZjE2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzAyCgkvLyAhZXhpc3RzCglmcmFtZV9kaWcgNSAvLyBleGlzdHM6IGJvb2wKCSEKCWJ6ICppZjE2X2VuZAoKCS8vICppZjE2X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjMwNAoJLy8gY29zdCArPSBTQ0JPWF9QRVJCT1ggKyBTQ0JPWF9QRVJCWVRFICogKGxlbihuYW1lKSArIGxlbih2YWx1ZSkpCglmcmFtZV9kaWcgMCAvLyBjb3N0OiB1aW50NjQKCWludGMgMTIgLy8gMjUwMAoJaW50YyA5IC8vIDQwMAoJZnJhbWVfZGlnIDMgLy8gbmFtZTogYnl0ZVtdCglsZW4KCWZyYW1lX2RpZyA0IC8vIHZhbHVlOiBieXRlW10KCWxlbgoJKwoJKgoJKwoJKwoJZnJhbWVfYnVyeSAwIC8vIGNvc3Q6IHVpbnQ2NAoJYiAqZm9yXzJfY29udGludWUKCippZjE2X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjMwNwoJLy8gZXhpc3RpbmdMZW5ndGggPSB0aGlzLmJveGVzKG5hbWUpLnNpemUKCWZyYW1lX2RpZyAzIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2xlbgoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhuYW1lKS5zaXplCglhc3NlcnQKCWZyYW1lX2J1cnkgNiAvLyBleGlzdGluZ0xlbmd0aDogdWludDY0CgoJLy8gKmlmMTdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMDgKCS8vIGxlbih2YWx1ZSkgPD0gZXhpc3RpbmdMZW5ndGgKCWZyYW1lX2RpZyA0IC8vIHZhbHVlOiBieXRlW10KCWxlbgoJZnJhbWVfZGlnIDYgLy8gZXhpc3RpbmdMZW5ndGg6IHVpbnQ2NAoJPD0KCWJ6ICppZjE3X2Vsc2UKCgkvLyAqaWYxN19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMDkKCS8vIHJlbW92ZWRDb3N0ICs9IFNDQk9YX1BFUkJZVEUgKiAoZXhpc3RpbmdMZW5ndGggLSBsZW4odmFsdWUpKQoJZnJhbWVfZGlnIDEgLy8gcmVtb3ZlZENvc3Q6IHVpbnQ2NAoJaW50YyA5IC8vIDQwMAoJZnJhbWVfZGlnIDYgLy8gZXhpc3RpbmdMZW5ndGg6IHVpbnQ2NAoJZnJhbWVfZGlnIDQgLy8gdmFsdWU6IGJ5dGVbXQoJbGVuCgktCgkqCgkrCglmcmFtZV9idXJ5IDEgLy8gcmVtb3ZlZENvc3Q6IHVpbnQ2NAoJYiAqaWYxN19lbmQKCippZjE3X2Vsc2U6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMTEKCS8vIGNvc3QgKz0gU0NCT1hfUEVSQllURSAqIChsZW4odmFsdWUpIC0gZXhpc3RpbmdMZW5ndGgpCglmcmFtZV9kaWcgMCAvLyBjb3N0OiB1aW50NjQKCWludGMgOSAvLyA0MDAKCWZyYW1lX2RpZyA0IC8vIHZhbHVlOiBieXRlW10KCWxlbgoJZnJhbWVfZGlnIDYgLy8gZXhpc3RpbmdMZW5ndGg6IHVpbnQ2NAoJLQoJKgoJKwoJZnJhbWVfYnVyeSAwIC8vIGNvc3Q6IHVpbnQ2NAoKKmlmMTdfZW5kOgoKKmZvcl8yX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MjkwCgkvLyBpICs9IDIKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAyIC8vIDIKCSsKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCWIgKmZvcl8yCgoqZm9yXzJfZW5kOgoJLy8gKmlmMThfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMTUKCS8vIHJlbW92ZWRDb3N0ID4gY29zdAoJZnJhbWVfZGlnIDEgLy8gcmVtb3ZlZENvc3Q6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gY29zdDogdWludDY0Cgk+CglieiAqaWYxOF9lbmQKCgkvLyAqaWYxOF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMTYKCS8vIHJldHVybiAwCglpbnRjIDAgLy8gMAoJYiAqZ2V0RmllbGRVcGRhdGVDb3N0KnJldHVybgoKKmlmMThfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzE4CgkvLyByZXR1cm4gY29zdCAtIHJlbW92ZWRDb3N0CglmcmFtZV9kaWcgMCAvLyBjb3N0OiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIHJlbW92ZWRDb3N0OiB1aW50NjQKCS0KCipnZXRGaWVsZFVwZGF0ZUNvc3QqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNgoJcmV0c3ViCgovLyB1cGRhdGVGaWVsZHMoYnl0ZVtdW10pdm9pZAoqYWJpX3JvdXRlX3VwZGF0ZUZpZWxkczoKCS8vIGZpZWxkQW5kVmFsczogYnl0ZVtdW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCgkvLyBleGVjdXRlIHVwZGF0ZUZpZWxkcyhieXRlW11bXSl2b2lkCgljYWxsc3ViIHVwZGF0ZUZpZWxkcwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gdXBkYXRlRmllbGRzKGZpZWxkQW5kVmFsczogYnl0ZXNbXSk6IHZvaWQKdXBkYXRlRmllbGRzOgoJcHJvdG8gMSAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gMwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjMyMgoJLy8gYXNzZXJ0KCF0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElORykuZXhpc3RzKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzIzCgkvLyBhc3NlcnQoIXRoaXMuaXNFeHBpcmVkKCksICJjYW4ndCB1cGRhdGUgZmllbGRzIGlmIE5GRCBleHBpcmVkIikKCWNhbGxzdWIgaXNFeHBpcmVkCgkhCgoJLy8gY2FuJ3QgdXBkYXRlIGZpZWxkcyBpZiBORkQgZXhwaXJlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzI1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vICppZjE5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzI4CgkvLyBnbG9iYWxzLmNhbGxlckFwcGxpY2F0aW9uSUQgPT09IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKQoJZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uSUQKCWludGMgNCAvLyBUTVBMX3JlZ2lzdHJ5QXBwSWQKCT09CglieiAqaWYxOV9lbmQKCgkvLyAqaWYxOV9jb25zZXF1ZW50CgkvLyAqaWYyMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjMyOQoJLy8gZmllbGRBbmRWYWxzLmxlbmd0aCA9PT0gMiAmJiBmaWVsZEFuZFZhbHNbMF0gPT09IE5GRF9GSUVMRF9DQV9UT19WRVJJRlkKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEFuZFZhbHM6IGJ5dGVzW10KCWludGMgMCAvLyAwCglleHRyYWN0X3VpbnQxNgoJaW50YyAyIC8vIDIKCT09CglkdXAKCWJ6ICpza2lwX2FuZDkKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEFuZFZhbHM6IGJ5dGVzW10KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDIgLy8gMgoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglkdXAgLy8gZHVwbGljYXRlIHN0YXJ0IG9mIGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWV4dHJhY3RfdWludDE2IC8vIGdldCBudW1iZXIgb2YgZWxlbWVudHMKCWludGMgMSAvLyAgZ2V0IHR5cGUgbGVuZ3RoCgkqIC8vIG11bHRpcGx5IGJ5IHR5cGUgbGVuZ3RoCglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWV4dHJhY3QzCglleHRyYWN0IDIgMAoJcHVzaGJ5dGVzICJ1LmNhdi5hbGdvLmEiCgk9PQoJJiYKCipza2lwX2FuZDk6CglieiAqaWYyMF9lbmQKCgkvLyAqaWYyMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMzAKCS8vIHRoaXMuYm94ZXMoZmllbGRBbmRWYWxzWzBdKS52YWx1ZSA9IGZpZWxkQW5kVmFsc1sxXQoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkQW5kVmFsczogYnl0ZXNbXQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMiAvLyAyCglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cgl1bmNvdmVyIDIKCWV4dHJhY3RfdWludDE2CglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWR1cCAvLyBkdXBsaWNhdGUgc3RhcnQgb2YgZWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJZXh0cmFjdF91aW50MTYgLy8gZ2V0IG51bWJlciBvZiBlbGVtZW50cwoJaW50YyAxIC8vICBnZXQgdHlwZSBsZW5ndGgKCSogLy8gbXVsdGlwbHkgYnkgdHlwZSBsZW5ndGgKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJZXh0cmFjdDMKCWV4dHJhY3QgMiAwCglmcmFtZV9kaWcgLTEgLy8gZmllbGRBbmRWYWxzOiBieXRlc1tdCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAxMCAvLyA0Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cgl1bmNvdmVyIDIKCWV4dHJhY3RfdWludDE2CglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWR1cCAvLyBkdXBsaWNhdGUgc3RhcnQgb2YgZWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJZXh0cmFjdF91aW50MTYgLy8gZ2V0IG51bWJlciBvZiBlbGVtZW50cwoJaW50YyAxIC8vICBnZXQgdHlwZSBsZW5ndGgKCSogLy8gbXVsdGlwbHkgYnkgdHlwZSBsZW5ndGgKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJZXh0cmFjdDMKCWV4dHJhY3QgMiAwCglib3hfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzMxCgkvLyByZXR1cm4KCXJldHN1YgoKKmlmMjBfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzMzCgkvLyBhc3NlcnQoZmFsc2UsICdpbnZhbGlkIHVwZGF0ZSBjYWxsIGJ5IHJlZ2lzdHJ5JykKCWludGMgMCAvLyAwCgoJLy8gaW52YWxpZCB1cGRhdGUgY2FsbCBieSByZWdpc3RyeQoJYXNzZXJ0CgoqaWYxOV9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMzYKCS8vIGFkbWluUmlnaHRzID0gdGhpcy5pc0N1cnJlbnRUeG5Db250cmFjdEF1dGhvcml0eSgpCgljYWxsc3ViIGlzQ3VycmVudFR4bkNvbnRyYWN0QXV0aG9yaXR5CglmcmFtZV9idXJ5IDAgLy8gYWRtaW5SaWdodHM6IGJvb2wKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMzcKCS8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBmaWVsZEFuZFZhbHMubGVuZ3RoOyBpICs9IDIpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoKKmZvcl8zOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzM3CgkvLyBpIDwgZmllbGRBbmRWYWxzLmxlbmd0aAoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gZmllbGRBbmRWYWxzOiBieXRlc1tdCglpbnRjIDAgLy8gMAoJZXh0cmFjdF91aW50MTYKCTwKCWJ6ICpmb3JfM19lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozMzgKCS8vIG5hbWUgPSBmaWVsZEFuZFZhbHNbaV0KCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEFuZFZhbHM6IGJ5dGVzW10KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDAgLy8gIGluaXRpYWwgb2Zmc2V0CglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgMiAvLyAyCgkqIC8vIGFjYyAqIDIKCSsKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglkdXAgLy8gZHVwbGljYXRlIHN0YXJ0IG9mIGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWV4dHJhY3RfdWludDE2IC8vIGdldCBudW1iZXIgb2YgZWxlbWVudHMKCWludGMgMSAvLyAgZ2V0IHR5cGUgbGVuZ3RoCgkqIC8vIG11bHRpcGx5IGJ5IHR5cGUgbGVuZ3RoCglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWV4dHJhY3QzCglleHRyYWN0IDIgMAoJZnJhbWVfYnVyeSAyIC8vIG5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjMzOQoJLy8gdmFsdWUgPSBmaWVsZEFuZFZhbHNbaSArIDFdCglmcmFtZV9kaWcgLTEgLy8gZmllbGRBbmRWYWxzOiBieXRlc1tdCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAwIC8vICBpbml0aWFsIG9mZnNldAoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJaW50YyAyIC8vIDIKCSogLy8gYWNjICogMgoJKwoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cgl1bmNvdmVyIDIKCWV4dHJhY3RfdWludDE2CglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWR1cCAvLyBkdXBsaWNhdGUgc3RhcnQgb2YgZWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJZXh0cmFjdF91aW50MTYgLy8gZ2V0IG51bWJlciBvZiBlbGVtZW50cwoJaW50YyAxIC8vICBnZXQgdHlwZSBsZW5ndGgKCSogLy8gbXVsdGlwbHkgYnkgdHlwZSBsZW5ndGgKCWludGMgMiAvLyAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJZXh0cmFjdDMKCWV4dHJhY3QgMiAwCglmcmFtZV9idXJ5IDMgLy8gdmFsdWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM0MAoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHRoaXMuaXNGaWVsZFVwZGF0ZUFsbG93ZWQobmFtZSwgdmFsdWUsIGFkbWluUmlnaHRzKSwKCS8vICAgICAgICAgICAgICAgICAnZmllbGQgbm90IHVwZGF0YWJsZSBvciBubyBwZXJtaXNzaW9ucyB0byB1cGRhdGUnLAoJLy8gICAgICAgICAgICAgKQoJZnJhbWVfZGlnIDAgLy8gYWRtaW5SaWdodHM6IGJvb2wKCWZyYW1lX2RpZyAzIC8vIHZhbHVlOiBieXRlW10KCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ZpZWxkVXBkYXRlQWxsb3dlZAoKCS8vIGZpZWxkIG5vdCB1cGRhdGFibGUgb3Igbm8gcGVybWlzc2lvbnMgdG8gdXBkYXRlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozNDQKCS8vIHRoaXMuYm94ZXMobmFtZSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2RlbAoKCS8vICppZjIxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzQ1CgkvLyBsZW4odmFsdWUpID4gMAoJZnJhbWVfZGlnIDMgLy8gdmFsdWU6IGJ5dGVbXQoJbGVuCglpbnRjIDAgLy8gMAoJPgoJYnogKmlmMjFfZW5kCgoJLy8gKmlmMjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzQ2CgkvLyB0aGlzLmJveGVzKG5hbWUpLnZhbHVlID0gdmFsdWUKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJZnJhbWVfZGlnIDMgLy8gdmFsdWU6IGJ5dGVbXQoJYm94X3B1dAoKKmlmMjFfZW5kOgoKKmZvcl8zX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzM3CgkvLyBpICs9IDIKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyAyIC8vIDIKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgKmZvcl8zCgoqZm9yXzNfZW5kOgoJcmV0c3ViCgovLyB1cGRhdGVGaWVsZHNGcm9tQXJncygpOiB2b2lkCnVwZGF0ZUZpZWxkc0Zyb21BcmdzOgoJcHJvdG8gMCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gMwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM1MgoJLy8gYXNzZXJ0KCF0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElORykuZXhpc3RzKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzUzCgkvLyBhc3NlcnQoIXRoaXMuaXNFeHBpcmVkKCksICJjYW4ndCB1cGRhdGUgZmllbGRzIGlmIE5GRCBleHBpcmVkIikKCWNhbGxzdWIgaXNFeHBpcmVkCgkhCgoJLy8gY2FuJ3QgdXBkYXRlIGZpZWxkcyBpZiBORkQgZXhwaXJlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzU1CgkvLyBhZG1pblJpZ2h0cyA9IHRoaXMuaXNDdXJyZW50VHhuQ29udHJhY3RBdXRob3JpdHkoKQoJY2FsbHN1YiBpc0N1cnJlbnRUeG5Db250cmFjdEF1dGhvcml0eQoJZnJhbWVfYnVyeSAwIC8vIGFkbWluUmlnaHRzOiBib29sCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzU2CgkvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAxOyBpIDwgdGhpcy50eG4ubnVtQXBwQXJnczsgaSArPSAyKQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCipmb3JfNDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM1NgoJLy8gaSA8IHRoaXMudHhuLm51bUFwcEFyZ3MKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJdHhuIE51bUFwcEFyZ3MKCTwKCWJ6ICpmb3JfNF9lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozNTcKCS8vIG5hbWUgPSB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhW2ldIGFzIGJ5dGVzCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCXR4bmFzIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfYnVyeSAyIC8vIG5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM1OAoJLy8gdmFsdWUgPSB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhW2kgKyAxXSBhcyBieXRlcwoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJdHhuYXMgQXBwbGljYXRpb25BcmdzCglmcmFtZV9idXJ5IDMgLy8gdmFsdWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM1OQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHRoaXMuaXNGaWVsZFVwZGF0ZUFsbG93ZWQobmFtZSwgdmFsdWUsIGFkbWluUmlnaHRzKSwKCS8vICAgICAgICAgICAgICAgICAnZmllbGQgbm90IHVwZGF0YWJsZSBvciBubyBwZXJtaXNzaW9ucyB0byB1cGRhdGUnLAoJLy8gICAgICAgICAgICAgKQoJZnJhbWVfZGlnIDAgLy8gYWRtaW5SaWdodHM6IGJvb2wKCWZyYW1lX2RpZyAzIC8vIHZhbHVlOiBieXRlW10KCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ZpZWxkVXBkYXRlQWxsb3dlZAoKCS8vIGZpZWxkIG5vdCB1cGRhdGFibGUgb3Igbm8gcGVybWlzc2lvbnMgdG8gdXBkYXRlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozNjMKCS8vIHRoaXMuYm94ZXMobmFtZSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJYm94X2RlbAoKCS8vICppZjIyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzY0CgkvLyBsZW4odmFsdWUpID4gMAoJZnJhbWVfZGlnIDMgLy8gdmFsdWU6IGJ5dGVbXQoJbGVuCglpbnRjIDAgLy8gMAoJPgoJYnogKmlmMjJfZW5kCgoJLy8gKmlmMjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzY1CgkvLyB0aGlzLmJveGVzKG5hbWUpLnZhbHVlID0gdmFsdWUKCWZyYW1lX2RpZyAyIC8vIG5hbWU6IGJ5dGVbXQoJZnJhbWVfZGlnIDMgLy8gdmFsdWU6IGJ5dGVbXQoJYm94X3B1dAoKKmlmMjJfZW5kOgoKKmZvcl80X2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzU2CgkvLyBpICs9IDIKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyAyIC8vIDIKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgKmZvcl80CgoqZm9yXzRfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzY4CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyByZWFkRmllbGQoYnl0ZVtdKWJ5dGVbXQoqYWJpX3JvdXRlX3JlYWRGaWVsZDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMTEgLy8gMHgxNTFmN2M3NQoKCS8vIGZpZWxkTmFtZTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgcmVhZEZpZWxkKGJ5dGVbXSlieXRlW10KCWNhbGxzdWIgcmVhZEZpZWxkCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHJlYWRGaWVsZChmaWVsZE5hbWU6IGJ5dGVzKTogYnl0ZXMKcmVhZEZpZWxkOgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gNAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM3NAoJLy8gdHJ1c3RUeXBlID0gZXh0cmFjdDMoZmllbGROYW1lLCAwLCAyKQoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkTmFtZTogYnl0ZXMKCWV4dHJhY3QgMCAyCglmcmFtZV9idXJ5IDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCgkvLyAqaWYyM19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM3NgoJLy8gdGhpcy5pc0ludGVybmFsRmllbGQodHJ1c3RUeXBlKQoJZnJhbWVfZGlnIDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCWNhbGxzdWIgaXNJbnRlcm5hbEZpZWxkCglieiAqaWYyM19lbmQKCgkvLyAqaWYyM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozNzcKCS8vIHJldHVybiB0aGlzLnNhZmVHbG9iYWxCeXRlR2V0KGZpZWxkTmFtZSkKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZE5hbWU6IGJ5dGVzCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CgliICpyZWFkRmllbGQqcmV0dXJuCgoqaWYyM19lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozNzkKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIHRoaXMuaXNVc2VyRmllbGQodHJ1c3RUeXBlKSB8fCB0aGlzLmlzVmVyaWZpZWRGaWVsZCh0cnVzdFR5cGUpLAoJLy8gICAgICAgICAgICAgJ211c3QgYmUgdXNlci1kZWZpbmVkIG9yIHZlcmlmaWVkIGZpZWxkIHRvIGZldGNoJywKCS8vICAgICAgICAgKQoJZnJhbWVfZGlnIDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCWNhbGxzdWIgaXNVc2VyRmllbGQKCWR1cAoJYm56ICpza2lwX29yMAoJZnJhbWVfZGlnIDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCWNhbGxzdWIgaXNWZXJpZmllZEZpZWxkCgl8fAoKKnNraXBfb3IwOgoJLy8gbXVzdCBiZSB1c2VyLWRlZmluZWQgb3IgdmVyaWZpZWQgZmllbGQgdG8gZmV0Y2gKCWFzc2VydAoKCS8vICppZjI0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MzgzCgkvLyB0aGlzLmJveGVzKGZpZWxkTmFtZSkuZXhpc3RzCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBieXRlcwoJYm94X2xlbgoJc3dhcAoJcG9wCglieiAqaWYyNF9lbmQKCgkvLyAqaWYyNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozODQKCS8vIHJldHVybiB0aGlzLmJveGVzKGZpZWxkTmFtZSkudmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZE5hbWU6IGJ5dGVzCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGZpZWxkTmFtZSkudmFsdWUKCWFzc2VydAoJYiAqcmVhZEZpZWxkKnJldHVybgoKKmlmMjRfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mzg3CgkvLyBib3hOYW1lID0gZmllbGROYW1lICsgJ18wMCcKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZE5hbWU6IGJ5dGVzCglwdXNoYnl0ZXMgMHg1ZjMwMzAgLy8gIl8wMCIKCWNvbmNhdAoJZnJhbWVfYnVyeSAxIC8vIGJveE5hbWU6IGJ5dGVbXQoKCS8vICppZjI1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mzg4CgkvLyAhdGhpcy5ib3hlcyhib3hOYW1lKS5leGlzdHMKCWZyYW1lX2RpZyAxIC8vIGJveE5hbWU6IGJ5dGVbXQoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglieiAqaWYyNV9lbmQKCgkvLyAqaWYyNV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozODkKCS8vIHJldHVybiAnJwoJYnl0ZWMgMCAvLyAgIiIKCWIgKnJlYWRGaWVsZCpyZXR1cm4KCippZjI1X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjM5MgoJLy8gcmV0VmFsdWUgPSB0aGlzLmJveGVzKGJveE5hbWUpLnZhbHVlIGFzIGJ5dGVzCglmcmFtZV9kaWcgMSAvLyBib3hOYW1lOiBieXRlW10KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoYm94TmFtZSkudmFsdWUKCWFzc2VydAoJZnJhbWVfYnVyeSAyIC8vIHJldFZhbHVlOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozOTMKCS8vIG5hbWVQcmVmaXggPSBmaWVsZE5hbWUgKyAnXzAnCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBieXRlcwoJcHVzaGJ5dGVzIDB4NWYzMCAvLyAiXzAiCgljb25jYXQKCWZyYW1lX2J1cnkgMyAvLyBuYW1lUHJlZml4OiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozOTQKCS8vIGZvciAobGV0IGkgPSAxOyBpIDwgMTA7IGkgKz0gMSkKCWludGMgMSAvLyAxCglmcmFtZV9idXJ5IDQgLy8gaTogdWludDY0CgoqZm9yXzU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czozOTQKCS8vIGkgPCAxMAoJZnJhbWVfZGlnIDQgLy8gaTogdWludDY0CglpbnRjIDExIC8vIDEwCgk8CglieiAqZm9yXzVfZW5kCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mzk1CgkvLyBib3hOYW1lID0gbmFtZVByZWZpeCArIGkudG9TdHJpbmcoKQoJZnJhbWVfZGlnIDMgLy8gbmFtZVByZWZpeDogYnl0ZVtdCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWNhbGxzdWIgKml0b2EKCWNvbmNhdAoJZnJhbWVfYnVyeSAxIC8vIGJveE5hbWU6IGJ5dGVbXQoKCS8vICppZjI2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mzk2CgkvLyAhdGhpcy5ib3hlcyhib3hOYW1lKS5leGlzdHMKCWZyYW1lX2RpZyAxIC8vIGJveE5hbWU6IGJ5dGVbXQoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglieiAqaWYyNl9lbmQKCgkvLyAqaWYyNl9jb25zZXF1ZW50CgliICpmb3JfNV9lbmQKCippZjI2X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQwMAoJLy8gcmV0VmFsdWUgPSBjb25jYXQocmV0VmFsdWUsIHRoaXMuYm94ZXMoYm94TmFtZSkudmFsdWUpCglmcmFtZV9kaWcgMiAvLyByZXRWYWx1ZTogYnl0ZVtdCglmcmFtZV9kaWcgMSAvLyBib3hOYW1lOiBieXRlW10KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoYm94TmFtZSkudmFsdWUKCWFzc2VydAoJY29uY2F0CglmcmFtZV9idXJ5IDIgLy8gcmV0VmFsdWU6IGJ5dGVbXQoKKmZvcl81X2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Mzk0CgkvLyBpICs9IDEKCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgNCAvLyBpOiB1aW50NjQKCWIgKmZvcl81CgoqZm9yXzVfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDAyCgkvLyByZXR1cm4gcmV0VmFsdWUKCWZyYW1lX2RpZyAyIC8vIHJldFZhbHVlOiBieXRlW10KCipyZWFkRmllbGQqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNAoJcmV0c3ViCgovLyBvZmZlckZvclNhbGUodWludDY0LGFkZHJlc3Mpdm9pZAoqYWJpX3JvdXRlX29mZmVyRm9yU2FsZToKCS8vIHJlc2VydmVkRm9yOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKHJlc2VydmVkRm9yKSBmb3Igb2ZmZXJGb3JTYWxlIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBzZWxsQW1vdW50OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIG9mZmVyRm9yU2FsZSh1aW50NjQsYWRkcmVzcyl2b2lkCgljYWxsc3ViIG9mZmVyRm9yU2FsZQoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gb2ZmZXJGb3JTYWxlKHNlbGxBbW91bnQ6IHVpbnQ2NCwgcmVzZXJ2ZWRGb3I6IEFkZHJlc3MpOiB2b2lkCm9mZmVyRm9yU2FsZToKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDA4CgkvLyBhc3NlcnQoIXRoaXMuaXNFeHBpcmVkKCksICJjYW4ndCBzZWxsIGlmIE5GRCBleHBpcmVkIikKCWNhbGxzdWIgaXNFeHBpcmVkCgkhCgoJLy8gY2FuJ3Qgc2VsbCBpZiBORkQgZXhwaXJlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDA5CgkvLyBhc3NlcnQoIXRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS5leGlzdHMpCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0MTAKCS8vIHRoaXMubXVzdEJlQ2FsbGVkQnlPd25lcigpCgljYWxsc3ViIG11c3RCZUNhbGxlZEJ5T3duZXIKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0MTEKCS8vIG91ckJveENvdW50ID0gdGhpcy5hcHAuYWRkcmVzcy50b3RhbEJveGVzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RUb3RhbEJveGVzCglwb3AKCWZyYW1lX2J1cnkgMCAvLyBvdXJCb3hDb3VudDogdWludDY0CgoJLy8gKmlmMjdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0MTYKCS8vIG91ckJveENvdW50ID4gMAoJZnJhbWVfZGlnIDAgLy8gb3VyQm94Q291bnQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT4KCWJ6ICppZjI3X2VuZAoKCS8vICppZjI3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQxNwoJLy8gbG9nKCdib3ggY291bnQ6JyArIG91ckJveENvdW50LnRvU3RyaW5nKCkpCglwdXNoYnl0ZXMgMHg2MjZmNzgyMDYzNmY3NTZlNzQzYSAvLyAiYm94IGNvdW50OiIKCWZyYW1lX2RpZyAwIC8vIG91ckJveENvdW50OiB1aW50NjQKCWNhbGxzdWIgKml0b2EKCWNvbmNhdAoJbG9nCgoqaWYyN19lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0MTkKCS8vIGFzc2VydChvdXJCb3hDb3VudCA9PT0gMCwgJ2NhbiBvbmx5IGJlIHNvbGQgaWYgbm8gdXNlci1kZWZpbmVkIG9yIHZlcmlmaWVkIHByb3BlcnRpZXMgcmVtYWluJykKCWZyYW1lX2RpZyAwIC8vIG91ckJveENvdW50OiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoKCS8vIGNhbiBvbmx5IGJlIHNvbGQgaWYgbm8gdXNlci1kZWZpbmVkIG9yIHZlcmlmaWVkIHByb3BlcnRpZXMgcmVtYWluCglhc3NlcnQKCgkvLyAqaWYyOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQyMgoJLy8gbGVuKHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXQoTkZEX0tFWV9DT01NSVNTSU9OMV9BR0VOVCkpICE9PSAwCglieXRlYyA1IC8vICJpLmNvbW1pc3Npb24xQWdlbnQuYSIKCWNhbGxzdWIgc2FmZUdsb2JhbEJ5dGVHZXQKCWxlbgoJaW50YyAwIC8vIDAKCSE9CglieiAqaWYyOF9lbmQKCgkvLyAqaWYyOF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0MjMKCS8vIGFzc2VydChzZWxsQW1vdW50ID49IE5GRF9NSU5fU0VMTEFNT1VOVF9XX0NPTU1JU1NJT05TLCAnbXVzdCBiZSBzb2xkIGZvciBhdCBsZWFzdCBNSU4gYW1vdW50JykKCWZyYW1lX2RpZyAtMSAvLyBzZWxsQW1vdW50OiB1aW50NjQKCWludGMgMTUgLy8gMTAwMDAwMAoJPj0KCgkvLyBtdXN0IGJlIHNvbGQgZm9yIGF0IGxlYXN0IE1JTiBhbW91bnQKCWFzc2VydAoKKmlmMjhfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDI1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQyNwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0lTU0VHTUVOVExPQ0tFRCkudmFsdWUgPSBORkRfTE9DS0VEX1ZBTF9UUlVFCglieXRlYyAyMSAvLyAiaS5zZWdtZW50TG9ja2VkIgoJYnl0ZWMgMTkgLy8gIjEiCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQzMgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NFTExfQU1PVU5UKS52YWx1ZSA9IGl0b2Ioc2VsbEFtb3VudCkKCWJ5dGVjIDYgLy8gImkuc2VsbGFtdCIKCWZyYW1lX2RpZyAtMSAvLyBzZWxsQW1vdW50OiB1aW50NjQKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gKmlmMjlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0NDIKCS8vIHJlc2VydmVkRm9yICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzICYmIHJhd0J5dGVzKHJlc2VydmVkRm9yKSAhPT0gdGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX09XTkVSKQoJZnJhbWVfZGlnIC0yIC8vIHJlc2VydmVkRm9yOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9CglkdXAKCWJ6ICpza2lwX2FuZDEwCglmcmFtZV9kaWcgLTIgLy8gcmVzZXJ2ZWRGb3I6IEFkZHJlc3MKCWJ5dGVjIDEgLy8gImkub3duZXIuYSIKCWNhbGxzdWIgc2FmZUdsb2JhbEJ5dGVHZXQKCSE9CgkmJgoKKnNraXBfYW5kMTA6CglieiAqaWYyOV9lbHNlaWYxX2NvbmRpdGlvbgoKCS8vICppZjI5X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ0MwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1JFU0VSVkVEX09XTkVSKS52YWx1ZSA9IHJhd0J5dGVzKHJlc2VydmVkRm9yKQoJYnl0ZWMgOCAvLyAiaS5yZXNlcnZlZE93bmVyLmEiCglmcmFtZV9kaWcgLTIgLy8gcmVzZXJ2ZWRGb3I6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CgliICppZjI5X2VuZAoKKmlmMjlfZWxzZWlmMV9jb25kaXRpb246CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0NDUKCS8vIHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX01JTlRJTkdfS0lDS09GRl9BTU9VTlQpID4gMCAmJgoJLy8gICAgICAgICAgICAgc2VsbEFtb3VudCA8PSB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQU1PVU5UKQoJYnl0ZWMgMTMgLy8gImkubWludGluZ0tpY2tvZmZBbW91bnQiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCWludGMgMCAvLyAwCgk+CglkdXAKCWJ6ICpza2lwX2FuZDExCglmcmFtZV9kaWcgLTEgLy8gc2VsbEFtb3VudDogdWludDY0CglieXRlYyAxMyAvLyAiaS5taW50aW5nS2lja29mZkFtb3VudCIKCWNhbGxzdWIgc2FmZUdsb2JhbEludEdldAoJPD0KCSYmCgoqc2tpcF9hbmQxMToKCWJ6ICppZjI5X2Vsc2UKCgkvLyAqaWYyOV9lbHNlaWYxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ0OAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1JFU0VSVkVEX09XTkVSKS52YWx1ZSA9IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQ1JFQVRPUikudmFsdWUKCWJ5dGVjIDggLy8gImkucmVzZXJ2ZWRPd25lci5hIgoJYnl0ZWMgMTIgLy8gImkubWludGluZ0tpY2tvZmZDcmVhdG9yLmEiCglhcHBfZ2xvYmFsX2dldAoJYXBwX2dsb2JhbF9wdXQKCWIgKmlmMjlfZW5kCgoqaWYyOV9lbHNlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDUwCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfUkVTRVJWRURfT1dORVIpLmRlbGV0ZSgpCglieXRlYyA4IC8vICJpLnJlc2VydmVkT3duZXIuYSIKCWFwcF9nbG9iYWxfZGVsCgoqaWYyOV9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0NTMKCS8vIHRoaXMubmZkX29mZmVyRm9yU2FsZS5sb2coewoJLy8gICAgICAgICAgICAgYXBwSWQ6IHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgbmFtZTogdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgc2VsbGVyOiBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlKSwKCS8vICAgICAgICAgICAgIGFtb3VudDogc2VsbEFtb3VudCwKCS8vICAgICAgICAgICAgIHJlc2VydmVkRm9yOiByZXNlcnZlZEZvciwKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweGMyNGI1YWQ2IC8vIG5mZF9vZmZlckZvclNhbGUodWludDY0LHN0cmluZyxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzKQoJYnl0ZWMgMCAvLyAgaW5pdGlhbCBoZWFkCglieXRlYyAwIC8vICBpbml0aWFsIHRhaWwKCXB1c2hieXRlcyAweDAwNTIgLy8gaW5pdGlhbCBoZWFkIG9mZnNldAoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJYnl0ZWMgNCAvLyAiaS5uYW1lIgoJYXBwX2dsb2JhbF9nZXQKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMSAvLyBzZWxsQW1vdW50OiB1aW50NjQKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMiAvLyByZXNlcnZlZEZvcjogQWRkcmVzcwoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyBjYW5jZWxTYWxlKCl2b2lkCiphYmlfcm91dGVfY2FuY2VsU2FsZToKCS8vIGV4ZWN1dGUgY2FuY2VsU2FsZSgpdm9pZAoJY2FsbHN1YiBjYW5jZWxTYWxlCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBjYW5jZWxTYWxlKCk6IHZvaWQKY2FuY2VsU2FsZToKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ2NQoJLy8gYXNzZXJ0KCF0aGlzLmlzRXhwaXJlZCgpLCAiY2FuJ3QgdXBkYXRlIGZpZWxkcyBpZiBORkQgZXhwaXJlZCIpCgljYWxsc3ViIGlzRXhwaXJlZAoJIQoKCS8vIGNhbid0IHVwZGF0ZSBmaWVsZHMgaWYgTkZEIGV4cGlyZWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ2NgoJLy8gYXNzZXJ0KCF0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElORykuZXhpc3RzKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDY3CgkvLyBhc3NlcnQodGhpcy5pc0ZvclNhbGUoKSwgJ211c3QgYmUgZm9yIHNhbGUnKQoJY2FsbHN1YiBpc0ZvclNhbGUKCgkvLyBtdXN0IGJlIGZvciBzYWxlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0NjgKCS8vIHRoaXMubXVzdEJlQ2FsbGVkQnlPd25lcigpCgljYWxsc3ViIG11c3RCZUNhbGxlZEJ5T3duZXIKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0NjkKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMX0FNT1VOVCkuZGVsZXRlKCkKCWJ5dGVjIDYgLy8gImkuc2VsbGFtdCIKCWFwcF9nbG9iYWxfZGVsCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDcwCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfUkVTRVJWRURfT1dORVIpLmRlbGV0ZSgpCglieXRlYyA4IC8vICJpLnJlc2VydmVkT3duZXIuYSIKCWFwcF9nbG9iYWxfZGVsCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDcxCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ3MwoJLy8gdGhpcy5uZmRfc2FsZUNhbmNlbGxlZC5sb2coeyBhcHBJZDogdGhpcy5hcHAuaWQsIG5hbWU6IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9OQU1FKS52YWx1ZSB9KQoJYnl0ZWMgMzYgLy8gIG5mZF9zYWxlQ2FuY2VsbGVkKHVpbnQ2NCxzdHJpbmcpCglieXRlYyAwIC8vICBpbml0aWFsIGhlYWQKCWJ5dGVjIDAgLy8gIGluaXRpYWwgdGFpbAoJYnl0ZWMgNDEgLy8gIGluaXRpYWwgaGVhZCBvZmZzZXQKCXR4bmEgQXBwbGljYXRpb25zIDAKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWJ5dGVjIDQgLy8gImkubmFtZSIKCWFwcF9nbG9iYWxfZ2V0CglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJY29uY2F0Cglsb2cKCXJldHN1YgoKLy8gcG9zdE9mZmVyKHVpbnQ2NCxzdHJpbmcpdm9pZAoqYWJpX3JvdXRlX3Bvc3RPZmZlcjoKCS8vIG5vdGU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyBvZmZlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBwb3N0T2ZmZXIodWludDY0LHN0cmluZyl2b2lkCgljYWxsc3ViIHBvc3RPZmZlcgoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gcG9zdE9mZmVyKG9mZmVyOiB1aW50NjQsIG5vdGU6IHN0cmluZyk6IHZvaWQKcG9zdE9mZmVyOgoJcHJvdG8gMiAwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDgwCgkvLyB0aGlzLm5mZF9wb3N0ZWRPZmZlci5sb2coewoJLy8gICAgICAgICAgICAgYXBwSWQ6IHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgbmFtZTogdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgc2VuZGVyOiB0aGlzLnR4bi5zZW5kZXIsCgkvLyAgICAgICAgICAgICBhbW91bnQ6IG9mZmVyLAoJLy8gICAgICAgICAgICAgbm90ZTogbm90ZSwKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweDUyNTMyYjcwIC8vIG5mZF9wb3N0ZWRPZmZlcih1aW50NjQsc3RyaW5nLGFkZHJlc3MsdWludDY0LHN0cmluZykKCWJ5dGVjIDAgLy8gIGluaXRpYWwgaGVhZAoJYnl0ZWMgMCAvLyAgaW5pdGlhbCB0YWlsCglwdXNoYnl0ZXMgMHgwMDM0IC8vIGluaXRpYWwgaGVhZCBvZmZzZXQKCXR4bmEgQXBwbGljYXRpb25zIDAKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWJ5dGVjIDQgLy8gImkubmFtZSIKCWFwcF9nbG9iYWxfZ2V0CglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXR4biBTZW5kZXIKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMSAvLyBvZmZlcjogdWludDY0CglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTIgLy8gbm90ZTogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJY29uY2F0Cglsb2cKCXJldHN1YgoKLy8gbWludFBheW91dCh1aW50NjQsdWludDY0KSh1aW50NjQsYWRkcmVzcyx1aW50NjQsYWRkcmVzcyx1aW50NjQpCiphYmlfcm91dGVfbWludFBheW91dDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMTEgLy8gMHgxNTFmN2M3NQoKCS8vIHNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ286IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIG9uZVllYXJQcmljZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBtaW50UGF5b3V0KHVpbnQ2NCx1aW50NjQpKHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCkKCWNhbGxzdWIgbWludFBheW91dAoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIG1pbnRQYXlvdXQob25lWWVhclByaWNlOiB1aW50NjQsIHNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ286IHVpbnQ2NCk6IFBheW91dEluZm8KbWludFBheW91dDoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXBuIDYKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo0OTIKCS8vIGFzc2VydChnbG9iYWxzLmNhbGxlckFwcGxpY2F0aW9uSUQgPT09IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKSwgJ2NhbGxlciBtdXN0IGJlIE5GRCByZWdpc3RyeSEnKQoJZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uSUQKCWludGMgNCAvLyBUTVBMX3JlZ2lzdHJ5QXBwSWQKCT09CgoJLy8gY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDkzCgkvLyBhc3NlcnQodGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX01JTlRJTkcpID09PSBORkRfTUlOVElOR19TVEFURV9QT1NUQVNBKQoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJYnl0ZWMgMzAgLy8gIjIiCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NDk1CgkvLyBvZmZlckFtdCA9IHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX1NFTExfQU1PVU5UKQoJYnl0ZWMgNiAvLyAiaS5zZWxsYW10IgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglmcmFtZV9idXJ5IDAgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjQ5OAoJLy8gZ3Jvc3NUb1RyZWFzdXJ5ID0gb2ZmZXJBbXQKCWZyYW1lX2RpZyAwIC8vIG9mZmVyQW10OiB1aW50NjQKCWZyYW1lX2J1cnkgMSAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoKCS8vICppZjMwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTAzCgkvLyBsZW4odGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX1NFR01FTlRfQ09NTUlTU0lPTl9BR0VOVCkpID4gMAoJYnl0ZWMgOSAvLyAiaS5zZWdtZW50QWdlbnQuYSIKCWNhbGxzdWIgc2FmZUdsb2JhbEJ5dGVHZXQKCWxlbgoJaW50YyAwIC8vIDAKCT4KCWJ6ICppZjMwX2Vsc2UKCgkvLyAqaWYzMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1MDcKCS8vIGdyb3NzVG9UcmVhc3VyeSA9IHNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ28KCWZyYW1lX2RpZyAtMiAvLyBzZWdtZW50UGxhdGZvcm1Db3N0SW5BbGdvOiB1aW50NjQKCWZyYW1lX2J1cnkgMSAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUwOQoJLy8gZXh0cmFEYXlzID0gKDM2NSAqIG9mZmVyQW10KSAvIG9uZVllYXJQcmljZQoJaW50YyA4IC8vIDM2NQoJZnJhbWVfZGlnIDAgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIC0xIC8vIG9uZVllYXJQcmljZTogdWludDY0CgkvCglmcmFtZV9idXJ5IDMgLy8gZXh0cmFEYXlzOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1MTEKCS8vIGdyb3NzVG9UcmVhc3VyeSA9IChleHRyYURheXMgKiBzZWdtZW50UGxhdGZvcm1Db3N0SW5BbGdvKSAvIDM2NQoJZnJhbWVfZGlnIDMgLy8gZXh0cmFEYXlzOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBzZWdtZW50UGxhdGZvcm1Db3N0SW5BbGdvOiB1aW50NjQKCSoKCWludGMgOCAvLyAzNjUKCS8KCWZyYW1lX2J1cnkgMSAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoKCS8vICppZjMxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTEyCgkvLyBncm9zc1RvVHJlYXN1cnkgPCBzZWdtZW50UGxhdGZvcm1Db3N0SW5BbGdvCglmcmFtZV9kaWcgMSAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIHNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ286IHVpbnQ2NAoJPAoJYnogKmlmMzFfZW5kCgoJLy8gKmlmMzFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTEzCgkvLyBncm9zc1RvVHJlYXN1cnkgPSBzZWdtZW50UGxhdGZvcm1Db3N0SW5BbGdvCglmcmFtZV9kaWcgLTIgLy8gc2VnbWVudFBsYXRmb3JtQ29zdEluQWxnbzogdWludDY0CglmcmFtZV9idXJ5IDEgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCippZjMxX2VuZDoKCS8vICppZjMyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTE1CgkvLyBncm9zc1RvVHJlYXN1cnkgPj0gb2ZmZXJBbXQKCWZyYW1lX2RpZyAxIC8vIGdyb3NzVG9UcmVhc3VyeTogdWludDY0CglmcmFtZV9kaWcgMCAvLyBvZmZlckFtdDogdWludDY0Cgk+PQoJYnogKmlmMzJfZW5kCgoJLy8gKmlmMzJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTE2CgkvLyBncm9zc1RvVHJlYXN1cnkgPSBvZmZlckFtdAoJZnJhbWVfZGlnIDAgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJZnJhbWVfYnVyeSAxIC8vIGdyb3NzVG9UcmVhc3VyeTogdWludDY0CgoqaWYzMl9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1MTkKCS8vIHNlZ21lbnRDb21taXNzaW9uVG9QYXkgPSBvZmZlckFtdCAtIGdyb3NzVG9UcmVhc3VyeQoJZnJhbWVfZGlnIDAgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCS0KCWZyYW1lX2J1cnkgMiAvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5OiB1aW50NjQKCWIgKmlmMzBfZW5kCgoqaWYzMF9lbHNlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTIyCgkvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMiAvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5OiB1aW50NjQKCippZjMwX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUyNgoJLy8gY29tbWlzc2lvblRvUGF5ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNCAvLyBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoKCS8vICppZjMzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTI3CgkvLyB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9DT01NSVNTSU9OMSkgPT09IDAKCWJ5dGVjIDcgLy8gImkuY29tbWlzc2lvbjEiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmMzNfZWxzZQoKCS8vICppZjMzX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUyOQoJLy8gY29tbWlzc2lvblRvUGF5ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNCAvLyBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoJYiAqaWYzM19lbmQKCippZjMzX2Vsc2U6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1MzMKCS8vIGNvbW1pc3Npb25Ub1BheSA9IChncm9zc1RvVHJlYXN1cnkgKiB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9DT01NSVNTSU9OMSkpIC8gMTAwMAoJZnJhbWVfZGlnIDEgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCWJ5dGVjIDcgLy8gImkuY29tbWlzc2lvbjEiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCSoKCWludGMgMTggLy8gMTAwMAoJLwoJZnJhbWVfYnVyeSA0IC8vIGNvbW1pc3Npb25Ub1BheTogdWludDY0CgoqaWYzM19lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1MzYKCS8vIGNvbW1pc3Npb25BZ2VudCA9IGdsb2JhbHMuemVyb0FkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJZnJhbWVfYnVyeSA1IC8vIGNvbW1pc3Npb25BZ2VudDogYWRkcmVzcwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUzNwoJLy8gc2VnbWVudFJvb3RPd25lciA9IGdsb2JhbHMuemVyb0FkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJZnJhbWVfYnVyeSA2IC8vIHNlZ21lbnRSb290T3duZXI6IGFkZHJlc3MKCgkvLyAqaWYzNF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjUzOQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xX0FHRU5UKS5leGlzdHMKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGVjIDUgLy8gImkuY29tbWlzc2lvbjFBZ2VudC5hIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJYnogKmlmMzRfZW5kCgoJLy8gKmlmMzRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTQwCgkvLyBjb21taXNzaW9uQWdlbnQgPSBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQ09NTUlTU0lPTjFfQUdFTlQpLnZhbHVlKQoJYnl0ZWMgNSAvLyAiaS5jb21taXNzaW9uMUFnZW50LmEiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSA1IC8vIGNvbW1pc3Npb25BZ2VudDogYWRkcmVzcwoKKmlmMzRfZW5kOgoJLy8gKmlmMzVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NDIKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UX0NPTU1JU1NJT05fQUdFTlQpLmV4aXN0cwoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZWMgOSAvLyAiaS5zZWdtZW50QWdlbnQuYSIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCWJ6ICppZjM1X2VuZAoKCS8vICppZjM1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU0MwoJLy8gc2VnbWVudFJvb3RPd25lciA9IEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UX0NPTU1JU1NJT05fQUdFTlQpLnZhbHVlKQoJYnl0ZWMgOSAvLyAiaS5zZWdtZW50QWdlbnQuYSIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDYgLy8gc2VnbWVudFJvb3RPd25lcjogYWRkcmVzcwoKKmlmMzVfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTQ3CgkvLyB0aGlzLmRvUGF5b3V0cygKCS8vICAgICAgICAgICAgIGdyb3NzVG9UcmVhc3VyeSwKCS8vICAgICAgICAgICAgIEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMRVIpLnZhbHVlKSwKCS8vICAgICAgICAgICAgIGNvbW1pc3Npb25Ub1BheSwKCS8vICAgICAgICAgICAgIHNlZ21lbnRDb21taXNzaW9uVG9QYXksCgkvLyAgICAgICAgICAgICBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfU0VHTUVOVF9DT01NSVNTSU9OX0FHRU5UKS52YWx1ZSksCgkvLyAgICAgICAgICkKCWJ5dGVjIDkgLy8gImkuc2VnbWVudEFnZW50LmEiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDIgLy8gc2VnbWVudENvbW1pc3Npb25Ub1BheTogdWludDY0CglmcmFtZV9kaWcgNCAvLyBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoJYnl0ZWMgMTAgLy8gImkuc2VsbGVyLmEiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDEgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCWNhbGxzdWIgZG9QYXlvdXRzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTU2CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfU0VMTEVSKS52YWx1ZSA9IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUKCWJ5dGVjIDEwIC8vICJpLnNlbGxlci5hIgoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTU4CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfSElHSEVTVF9TT0xEX0FNT1VOVCkudmFsdWUgPSBpdG9iKG9mZmVyQW10KQoJYnl0ZWMgMjYgLy8gImkuaGlnaGVzdFNvbGRBbXQiCglmcmFtZV9kaWcgMCAvLyBvZmZlckFtdDogdWludDY0CglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU1OQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX01JTlRJTkcpLmRlbGV0ZSgpCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU2MAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NFTExfQU1PVU5UKS5kZWxldGUoKQoJYnl0ZWMgNiAvLyAiaS5zZWxsYW10IgoJYXBwX2dsb2JhbF9kZWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NjIKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UX0NPTU1JU1NJT05fQUdFTlQpLmRlbGV0ZSgpCglieXRlYyA5IC8vICJpLnNlZ21lbnRBZ2VudC5hIgoJYXBwX2dsb2JhbF9kZWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NjQKCS8vIHJldHVybiB7CgkvLyAgICAgICAgICAgICBhbW91bnRUb1NlbGxlcjogZ3Jvc3NUb1RyZWFzdXJ5IC0gY29tbWlzc2lvblRvUGF5LAoJLy8gICAgICAgICAgICAgY29tbWlzc2lvbkFkZHJlc3M6IGNvbW1pc3Npb25BZ2VudCwKCS8vICAgICAgICAgICAgIGFtb3VudFRvQ29tbWlzc2lvbjogY29tbWlzc2lvblRvUGF5LAoJLy8gICAgICAgICAgICAgc2VnbWVudFJvb3RPd25lcjogc2VnbWVudFJvb3RPd25lciwKCS8vICAgICAgICAgICAgIGFtb3VudFRvU2VnbWVudFJvb3Q6IHNlZ21lbnRDb21taXNzaW9uVG9QYXksCgkvLyAgICAgICAgIH0KCWZyYW1lX2RpZyAxIC8vIGdyb3NzVG9UcmVhc3VyeTogdWludDY0CglmcmFtZV9kaWcgNCAvLyBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoJLQoJaXRvYgoJZnJhbWVfZGlnIDUgLy8gY29tbWlzc2lvbkFnZW50OiBhZGRyZXNzCgljb25jYXQKCWZyYW1lX2RpZyA0IC8vIGNvbW1pc3Npb25Ub1BheTogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyA2IC8vIHNlZ21lbnRSb290T3duZXI6IGFkZHJlc3MKCWNvbmNhdAoJZnJhbWVfZGlnIDIgLy8gc2VnbWVudENvbW1pc3Npb25Ub1BheTogdWludDY0CglpdG9iCgljb25jYXQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiA2CglyZXRzdWIKCi8vIHB1cmNoYXNlKHBheSl2b2lkCiphYmlfcm91dGVfcHVyY2hhc2U6CgkvLyBwYXltZW50OiBwYXkKCXR4biBHcm91cEluZGV4CglpbnRjIDEgLy8gMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50YyAxIC8vICBwYXkKCT09CgoJLy8gYXJndW1lbnQgMCAocGF5bWVudCkgZm9yIHB1cmNoYXNlIG11c3QgYmUgYSBwYXkgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGV4ZWN1dGUgcHVyY2hhc2UocGF5KXZvaWQKCWNhbGxzdWIgcHVyY2hhc2UKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHB1cmNoYXNlKHBheW1lbnQ6IFBheVR4bik6IHZvaWQKcHVyY2hhc2U6Cglwcm90byAxIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiA4CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTc0CgkvLyBhc3NlcnQoIXRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HKS5leGlzdHMpCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NzUKCS8vIGFzc2VydCghdGhpcy5pc0V4cGlyZWQoKSwgImNhbid0IGJlIGV4cGlyZWQiKQoJY2FsbHN1YiBpc0V4cGlyZWQKCSEKCgkvLyBjYW4ndCBiZSBleHBpcmVkCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1NzYKCS8vIGFzc2VydCh0aGlzLmlzRm9yU2FsZSgpLCAnbXVzdCBiZSBmb3Igc2FsZScpCgljYWxsc3ViIGlzRm9yU2FsZQoKCS8vIG11c3QgYmUgZm9yIHNhbGUKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU3NwoJLy8gc2VsbEFtdCA9IHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX1NFTExfQU1PVU5UKQoJYnl0ZWMgNiAvLyAiaS5zZWxsYW10IgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglmcmFtZV9idXJ5IDAgLy8gc2VsbEFtdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTc4CgkvLyByZXNlcnZlZE93bmVyID0gdGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX1JFU0VSVkVEX09XTkVSKQoJYnl0ZWMgOCAvLyAiaS5yZXNlcnZlZE93bmVyLmEiCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CglmcmFtZV9idXJ5IDEgLy8gcmVzZXJ2ZWRPd25lcjogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTc5CgkvLyBvZmZlckFtdCA9IHBheW1lbnQuYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gcGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2J1cnkgMiAvLyBvZmZlckFtdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTgwCgkvLyBvcmlnT2ZmZXJhbXQgPSBvZmZlckFtdAoJZnJhbWVfZGlnIDIgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJZnJhbWVfYnVyeSAzIC8vIG9yaWdPZmZlcmFtdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTgxCgkvLyBsb2coJ29yaWdfb2ZmZXI6JyArIG9mZmVyQW10LnRvU3RyaW5nKCkpCglwdXNoYnl0ZXMgMHg2ZjcyNjk2NzVmNmY2NjY2NjU3MjNhIC8vICJvcmlnX29mZmVyOiIKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWNhbGxzdWIgKml0b2EKCWNvbmNhdAoJbG9nCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTgzCgkvLyBhc3NlcnQocGF5bWVudC5zZW5kZXIgPT09IHRoaXMudHhuLnNlbmRlciwgJ3BheW1lbnQgc2VuZGVyIG11c3QgYmUgc2FtZSBhcyBwdXJjaGFzZSBjYWxsZXInKQoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCgl0eG4gU2VuZGVyCgk9PQoKCS8vIHBheW1lbnQgc2VuZGVyIG11c3QgYmUgc2FtZSBhcyBwdXJjaGFzZSBjYWxsZXIKCWFzc2VydAoKCS8vICppZjM2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTg1CgkvLyBsZW4ocmVzZXJ2ZWRPd25lcikgPiAwCglmcmFtZV9kaWcgMSAvLyByZXNlcnZlZE93bmVyOiBieXRlW10KCWxlbgoJaW50YyAwIC8vIDAKCT4KCWJ6ICppZjM2X2VuZAoKCS8vICppZjM2X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjU4NgoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHJlc2VydmVkT3duZXIgPT09IHJhd0J5dGVzKHBheW1lbnQuc2VuZGVyKSwKCS8vICAgICAgICAgICAgICAgICAiUmVzZXJ2ZWQgb3duZXIgc2V0LCBidXQgc2VuZGVyIGlzbid0IHRoZSByZXNlcnZlZCBhZGRyZXNzIiwKCS8vICAgICAgICAgICAgICkKCWZyYW1lX2RpZyAxIC8vIHJlc2VydmVkT3duZXI6IGJ5dGVbXQoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCgk9PQoKCS8vIFJlc2VydmVkIG93bmVyIHNldCwgYnV0IHNlbmRlciBpc24ndCB0aGUgcmVzZXJ2ZWQgYWRkcmVzcwoJYXNzZXJ0CgoqaWYzNl9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo1OTQKCS8vIHJlc2VydmVkT3duZXIgPSByYXdCeXRlcyhwYXltZW50LnNlbmRlcikKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIFNlbmRlcgoJZnJhbWVfYnVyeSAxIC8vIHJlc2VydmVkT3duZXI6IGJ5dGVbXQoKCS8vICppZjM3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NTk5CgkvLyB0aGlzLnNhZmVHbG9iYWxCeXRlR2V0KE5GRF9LRVlfTUlOVElOR19LSUNLT0ZGX0NSRUFUT1IpID09PSByYXdCeXRlcyhwYXltZW50LnNlbmRlcikKCWJ5dGVjIDEyIC8vICJpLm1pbnRpbmdLaWNrb2ZmQ3JlYXRvci5hIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCgk9PQoJYnogKmlmMzdfZW5kCgoJLy8gKmlmMzdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjAwCgkvLyBvZmZlckFtdCArPSB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQU1PVU5UKQoJZnJhbWVfZGlnIDIgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJYnl0ZWMgMTMgLy8gImkubWludGluZ0tpY2tvZmZBbW91bnQiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCSsKCWZyYW1lX2J1cnkgMiAvLyBvZmZlckFtdDogdWludDY0CgoqaWYzN19lbmQ6CgkvLyAqaWYzOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYwMwoJLy8gbGVuKHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXQoTkZEX0tFWV9DT01NSVNTSU9OMV9BR0VOVCkpID4gMAoJYnl0ZWMgNSAvLyAiaS5jb21taXNzaW9uMUFnZW50LmEiCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CglsZW4KCWludGMgMCAvLyAwCgk+CglieiAqaWYzOF9lbmQKCgkvLyAqaWYzOF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MDQKCS8vIGFzc2VydChvZmZlckFtdCA+IE5GRF9NSU5fU0VMTEFNT1VOVF9XX0NPTU1JU1NJT05TLCAnb2ZmZXIgbXVzdCBiZSBhdCBsZWFzdCBtaW4gYW1vdW50JykKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWludGMgMTUgLy8gMTAwMDAwMAoJPgoKCS8vIG9mZmVyIG11c3QgYmUgYXQgbGVhc3QgbWluIGFtb3VudAoJYXNzZXJ0CgoqaWYzOF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MDcKCS8vIGFzc2VydChvZmZlckFtdCA+PSBzZWxsQW10LCAnb2ZmZXIgbXVzdCBiZSBhdCBsZWFzdCBzZWxsIGFtb3VudCcpCglmcmFtZV9kaWcgMiAvLyBvZmZlckFtdDogdWludDY0CglmcmFtZV9kaWcgMCAvLyBzZWxsQW10OiB1aW50NjQKCT49CgoJLy8gb2ZmZXIgbXVzdCBiZSBhdCBsZWFzdCBzZWxsIGFtb3VudAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjEwCgkvLyByZWZ1bmRBbXQgPSBvZmZlckFtdCAtIHNlbGxBbXQKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIHNlbGxBbXQ6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSA0IC8vIHJlZnVuZEFtdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjExCgkvLyBvZmZlckFtdCAtPSByZWZ1bmRBbXQKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWZyYW1lX2RpZyA0IC8vIHJlZnVuZEFtdDogdWludDY0CgktCglmcmFtZV9idXJ5IDIgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYxNAoJLy8gdmVyaWZ5UGF5VHhuKHBheW1lbnQsIHsgYW1vdW50OiBvcmlnT2ZmZXJhbXQsIHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzIH0pCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gcGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2RpZyAzIC8vIG9yaWdPZmZlcmFtdDogdWludDY0Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoicGF5bWVudCIsImZpZWxkIjoiYW1vdW50IiwiZXhwZWN0ZWQiOiJvcmlnT2ZmZXJhbXQifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gcGF5bWVudDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJwYXltZW50IiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MTcKCS8vIGNvbW1pc3Npb25Ub1BheSA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDUgLy8gY29tbWlzc2lvblRvUGF5OiB1aW50NjQKCgkvLyAqaWYzOV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYxOAoJLy8gdGhpcy5zYWZlR2xvYmFsSW50R2V0KE5GRF9LRVlfQ09NTUlTU0lPTjEpID09PSAwCglieXRlYyA3IC8vICJpLmNvbW1pc3Npb24xIgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjM5X2Vsc2UKCgkvLyAqaWYzOV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MjAKCS8vIGNvbW1pc3Npb25Ub1BheSA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDUgLy8gY29tbWlzc2lvblRvUGF5OiB1aW50NjQKCWIgKmlmMzlfZW5kCgoqaWYzOV9lbHNlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjI0CgkvLyBjb21taXNzaW9uVG9QYXkgPSAob2ZmZXJBbXQgKiB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9DT01NSVNTSU9OMSkpIC8gMTAwMAoJZnJhbWVfZGlnIDIgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJYnl0ZWMgNyAvLyAiaS5jb21taXNzaW9uMSIKCWNhbGxzdWIgc2FmZUdsb2JhbEludEdldAoJKgoJaW50YyAxOCAvLyAxMDAwCgkvCglmcmFtZV9idXJ5IDUgLy8gY29tbWlzc2lvblRvUGF5OiB1aW50NjQKCippZjM5X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYyNwoJLy8gY29udkZlZUFkZHIgPSBnbG9iYWxzLnplcm9BZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCWZyYW1lX2J1cnkgNiAvLyBjb252RmVlQWRkcjogYWRkcmVzcwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjYyOAoJLy8gY29udkZlZSA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDcgLy8gY29udkZlZTogdWludDY0CgoJLy8gKmlmNDBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MjkKCS8vIHRoaXMudHhuLmdyb3VwSW5kZXggPj0gMgoJdHhuIEdyb3VwSW5kZXgKCWludGMgMiAvLyAyCgk+PQoJYnogKmlmNDBfZW5kCgoJLy8gKmlmNDBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjMwCgkvLyBjb252RmVlVHhuID0gdGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMl0KCXR4biBHcm91cEluZGV4CglpbnRjIDIgLy8gMgoJLQoJZnJhbWVfYnVyeSA4IC8vIGNvbnZGZWVUeG46IHR4bgoKCS8vICppZjQxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjMyCgkvLyBjb252RmVlVHhuLnR5cGVFbnVtID09PSBUcmFuc2FjdGlvblR5cGUuUGF5bWVudCAmJgoJLy8gICAgICAgICAgICAgICAgIGNvbnZGZWVUeG4uc2VuZGVyID09PSB0aGlzLnR4bi5zZW5kZXIgJiYKCS8vICAgICAgICAgICAgICAgICBjb252RmVlVHhuLm5vdGUgPT09ICdjb252LiBmZWUnCglmcmFtZV9kaWcgOCAvLyBjb252RmVlVHhuOiB0eG4KCWd0eG5zIFR5cGVFbnVtCglpbnRjIDEgLy8gIHBheQoJPT0KCWR1cAoJYnogKnNraXBfYW5kMTIKCWZyYW1lX2RpZyA4IC8vIGNvbnZGZWVUeG46IHR4bgoJZ3R4bnMgU2VuZGVyCgl0eG4gU2VuZGVyCgk9PQoJJiYKCipza2lwX2FuZDEyOgoJZHVwCglieiAqc2tpcF9hbmQxMwoJZnJhbWVfZGlnIDggLy8gY29udkZlZVR4bjogdHhuCglndHhucyBOb3RlCglwdXNoYnl0ZXMgMHg2MzZmNmU3NjJlMjA2NjY1NjUgLy8gImNvbnYuIGZlZSIKCT09CgkmJgoKKnNraXBfYW5kMTM6CglieiAqaWY0MV9lbmQKCgkvLyAqaWY0MV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2MzYKCS8vIGNvbnZGZWVBZGRyID0gY29udkZlZVR4bi5yZWNlaXZlcgoJZnJhbWVfZGlnIDggLy8gY29udkZlZVR4bjogdHhuCglndHhucyBSZWNlaXZlcgoJZnJhbWVfYnVyeSA2IC8vIGNvbnZGZWVBZGRyOiBhZGRyZXNzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjM3CgkvLyBjb252RmVlID0gY29udkZlZVR4bi5hbW91bnQKCWZyYW1lX2RpZyA4IC8vIGNvbnZGZWVUeG46IHR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9idXJ5IDcgLy8gY29udkZlZTogdWludDY0CgoqaWY0MV9lbmQ6CgoqaWY0MF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NDEKCS8vIHNlbmRNZXRob2RDYWxsPHR5cGVvZiBORkRSZWdpc3RyeS5wcm90b3R5cGUub3duZXJzaGlwQ2hhbmdlZD4oewoJLy8gICAgICAgICAgICAgYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpLAoJLy8gICAgICAgICAgICAgbWV0aG9kQXJnczogWwoJLy8gICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9OQU1FKS52YWx1ZSwKCS8vICAgICAgICAgICAgICAgICB0aGlzLmFwcC5pZCwKCS8vICAgICAgICAgICAgICAgICBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlKSwKCS8vICAgICAgICAgICAgICAgICBBZGRyZXNzLmZyb21CeXRlcyhyZXNlcnZlZE93bmVyKSwKCS8vICAgICAgICAgICAgIF0sCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDcgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCXB1c2hieXRlcyAweGYyMmM1N2YyIC8vIG1ldGhvZCAib3duZXJzaGlwQ2hhbmdlZChzdHJpbmcsdWludDY0LGFkZHJlc3MsYWRkcmVzcyl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NDIKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKQoJaW50YyA0IC8vIFRNUExfcmVnaXN0cnlBcHBJZAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjQzCgkvLyBtZXRob2RBcmdzOiBbCgkvLyAgICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgICAgIHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgICAgIEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUpLAoJLy8gICAgICAgICAgICAgICAgIEFkZHJlc3MuZnJvbUJ5dGVzKHJlc2VydmVkT3duZXIpLAoJLy8gICAgICAgICAgICAgXQoJYnl0ZWMgNCAvLyAiaS5uYW1lIgoJYXBwX2dsb2JhbF9nZXQKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWJ5dGVjIDEgLy8gImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDEgLy8gcmVzZXJ2ZWRPd25lcjogYnl0ZVtdCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NTEKCS8vIHRoaXMubmZkX3B1cmNoYXNlZC5sb2coewoJLy8gICAgICAgICAgICAgYXBwSWQ6IHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgbmFtZTogdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgc2VsbGVyOiBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlKSwKCS8vICAgICAgICAgICAgIGJ1eWVyOiBBZGRyZXNzLmZyb21CeXRlcyhyZXNlcnZlZE93bmVyKSwKCS8vICAgICAgICAgICAgIHNlbGxBbW91bnQ6IHNlbGxBbXQsCgkvLyAgICAgICAgICAgICBvZmZlckFtb3VudDogb2ZmZXJBbXQsCgkvLyAgICAgICAgICAgICBvdmVycGF5bWVudFJlZnVuZDogcmVmdW5kQW10LAoJLy8gICAgICAgICAgICAgY29udkZlZUFkZHI6IGNvbnZGZWVBZGRyLAoJLy8gICAgICAgICAgICAgY29udkZlZUFtb3VudDogY29udkZlZSwKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweDc4ZGM4OWUzIC8vIG5mZF9wdXJjaGFzZWQodWludDY0LHN0cmluZyxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQpCglieXRlYyAwIC8vICBpbml0aWFsIGhlYWQKCWJ5dGVjIDAgLy8gIGluaXRpYWwgdGFpbAoJcHVzaGJ5dGVzIDB4MDA4YSAvLyBpbml0aWFsIGhlYWQgb2Zmc2V0Cgl0eG5hIEFwcGxpY2F0aW9ucyAwCglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglieXRlYyA0IC8vICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldAoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50CglieXRlYyAxIC8vICJpLm93bmVyLmEiCglhcHBfZ2xvYmFsX2dldAoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDEgLy8gcmVzZXJ2ZWRPd25lcjogYnl0ZVtdCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMCAvLyBzZWxsQW10OiB1aW50NjQKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyA0IC8vIHJlZnVuZEFtdDogdWludDY0CglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgNiAvLyBjb252RmVlQWRkcjogYWRkcmVzcwoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDcgLy8gY29udkZlZTogdWludDY0CglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50Cglwb3AgLy8gcG9wIGhlYWQgb2Zmc2V0Cgljb25jYXQgLy8gY29uY2F0IGhlYWQgYW5kIHRhaWwKCWNvbmNhdAoJbG9nCgoJLy8gKmlmNDJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NjQKCS8vIHJlZnVuZEFtdCA+IDAKCWZyYW1lX2RpZyA0IC8vIHJlZnVuZEFtdDogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJYnogKmlmNDJfZW5kCgoJLy8gKmlmNDJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjY1CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICAgICAgYW1vdW50OiByZWZ1bmRBbXQsCgkvLyAgICAgICAgICAgICAgICAgcmVjZWl2ZXI6IHBheW1lbnQuc2VuZGVyLAoJLy8gICAgICAgICAgICAgICAgIG5vdGU6ICdvdmVycGF5bWVudFJlZnVuZCcsCgkvLyAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NjYKCS8vIGFtb3VudDogcmVmdW5kQW10CglmcmFtZV9kaWcgNCAvLyByZWZ1bmRBbXQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NjcKCS8vIHJlY2VpdmVyOiBwYXltZW50LnNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjY4CgkvLyBub3RlOiAnb3ZlcnBheW1lbnRSZWZ1bmQnCglwdXNoYnl0ZXMgMHg2Zjc2NjU3MjcwNjE3OTZkNjU2ZTc0NTI2NTY2NzU2ZTY0IC8vICJvdmVycGF5bWVudFJlZnVuZCIKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjQyX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY3MQoJLy8gdGhpcy5kb1BheW91dHMoCgkvLyAgICAgICAgICAgICBvZmZlckFtdCwKCS8vICAgICAgICAgICAgIEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMRVIpLnZhbHVlKSwKCS8vICAgICAgICAgICAgIGNvbW1pc3Npb25Ub1BheSwKCS8vICAgICAgICAgICAgIDAsCgkvLyAgICAgICAgICAgICBnbG9iYWxzLnplcm9BZGRyZXNzLAoJLy8gICAgICAgICApCglnbG9iYWwgWmVyb0FkZHJlc3MKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgNSAvLyBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoJYnl0ZWMgMTAgLy8gImkuc2VsbGVyLmEiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDIgLy8gb2ZmZXJBbXQ6IHVpbnQ2NAoJY2FsbHN1YiBkb1BheW91dHMKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2NzkKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCglieXRlYyAxNCAvLyAgI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50YyAxMyAvLyAgRGVsZXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCglpdHhuX3N1Ym1pdAoKCS8vICppZjQzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Njg0CgkvLyBsZW4odGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX01JTlRJTkdfS0lDS09GRl9DUkVBVE9SKSkgIT09IDAKCWJ5dGVjIDEyIC8vICJpLm1pbnRpbmdLaWNrb2ZmQ3JlYXRvci5hIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJbGVuCglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjQzX2VuZAoKCS8vICppZjQzX2NvbnNlcXVlbnQKCS8vICppZjQ0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6Njg2CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfTUlOVElOR19LSUNLT0ZGX0NSRUFUT1IpLnZhbHVlICE9PSByYXdCeXRlcyhwYXltZW50LnNlbmRlcikgJiYKCS8vICAgICAgICAgICAgICAgICBsZW4odGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX01JTlRJTkcpKSA9PT0gMAoJYnl0ZWMgMTIgLy8gImkubWludGluZ0tpY2tvZmZDcmVhdG9yLmEiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCgkhPQoJZHVwCglieiAqc2tpcF9hbmQxNAoJYnl0ZWMgMyAvLyAiaS5taW50aW5nIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJbGVuCglpbnRjIDAgLy8gMAoJPT0KCSYmCgoqc2tpcF9hbmQxNDoKCWJ6ICppZjQ0X2VuZAoKCS8vICppZjQ0X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY4OQoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX01JTlRJTkdfS0lDS09GRl9BTU9VTlQpLAoJLy8gICAgICAgICAgICAgICAgICAgICByZWNlaXZlcjogQWRkcmVzcy5mcm9tQnl0ZXModGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX01JTlRJTkdfS0lDS09GRl9DUkVBVE9SKS52YWx1ZSksCgkvLyAgICAgICAgICAgICAgICAgICAgIG5vdGU6ICdlc2Nyb3dSZWZ1bmQnLAoJLy8gICAgICAgICAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDEgLy8gIHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY5MAoJLy8gYW1vdW50OiB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQU1PVU5UKQoJYnl0ZWMgMTMgLy8gImkubWludGluZ0tpY2tvZmZBbW91bnQiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NjkxCgkvLyByZWNlaXZlcjogQWRkcmVzcy5mcm9tQnl0ZXModGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX01JTlRJTkdfS0lDS09GRl9DUkVBVE9SKS52YWx1ZSkKCWJ5dGVjIDEyIC8vICJpLm1pbnRpbmdLaWNrb2ZmQ3JlYXRvci5hIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo2OTIKCS8vIG5vdGU6ICdlc2Nyb3dSZWZ1bmQnCglwdXNoYnl0ZXMgMHg2NTczNjM3MjZmNzc1MjY1NjY3NTZlNjQgLy8gImVzY3Jvd1JlZnVuZCIKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjQ0X2VuZDoKCippZjQzX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjY5OAoJLy8gdGhpcy5jbGF3QXNhRnJvbVRvKEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUpLCB0aGlzLmFwcC5hZGRyZXNzKQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWJ5dGVjIDEgLy8gImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0CgljYWxsc3ViIGNsYXdBc2FGcm9tVG8KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MTEKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUgPSByZXNlcnZlZE93bmVyCglieXRlYyAxIC8vICJpLm93bmVyLmEiCglmcmFtZV9kaWcgMSAvLyByZXNlcnZlZE93bmVyOiBieXRlW10KCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzEyCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfU0VMTEVSKS52YWx1ZSA9IHJlc2VydmVkT3duZXIKCWJ5dGVjIDEwIC8vICJpLnNlbGxlci5hIgoJZnJhbWVfZGlnIDEgLy8gcmVzZXJ2ZWRPd25lcjogYnl0ZVtdCglhcHBfZ2xvYmFsX3B1dAoKCS8vICppZjQ1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzEzCgkvLyBvZmZlckFtdCA+IHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX0hJR0hFU1RfU09MRF9BTU9VTlQpCglmcmFtZV9kaWcgMiAvLyBvZmZlckFtdDogdWludDY0CglieXRlYyAyNiAvLyAiaS5oaWdoZXN0U29sZEFtdCIKCWNhbGxzdWIgc2FmZUdsb2JhbEludEdldAoJPgoJYnogKmlmNDVfZW5kCgoJLy8gKmlmNDVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzE0CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfSElHSEVTVF9TT0xEX0FNT1VOVCkudmFsdWUgPSBpdG9iKG9mZmVyQW10KQoJYnl0ZWMgMjYgLy8gImkuaGlnaGVzdFNvbGRBbXQiCglmcmFtZV9kaWcgMiAvLyBvZmZlckFtdDogdWludDY0CglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKKmlmNDVfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzE2CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcxNwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1RJTUVQVVJDSEFTRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDM0IC8vICJpLnRpbWVQdXJjaGFzZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcxOAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX01JTlRJTkcpLmRlbGV0ZSgpCglieXRlYyAzIC8vICJpLm1pbnRpbmciCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcxOQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1JFU0VSVkVEX09XTkVSKS5kZWxldGUoKQoJYnl0ZWMgOCAvLyAiaS5yZXNlcnZlZE93bmVyLmEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcyMAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NFTExfQU1PVU5UKS5kZWxldGUoKQoJYnl0ZWMgNiAvLyAiaS5zZWxsYW10IgoJYXBwX2dsb2JhbF9kZWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MjEKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQ1JFQVRPUikuZGVsZXRlKCkKCWJ5dGVjIDEyIC8vICJpLm1pbnRpbmdLaWNrb2ZmQ3JlYXRvci5hIgoJYXBwX2dsb2JhbF9kZWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MjIKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9NSU5USU5HX0tJQ0tPRkZfQU1PVU5UKS5kZWxldGUoKQoJYnl0ZWMgMTMgLy8gImkubWludGluZ0tpY2tvZmZBbW91bnQiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcyMwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NFR01FTlRfQ09NTUlTU0lPTl9BR0VOVCkuZGVsZXRlKCkKCWJ5dGVjIDkgLy8gImkuc2VnbWVudEFnZW50LmEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjcyNQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0lTVkFVTFRPUFRJTkxPQ0tFRCkudmFsdWUgPSBORkRfTE9DS0VEX1ZBTF9GQUxTRQoJYnl0ZWMgMjAgLy8gImkudmF1bHRPcHRJbkxvY2tlZCIKCWJ5dGVjIDI0IC8vICIwIgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MjYKCS8vIGxvZyhpdG9iKG9mZmVyQW10KSkKCWZyYW1lX2RpZyAyIC8vIG9mZmVyQW10OiB1aW50NjQKCWl0b2IKCWxvZwoJcmV0c3ViCgovLyBpc0FkZHJlc3NJbkZpZWxkKHN0cmluZyxhZGRyZXNzKWJvb2wKKmFiaV9yb3V0ZV9pc0FkZHJlc3NJbkZpZWxkOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAxMSAvLyAweDE1MWY3Yzc1CgoJLy8gYWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChhZGRyZXNzKSBmb3IgaXNBZGRyZXNzSW5GaWVsZCBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZmllbGROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBpc0FkZHJlc3NJbkZpZWxkKHN0cmluZyxhZGRyZXNzKWJvb2wKCWNhbGxzdWIgaXNBZGRyZXNzSW5GaWVsZAoJYnl0ZWMgMjkgLy8gMHgwMAoJaW50YyAwIC8vIDAKCXVuY292ZXIgMgoJc2V0Yml0Cgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gaXNBZGRyZXNzSW5GaWVsZChmaWVsZE5hbWU6IHN0cmluZywgYWRkcmVzczogQWRkcmVzcyk6IGJvb2xlYW4KaXNBZGRyZXNzSW5GaWVsZDoKCXByb3RvIDIgMQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjczMQoJLy8gYXNzZXJ0KGFkZHJlc3MgIT09IGdsb2JhbHMuemVyb0FkZHJlc3MpCglmcmFtZV9kaWcgLTIgLy8gYWRkcmVzczogQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoJYXNzZXJ0CgoJLy8gKmlmNDZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo3MzIKCS8vICF0aGlzLmJveGVzKGZpZWxkTmFtZSkuZXhpc3RzCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBzdHJpbmcKCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYnogKmlmNDZfZW5kCgoJLy8gKmlmNDZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6NzMzCgkvLyByZXR1cm4gZmFsc2UKCWludGMgMCAvLyAwCglyZXRzdWIKCippZjQ2X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjczNQoJLy8gcmV0dXJuIHRoaXMuZmluZEFkZHJJbkJ5dGVzKHRoaXMuYm94ZXMoZmllbGROYW1lKS52YWx1ZSwgYWRkcmVzcykKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBzdHJpbmcKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoZmllbGROYW1lKS52YWx1ZQoJYXNzZXJ0CgljYWxsc3ViIGZpbmRBZGRySW5CeXRlcwoJcmV0c3ViCgovLyBkb1BheW91dHMoZ3Jvc3NUb1NlbGxlcjogdWludDY0LCBzZWxsZXJBZGRyZXNzOiBBZGRyZXNzLCBjb21taXNzaW9uVG9QYXk6IHVpbnQ2NCwgc2VnbWVudENvbW1pc3Npb25Ub1BheTogdWludDY0LCBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3M6IEFkZHJlc3MpOiB2b2lkCmRvUGF5b3V0czoKCXByb3RvIDUgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODA2CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICBhbW91bnQ6IGdyb3NzVG9TZWxsZXIgLSBjb21taXNzaW9uVG9QYXksCgkvLyAgICAgICAgICAgICByZWNlaXZlcjogc2VsbGVyQWRkcmVzcywKCS8vICAgICAgICAgICAgIG5vdGU6ICdzZWxsZXInLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4MDcKCS8vIGFtb3VudDogZ3Jvc3NUb1NlbGxlciAtIGNvbW1pc3Npb25Ub1BheQoJZnJhbWVfZGlnIC0xIC8vIGdyb3NzVG9TZWxsZXI6IHVpbnQ2NAoJZnJhbWVfZGlnIC0zIC8vIGNvbW1pc3Npb25Ub1BheTogdWludDY0CgktCglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgwOAoJLy8gcmVjZWl2ZXI6IHNlbGxlckFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBzZWxsZXJBZGRyZXNzOiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODA5CgkvLyBub3RlOiAnc2VsbGVyJwoJcHVzaGJ5dGVzIDB4NzM2NTZjNmM2NTcyIC8vICJzZWxsZXIiCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODExCgkvLyBjb21taXNzaW9uQWRkcmVzcyA9IGdsb2JhbHMuemVyb0FkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJZnJhbWVfYnVyeSAwIC8vIGNvbW1pc3Npb25BZGRyZXNzOiBhZGRyZXNzCgoJLy8gKmlmNDdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4MTQKCS8vIGxlbih0aGlzLnNhZmVHbG9iYWxCeXRlR2V0KE5GRF9LRVlfQ09NTUlTU0lPTjFfQUdFTlQpKSAhPT0gMAoJYnl0ZWMgNSAvLyAiaS5jb21taXNzaW9uMUFnZW50LmEiCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CglsZW4KCWludGMgMCAvLyAwCgkhPQoJYnogKmlmNDdfZW5kCgoJLy8gKmlmNDdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODE1CgkvLyBjb21taXNzaW9uQWRkcmVzcyA9IEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9DT01NSVNTSU9OMV9BR0VOVCkudmFsdWUpCglieXRlYyA1IC8vICJpLmNvbW1pc3Npb24xQWdlbnQuYSIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDAgLy8gY29tbWlzc2lvbkFkZHJlc3M6IGFkZHJlc3MKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4MTYKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgICAgICAgICAgICBhbW91bnQ6IGNvbW1pc3Npb25Ub1BheSwKCS8vICAgICAgICAgICAgICAgICByZWNlaXZlcjogY29tbWlzc2lvbkFkZHJlc3MsCgkvLyAgICAgICAgICAgICAgICAgbm90ZTogJ2NvbW1pc3Npb24nLAoJLy8gICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODE3CgkvLyBhbW91bnQ6IGNvbW1pc3Npb25Ub1BheQoJZnJhbWVfZGlnIC0zIC8vIGNvbW1pc3Npb25Ub1BheTogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgxOAoJLy8gcmVjZWl2ZXI6IGNvbW1pc3Npb25BZGRyZXNzCglmcmFtZV9kaWcgMCAvLyBjb21taXNzaW9uQWRkcmVzczogYWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgxOQoJLy8gbm90ZTogJ2NvbW1pc3Npb24nCglwdXNoYnl0ZXMgMHg2MzZmNmQ2ZDY5NzM3MzY5NmY2ZSAvLyAiY29tbWlzc2lvbiIKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyAqaWY0OF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgyNQoJLy8gbGVuKHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXQoTkZEX0tFWV9DT01NSVNTSU9OMl9BR0VOVCkpID09PSAwCglieXRlYyAxNiAvLyAiaS5jb21taXNzaW9uMkFnZW50LmEiCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CglsZW4KCWludGMgMCAvLyAwCgk9PQoJYnogKmlmNDhfZWxzZQoKCS8vICppZjQ4X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgyNgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xX0FHRU5UKS5kZWxldGUoKQoJYnl0ZWMgNSAvLyAiaS5jb21taXNzaW9uMUFnZW50LmEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgyNwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xKS5kZWxldGUoKQoJYnl0ZWMgNyAvLyAiaS5jb21taXNzaW9uMSIKCWFwcF9nbG9iYWxfZGVsCgliICppZjQ4X2VuZAoKKmlmNDhfZWxzZToKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgyOQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xX0FHRU5UKS52YWx1ZSA9IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9DT01NSVNTSU9OMl9BR0VOVCkudmFsdWUKCWJ5dGVjIDUgLy8gImkuY29tbWlzc2lvbjFBZ2VudC5hIgoJYnl0ZWMgMTYgLy8gImkuY29tbWlzc2lvbjJBZ2VudC5hIgoJYXBwX2dsb2JhbF9nZXQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODMwCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQ09NTUlTU0lPTjEpLnZhbHVlID0gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04yKS52YWx1ZQoJYnl0ZWMgNyAvLyAiaS5jb21taXNzaW9uMSIKCWJ5dGVjIDIyIC8vICJpLmNvbW1pc3Npb24yIgoJYXBwX2dsb2JhbF9nZXQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODMxCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQ09NTUlTU0lPTjJfQUdFTlQpLmRlbGV0ZSgpCglieXRlYyAxNiAvLyAiaS5jb21taXNzaW9uMkFnZW50LmEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjgzMgoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04yKS5kZWxldGUoKQoJYnl0ZWMgMjIgLy8gImkuY29tbWlzc2lvbjIiCglhcHBfZ2xvYmFsX2RlbAoKKmlmNDhfZW5kOgoKKmlmNDdfZW5kOgoJLy8gKmlmNDlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4MzgKCS8vIHNlZ21lbnRDb21taXNzaW9uVG9QYXkgIT09IDAKCWZyYW1lX2RpZyAtNCAvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5OiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoJYnogKmlmNDlfZW5kCgoJLy8gKmlmNDlfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODM5CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICAgICAgYW1vdW50OiBzZWdtZW50Q29tbWlzc2lvblRvUGF5LAoJLy8gICAgICAgICAgICAgICAgIHJlY2VpdmVyOiBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3MsCgkvLyAgICAgICAgICAgICAgICAgbm90ZTogJ3NlZ21lbnQnLAoJLy8gICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODQwCgkvLyBhbW91bnQ6IHNlZ21lbnRDb21taXNzaW9uVG9QYXkKCWZyYW1lX2RpZyAtNCAvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5OiB1aW50NjQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODQxCgkvLyByZWNlaXZlcjogc2VnbWVudENvbW1pc3Npb25BZGRyZXNzCglmcmFtZV9kaWcgLTUgLy8gc2VnbWVudENvbW1pc3Npb25BZGRyZXNzOiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODQyCgkvLyBub3RlOiAnc2VnbWVudCcKCXB1c2hieXRlcyAweDczNjU2NzZkNjU2ZTc0IC8vICJzZWdtZW50IgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmNDlfZW5kOgoJcmV0c3ViCgovLyBnZXRSZW5ld1ByaWNlKCl1aW50NjQKKmFiaV9yb3V0ZV9nZXRSZW5ld1ByaWNlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAxMSAvLyAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBnZXRSZW5ld1ByaWNlKCl1aW50NjQKCWNhbGxzdWIgZ2V0UmVuZXdQcmljZQoJaXRvYgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldFJlbmV3UHJpY2UoKTogdWludDY0CmdldFJlbmV3UHJpY2U6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NTAKCS8vIHJldHVybiB0aGlzLmdldFJlbmV3UHJpY2VEYXRhKHRoaXMudHhuLnNlbmRlcikub25lWWVhclByaWNlCgl0eG4gU2VuZGVyCgljYWxsc3ViIGdldFJlbmV3UHJpY2VEYXRhCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAwIDgKCWJ0b2kKCXJldHN1YgoKLy8gdXBkYXRlSGFzaChieXRlW10pdm9pZAoqYWJpX3JvdXRlX3VwZGF0ZUhhc2g6CgkvLyBoYXNoOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSB1cGRhdGVIYXNoKGJ5dGVbXSl2b2lkCgljYWxsc3ViIHVwZGF0ZUhhc2gKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHVwZGF0ZUhhc2goaGFzaDogYnl0ZXMpOiB2b2lkCnVwZGF0ZUhhc2g6Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NTYKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIGxlbihoYXNoKSA9PT0gMzIgJiYgQWRkcmVzcy5mcm9tQnl0ZXMoaGFzaCkgIT09IGdsb2JhbHMuemVyb0FkZHJlc3MsCgkvLyAgICAgICAgICAgICAibXVzdCBwYXNzIDMyLWJ5dGUgaGFzaCB0aGF0IGlzbid0IDAiLAoJLy8gICAgICAgICApCglmcmFtZV9kaWcgLTEgLy8gaGFzaDogYnl0ZXMKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoJZHVwCglieiAqc2tpcF9hbmQxNQoJZnJhbWVfZGlnIC0xIC8vIGhhc2g6IGJ5dGVzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9CgkmJgoKKnNraXBfYW5kMTU6CgkvLyBtdXN0IHBhc3MgMzItYnl0ZSBoYXNoIHRoYXQgaXNuJ3QgMAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODYxCgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICByYXdCeXRlcyh0aGlzLnR4bi5zZW5kZXIpID09PSB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlIHx8IHRoaXMuaXNDdXJyZW50VHhuQ29udHJhY3RBdXRob3JpdHkoKSwKCS8vICAgICAgICAgICAgICdvbmx5IHR4bmxhYiBvciBvd25lciBjYW4gcmVxdWVzdCBhbiBuZmQgbmZ0IGhhc2ggdXBkYXRlJywKCS8vICAgICAgICAgKQoJdHhuIFNlbmRlcgoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCT09CglkdXAKCWJueiAqc2tpcF9vcjEKCWNhbGxzdWIgaXNDdXJyZW50VHhuQ29udHJhY3RBdXRob3JpdHkKCXx8Cgoqc2tpcF9vcjE6CgkvLyBvbmx5IHR4bmxhYiBvciBvd25lciBjYW4gcmVxdWVzdCBhbiBuZmQgbmZ0IGhhc2ggdXBkYXRlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NjUKCS8vIHNlbmRBc3NldENvbmZpZyh7CgkvLyAgICAgICAgICAgICBjb25maWdBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KGJ0b2kodGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0FTQUlEKS52YWx1ZSkpLAoJLy8gICAgICAgICAgICAgY29uZmlnQXNzZXRNYW5hZ2VyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICAgICAgY29uZmlnQXNzZXRSZXNlcnZlOiBBZGRyZXNzLmZyb21CeXRlcyhoYXNoKSwKCS8vICAgICAgICAgICAgIGNvbmZpZ0Fzc2V0Q2xhd2JhY2s6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDYgLy8gIGFjZmcKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NjYKCS8vIGNvbmZpZ0Fzc2V0OiBBc3NldElELmZyb21VaW50NjQoYnRvaSh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQVNBSUQpLnZhbHVlKSkKCWJ5dGVjIDE4IC8vICJpLmFzYWlkIgoJYXBwX2dsb2JhbF9nZXQKCWJ0b2kKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NjcKCS8vIGNvbmZpZ0Fzc2V0TWFuYWdlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRNYW5hZ2VyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODY4CgkvLyBjb25maWdBc3NldFJlc2VydmU6IEFkZHJlc3MuZnJvbUJ5dGVzKGhhc2gpCglmcmFtZV9kaWcgLTEgLy8gaGFzaDogYnl0ZXMKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRSZXNlcnZlCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODY5CgkvLyBjb25maWdBc3NldENsYXdiYWNrOiB0aGlzLmFwcC5hZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBDb25maWdBc3NldENsYXdiYWNrCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBjb250cmFjdExvY2soYm9vbCl2b2lkCiphYmlfcm91dGVfY29udHJhY3RMb2NrOgoJLy8gbG9jazogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgMSAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGxvY2spIGZvciBjb250cmFjdExvY2sgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIGV4ZWN1dGUgY29udHJhY3RMb2NrKGJvb2wpdm9pZAoJY2FsbHN1YiBjb250cmFjdExvY2sKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGNvbnRyYWN0TG9jayhsb2NrOiBib29sZWFuKTogdm9pZApjb250cmFjdExvY2s6Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4NzcKCS8vIHRoaXMuYXNzZXJ0T3duZXJDYWxsZWROb3RGb3JTYWxlT3JFeHBpcmVkKCkKCWNhbGxzdWIgYXNzZXJ0T3duZXJDYWxsZWROb3RGb3JTYWxlT3JFeHBpcmVkCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODc4CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjg3OQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0lTTE9DS0VEKS52YWx1ZSA9IGxvY2sgPyAnMScgOiAnMCcKCWJ5dGVjIDI1IC8vICJpLmNvbnRyYWN0TG9ja2VkIgoJZnJhbWVfZGlnIC0xIC8vIGxvY2s6IGJvb2xlYW4KCWJ6ICp0ZXJuYXJ5MF9mYWxzZQoJYnl0ZWMgMTUgLy8gICIxIgoJYiAqdGVybmFyeTBfZW5kCgoqdGVybmFyeTBfZmFsc2U6CglieXRlYyAyMyAvLyAgIjAiCgoqdGVybmFyeTBfZW5kOgoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gc2VnbWVudExvY2soYm9vbCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3NlZ21lbnRMb2NrOgoJLy8gdXNkUHJpY2U6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGxvY2s6IGJvb2wKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDEgLy8gMQoJPT0KCgkvLyBhcmd1bWVudCAxIChsb2NrKSBmb3Igc2VnbWVudExvY2sgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIGV4ZWN1dGUgc2VnbWVudExvY2soYm9vbCx1aW50NjQpdm9pZAoJY2FsbHN1YiBzZWdtZW50TG9jawoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc2VnbWVudExvY2sobG9jazogYm9vbGVhbiwgdXNkUHJpY2U6IHVpbnQ2NCk6IHZvaWQKc2VnbWVudExvY2s6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjg4NQoJLy8gdGhpcy5hc3NlcnRPd25lckNhbGxlZE5vdEZvclNhbGVPckV4cGlyZWQoKQoJY2FsbHN1YiBhc3NlcnRPd25lckNhbGxlZE5vdEZvclNhbGVPckV4cGlyZWQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4ODYKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FQ0hBTkdFRCkudmFsdWUgPSBpdG9iKGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wKQoJYnl0ZWMgMiAvLyAiaS50aW1lQ2hhbmdlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODg3CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfSVNTRUdNRU5UTE9DS0VEKS52YWx1ZSA9IGxvY2sgPyAnMScgOiAnMCcKCWJ5dGVjIDIxIC8vICJpLnNlZ21lbnRMb2NrZWQiCglmcmFtZV9kaWcgLTEgLy8gbG9jazogYm9vbGVhbgoJYnogKnRlcm5hcnkxX2ZhbHNlCglieXRlYyAxNSAvLyAgIjEiCgliICp0ZXJuYXJ5MV9lbmQKCip0ZXJuYXJ5MV9mYWxzZToKCWJ5dGVjIDIzIC8vICAiMCIKCip0ZXJuYXJ5MV9lbmQ6CglhcHBfZ2xvYmFsX3B1dAoKCS8vICppZjUwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODg4CgkvLyBsb2NrCglmcmFtZV9kaWcgLTEgLy8gbG9jazogYm9vbGVhbgoJYnogKmlmNTBfZWxzZQoKCS8vICppZjUwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjg4OQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1NFR01FTlRfVVNEX1BSSUNFKS5kZWxldGUoKQoJYnl0ZWMgMzIgLy8gImkuc2VnbWVudFByaWNlVXNkIgoJYXBwX2dsb2JhbF9kZWwKCWIgKmlmNTBfZW5kCgoqaWY1MF9lbHNlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6ODkyCgkvLyBjb25zdHJhaW50RGF0YSA9IHNlbmRNZXRob2RDYWxsPHR5cGVvZiBORkRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM+KHsKCS8vICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KHRoaXMucmVnaXN0cnlBcHBJZCksCgkvLyAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglieXRlYyAzNyAvLyAgbWV0aG9kICJnZXRDb25zdHJhaW50cygpKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4OTMKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKQoJaW50YyA0IC8vIFRNUExfcmVnaXN0cnlBcHBJZAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnRjIDEgLy8gMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglmcmFtZV9idXJ5IDAgLy8gY29uc3RyYWludERhdGE6ICh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjg5NQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHVzZFByaWNlID49IGNvbnN0cmFpbnREYXRhLnNlZ21lbnRQbGF0Zm9ybUNvc3RJblVzZCwKCS8vICAgICAgICAgICAgICAgICAnYW1vdW50IG11c3QgYmUgYXQgbGVhc3QgTkZEX01JTl9TRUdNRU5UX1VTRCBkb2xsYXJzIGluIGFsZ28nLAoJLy8gICAgICAgICAgICAgKQoJZnJhbWVfZGlnIC0yIC8vIHVzZFByaWNlOiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIGNvbnN0cmFpbnREYXRhOiAodWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMCA4CglidG9pCgk+PQoKCS8vIGFtb3VudCBtdXN0IGJlIGF0IGxlYXN0IE5GRF9NSU5fU0VHTUVOVF9VU0QgZG9sbGFycyBpbiBhbGdvCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo4OTkKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUdNRU5UX1VTRF9QUklDRSkudmFsdWUgPSBpdG9iKHVzZFByaWNlKQoJYnl0ZWMgMzIgLy8gImkuc2VnbWVudFByaWNlVXNkIgoJZnJhbWVfZGlnIC0yIC8vIHVzZFByaWNlOiB1aW50NjQKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoqaWY1MF9lbmQ6CglyZXRzdWIKCi8vIHZhdWx0T3B0SW5Mb2NrKGJvb2wpdm9pZAoqYWJpX3JvdXRlX3ZhdWx0T3B0SW5Mb2NrOgoJLy8gbG9jazogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgMSAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGxvY2spIGZvciB2YXVsdE9wdEluTG9jayBtdXN0IGJlIGEgYm9vbAoJYXNzZXJ0CglpbnRjIDAgLy8gMAoJZ2V0Yml0CgoJLy8gZXhlY3V0ZSB2YXVsdE9wdEluTG9jayhib29sKXZvaWQKCWNhbGxzdWIgdmF1bHRPcHRJbkxvY2sKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHZhdWx0T3B0SW5Mb2NrKGxvY2s6IGJvb2xlYW4pOiB2b2lkCnZhdWx0T3B0SW5Mb2NrOgoJcHJvdG8gMSAwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTA4CgkvLyB0aGlzLmFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIGFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjkwOQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX1RJTUVDSEFOR0VEKS52YWx1ZSA9IGl0b2IoZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXApCglieXRlYyAyIC8vICJpLnRpbWVDaGFuZ2VkIgoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJaXRvYgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5MTAKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9JU1ZBVUxUT1BUSU5MT0NLRUQpLnZhbHVlID0gbG9jayA/ICcxJyA6ICcwJwoJYnl0ZWMgMjAgLy8gImkudmF1bHRPcHRJbkxvY2tlZCIKCWZyYW1lX2RpZyAtMSAvLyBsb2NrOiBib29sZWFuCglieiAqdGVybmFyeTJfZmFsc2UKCWJ5dGVjIDE1IC8vICAiMSIKCWIgKnRlcm5hcnkyX2VuZAoKKnRlcm5hcnkyX2ZhbHNlOgoJYnl0ZWMgMjMgLy8gICIwIgoKKnRlcm5hcnkyX2VuZDoKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIHZhdWx0T3B0SW4odWludDY0W10pdm9pZAoqYWJpX3JvdXRlX3ZhdWx0T3B0SW46CgkvLyBhc3NldHM6IHVpbnQ2NFtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdmF1bHRPcHRJbih1aW50NjRbXSl2b2lkCgljYWxsc3ViIHZhdWx0T3B0SW4KCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHZhdWx0T3B0SW4oYXNzZXRzOiBBc3NldElEW10pOiB2b2lkCnZhdWx0T3B0SW46Cglwcm90byAxIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTIwCgkvLyB0aGlzLm5vdEZvclNhbGVPckV4cGlyZWQoKQoJY2FsbHN1YiBub3RGb3JTYWxlT3JFeHBpcmVkCgoJLy8gKmlmNTFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5MjQKCS8vIHRoaXMuaXNWYXVsdEF1dG9PcHRJbkxvY2tlZCgpCgljYWxsc3ViIGlzVmF1bHRBdXRvT3B0SW5Mb2NrZWQKCWJ6ICppZjUxX2VuZAoKCS8vICppZjUxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjkyNQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHJhd0J5dGVzKHRoaXMudHhuLnNlbmRlcikgPT09IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUsCgkvLyAgICAgICAgICAgICAgICAgJ3NlbmRlciBtdXN0IGJlIG93bmVyIHdoZW4gdmF1bHQgbG9ja2VkJywKCS8vICAgICAgICAgICAgICkKCXR4biBTZW5kZXIKCWJ5dGVjIDEgLy8gImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoKCS8vIHNlbmRlciBtdXN0IGJlIG93bmVyIHdoZW4gdmF1bHQgbG9ja2VkCglhc3NlcnQKCippZjUxX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjkzMQoJLy8gYXNzZXJ0KHRoaXMudHhuLmdyb3VwSW5kZXggPiAwLCAncGFydCBvZiBvcHQtaW4gZm9yIG5ldyBhc3NldCwgbXVzdCBoYXZlIHByaW9yIHR4biBwYXlpbmcgTUJSJykKCXR4biBHcm91cEluZGV4CglpbnRjIDAgLy8gMAoJPgoKCS8vIHBhcnQgb2Ygb3B0LWluIGZvciBuZXcgYXNzZXQsIG11c3QgaGF2ZSBwcmlvciB0eG4gcGF5aW5nIE1CUgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTMzCgkvLyB2ZXJpZnlQYXlUeG4odGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMV0sIHsKCS8vICAgICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICAgICAgYW1vdW50OiAxMDBfMDAwICogYXNzZXRzLmxlbmd0aCwKCS8vICAgICAgICAgfSkKCXR4biBHcm91cEluZGV4CglpbnRjIDEgLy8gMQoJLQoJc3RvcmUgMjQ4IC8vIHZlcmlmeVR4biBpbmRleAoKCS8vIHZlcmlmeSBwYXkKCWxvYWQgMjQ4IC8vIHZlcmlmeVR4biBpbmRleAoJZ3R4bnMgVHlwZUVudW0KCWludGMgMSAvLyAgcGF5Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoidGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMV0iLCJmaWVsZCI6InR5cGVFbnVtIiwiZXhwZWN0ZWQiOiJwYXkifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHJlY2VpdmVyCglsb2FkIDI0OCAvLyB2ZXJpZnlUeG4gaW5kZXgKCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InRoaXMudHhuR3JvdXBbdGhpcy50eG4uZ3JvdXBJbmRleCAtIDFdIiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50Cglsb2FkIDI0OCAvLyB2ZXJpZnlUeG4gaW5kZXgKCWd0eG5zIEFtb3VudAoJaW50YyAxNiAvLyAxMDBfMDAwCglmcmFtZV9kaWcgLTEgLy8gYXNzZXRzOiBBc3NldElEW10KCWxlbgoJaW50YyA1IC8vIDgKCS8KCSoKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJ0aGlzLnR4bkdyb3VwW3RoaXMudHhuLmdyb3VwSW5kZXggLSAxXSIsImZpZWxkIjoiYW1vdW50IiwiZXhwZWN0ZWQiOiIxMDBfMDAwICogYXNzZXRzLmxlbmd0aCJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5MzcKCS8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpICs9IDEpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAwIC8vIGk6IHVpbnQ2NAoKKmZvcl82OgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTM3CgkvLyBpIDwgYXNzZXRzLmxlbmd0aAoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gYXNzZXRzOiBBc3NldElEW10KCWxlbgoJaW50YyA1IC8vIDgKCS8KCTwKCWJ6ICpmb3JfNl9lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5MzgKCS8vIGFzc2V0SWQgPSBhc3NldHNbaV0KCWZyYW1lX2RpZyAtMSAvLyBhc3NldHM6IEFzc2V0SURbXQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMCAvLyAgaW5pdGlhbCBvZmZzZXQKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50YyA1IC8vIDgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJaW50YyA1IC8vIDgKCWV4dHJhY3QzCglidG9pCglmcmFtZV9idXJ5IDEgLy8gYXNzZXRJZDogdWludDY0CgoJLy8gKmlmNTJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5NDAKCS8vICF0aGlzLmFwcC5hZGRyZXNzLmlzT3B0ZWRJblRvQXNzZXQoYXNzZXRJZCkKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglmcmFtZV9kaWcgMSAvLyBhc3NldElkOiB1aW50NjQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJc3dhcAoJcG9wCgkhCglieiAqaWY1Ml9lbmQKCgkvLyAqaWY1Ml9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5NDEKCS8vIHNlbmRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgICAgICAgICAgICAgICAgeGZlckFzc2V0OiBhc3NldElkLAoJLy8gICAgICAgICAgICAgICAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICAgICAgICAgICAgICBhc3NldEFtb3VudDogMCwKCS8vICAgICAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxMCAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5NDIKCS8vIHhmZXJBc3NldDogYXNzZXRJZAoJZnJhbWVfZGlnIDEgLy8gYXNzZXRJZDogdWludDY0CglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk0MwoJLy8gYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk0NAoJLy8gYXNzZXRBbW91bnQ6IDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmNTJfZW5kOgoKKmZvcl82X2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTM3CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMCAvLyBpOiB1aW50NjQKCWIgKmZvcl82CgoqZm9yXzZfZW5kOgoJcmV0c3ViCgovLyB2YXVsdFNlbmQodWludDY0LGFkZHJlc3Msc3RyaW5nLHVpbnQ2NCx1aW50NjRbXSl2b2lkCiphYmlfcm91dGVfdmF1bHRTZW5kOgoJLy8gb3RoZXJBc3NldHM6IHVpbnQ2NFtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglleHRyYWN0IDIgMAoKCS8vIGFzc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBub3RlOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWV4dHJhY3QgMiAwCgoJLy8gcmVjZWl2ZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDMgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMyAocmVjZWl2ZXIpIGZvciB2YXVsdFNlbmQgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGFtb3VudDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSB2YXVsdFNlbmQodWludDY0LGFkZHJlc3Msc3RyaW5nLHVpbnQ2NCx1aW50NjRbXSl2b2lkCgljYWxsc3ViIHZhdWx0U2VuZAoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gdmF1bHRTZW5kKGFtb3VudDogdWludDY0LCByZWNlaXZlcjogQWRkcmVzcywgbm90ZTogc3RyaW5nLCBhc3NldDogdWludDY0LCBvdGhlckFzc2V0czogQXNzZXRJRFtdKTogdm9pZAp2YXVsdFNlbmQ6Cglwcm90byA1IDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiAzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTY0CgkvLyB0aGlzLmFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIGFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk2NQoJLy8gYXNzZXJ0KHJlY2VpdmVyICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIHJlY2VpdmVyOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9Cglhc3NlcnQKCgkvLyAqaWY1M19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk2NwoJLy8gYXNzZXQgPT09IDAKCWZyYW1lX2RpZyAtNCAvLyBhc3NldDogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjUzX2VuZAoKCS8vICppZjUzX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk2OAoJLy8gYXNzZXJ0KG90aGVyQXNzZXRzLmxlbmd0aCA9PT0gMCwgImNhbid0IHNwZWNpZnkgb3RoZXIgYXNzZXRzIGlmIHNlbmRpbmcgYWxnbyBmcm9tIHZhdWx0IikKCWZyYW1lX2RpZyAtNSAvLyBvdGhlckFzc2V0czogQXNzZXRJRFtdCglsZW4KCWludGMgNSAvLyA4CgkvCglpbnRjIDAgLy8gMAoJPT0KCgkvLyBjYW4ndCBzcGVjaWZ5IG90aGVyIGFzc2V0cyBpZiBzZW5kaW5nIGFsZ28gZnJvbSB2YXVsdAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTY5CgkvLyBhc3NlcnQoYW1vdW50ID4gMCkKCWZyYW1lX2RpZyAtMSAvLyBhbW91bnQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT4KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk3MQoJLy8gbWluQmFsYW5jZSA9IHRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZSArIHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX01JTlRJTkdfS0lDS09GRl9BTU9VTlQpCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCglwb3AKCWJ5dGVjIDEzIC8vICJpLm1pbnRpbmdLaWNrb2ZmQW1vdW50IgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CgkrCglmcmFtZV9idXJ5IDAgLy8gbWluQmFsYW5jZTogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTczCgkvLyBhc3NlcnQodGhpcy5hcHAuYWRkcmVzcy5iYWxhbmNlIC0gYW1vdW50ID49IG1pbkJhbGFuY2UpCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAtMSAvLyBhbW91bnQ6IHVpbnQ2NAoJLQoJZnJhbWVfZGlnIDAgLy8gbWluQmFsYW5jZTogdWludDY0Cgk+PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTc0CgkvLyBzZW5kUGF5bWVudCh7IHJlY2VpdmVyOiByZWNlaXZlciwgYW1vdW50OiBhbW91bnQsIG5vdGU6IG5vdGUgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTc0CgkvLyByZWNlaXZlcjogcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMiAvLyByZWNlaXZlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk3NAoJLy8gYW1vdW50OiBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBhbW91bnQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5NzQKCS8vIG5vdGU6IG5vdGUKCWZyYW1lX2RpZyAtMyAvLyBub3RlOiBzdHJpbmcKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5NzUKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY1M19lbmQ6CgkvLyAqaWY1NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk3OQoJLy8gYW1vdW50ICE9PSAwCglmcmFtZV9kaWcgLTEgLy8gYW1vdW50OiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoJYnogKmlmNTRfZW5kCgoJLy8gKmlmNTRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTgwCgkvLyBhc3NlcnQob3RoZXJBc3NldHMubGVuZ3RoID09PSAwLCAnY2FuIG9ubHkgc2VuZCBvbmUgYXNzZXQgaWYgYW1vdW50ID09IDAnKQoJZnJhbWVfZGlnIC01IC8vIG90aGVyQXNzZXRzOiBBc3NldElEW10KCWxlbgoJaW50YyA1IC8vIDgKCS8KCWludGMgMCAvLyAwCgk9PQoKCS8vIGNhbiBvbmx5IHNlbmQgb25lIGFzc2V0IGlmIGFtb3VudCA9PSAwCglhc3NlcnQKCippZjU0X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk4MgoJLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8PSBvdGhlckFzc2V0cy5sZW5ndGg7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDEgLy8gaTogdWludDY0CgoqZm9yXzc6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5ODIKCS8vIGkgPD0gb3RoZXJBc3NldHMubGVuZ3RoCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAtNSAvLyBvdGhlckFzc2V0czogQXNzZXRJRFtdCglsZW4KCWludGMgNSAvLyA4CgkvCgk8PQoJYnogKmZvcl83X2VuZAoKCS8vICppZjU1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTg2CgkvLyBpID09PSAwCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmNTVfZWxzZQoKCS8vICppZjU1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjk4NwoJLy8gYXNzZXRJZCA9IEFzc2V0SUQuZnJvbVVpbnQ2NChhc3NldCkKCWZyYW1lX2RpZyAtNCAvLyBhc3NldDogdWludDY0CglmcmFtZV9idXJ5IDIgLy8gYXNzZXRJZDogQXNzZXRJRAoJYiAqaWY1NV9lbmQKCippZjU1X2Vsc2U6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5ODkKCS8vIGFzc2V0SWQgPSBvdGhlckFzc2V0c1tpIC0gMV0KCWZyYW1lX2RpZyAtNSAvLyBvdGhlckFzc2V0czogQXNzZXRJRFtdCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAwIC8vICBpbml0aWFsIG9mZnNldAoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJLQoJaW50YyA1IC8vIDgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJaW50YyA1IC8vIDgKCWV4dHJhY3QzCglidG9pCglmcmFtZV9idXJ5IDIgLy8gYXNzZXRJZDogQXNzZXRJRAoKKmlmNTVfZW5kOgoJLy8gKmlmNTZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5OTIKCS8vIGFzc2V0SWQuaWQgPT09IGJ0b2kodGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0FTQUlEKS52YWx1ZSkKCWZyYW1lX2RpZyAyIC8vIGFzc2V0SWQ6IEFzc2V0SUQKCWJ5dGVjIDE4IC8vICJpLmFzYWlkIgoJYXBwX2dsb2JhbF9nZXQKCWJ0b2kKCT09CglieiAqaWY1Nl9lbmQKCgkvLyAqaWY1Nl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5OTMKCS8vIGFzc2VydChyYXdCeXRlcyhyZWNlaXZlcikgPT09IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUsICdyZWNlaXZlciBtdXN0IGJlIG93bmVyJykKCWZyYW1lX2RpZyAtMiAvLyByZWNlaXZlcjogQWRkcmVzcwoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCT09CgoJLy8gcmVjZWl2ZXIgbXVzdCBiZSBvd25lcgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTk0CgkvLyB0aGlzLmNsYXdBc2FGcm9tVG8odGhpcy5hcHAuYWRkcmVzcywgcmVjZWl2ZXIpCglmcmFtZV9kaWcgLTIgLy8gcmVjZWl2ZXI6IEFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgljYWxsc3ViIGNsYXdBc2FGcm9tVG8KCWIgKmZvcl83X2NvbnRpbnVlCgoqaWY1Nl9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5OTcKCS8vIGFzc2V0QmFsID0gcmVjZWl2ZXIuYXNzZXRCYWxhbmNlKGFzc2V0SWQpCglmcmFtZV9kaWcgLTIgLy8gcmVjZWl2ZXI6IEFkZHJlc3MKCWZyYW1lX2RpZyAyIC8vIGFzc2V0SWQ6IEFzc2V0SUQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglmcmFtZV9idXJ5IDMgLy8gYXNzZXRCYWw6IHVpbnQ2NAoKCS8vICppZjU3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6OTk4CgkvLyBhbW91bnQgPT09IDAgfHwgdGhpcy5hcHAuYWRkcmVzcy5hc3NldEJhbGFuY2UoYXNzZXRJZCkgPT09IGFzc2V0QmFsCglmcmFtZV9kaWcgLTEgLy8gYW1vdW50OiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoJZHVwCglibnogKnNraXBfb3IyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZnJhbWVfZGlnIDIgLy8gYXNzZXRJZDogQXNzZXRJRAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAzIC8vIGFzc2V0QmFsOiB1aW50NjQKCT09Cgl8fAoKKnNraXBfb3IyOgoJYnogKmlmNTdfZWxzZQoKCS8vICppZjU3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwMDAKCS8vIHNlbmRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgICAgICAgICAgICAgICAgeGZlckFzc2V0OiBhc3NldElkLAoJLy8gICAgICAgICAgICAgICAgICAgICBhc3NldFJlY2VpdmVyOiByZWNlaXZlciwKCS8vICAgICAgICAgICAgICAgICAgICAgYXNzZXRDbG9zZVRvOiByZWNlaXZlciwKCS8vICAgICAgICAgICAgICAgICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKCS8vICAgICAgICAgICAgICAgICAgICAgbm90ZTogbm90ZSwKCS8vICAgICAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxMCAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDAxCgkvLyB4ZmVyQXNzZXQ6IGFzc2V0SWQKCWZyYW1lX2RpZyAyIC8vIGFzc2V0SWQ6IEFzc2V0SUQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAwMgoJLy8gYXNzZXRSZWNlaXZlcjogcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMiAvLyByZWNlaXZlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAwMwoJLy8gYXNzZXRDbG9zZVRvOiByZWNlaXZlcgoJZnJhbWVfZGlnIC0yIC8vIHJlY2VpdmVyOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFzc2V0Q2xvc2VUbwoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwMDQKCS8vIGFzc2V0QW1vdW50OiBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBhbW91bnQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwMDUKCS8vIG5vdGU6IG5vdGUKCWZyYW1lX2RpZyAtMyAvLyBub3RlOiBzdHJpbmcKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWIgKmlmNTdfZW5kCgoqaWY1N19lbHNlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAwOAoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoeyB4ZmVyQXNzZXQ6IGFzc2V0SWQsIGFzc2V0UmVjZWl2ZXI6IHJlY2VpdmVyLCBhc3NldEFtb3VudDogYW1vdW50LCBub3RlOiBub3RlIH0pCglpdHhuX2JlZ2luCglpbnRjIDEwIC8vICBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwMDgKCS8vIHhmZXJBc3NldDogYXNzZXRJZAoJZnJhbWVfZGlnIDIgLy8gYXNzZXRJZDogQXNzZXRJRAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDA4CgkvLyBhc3NldFJlY2VpdmVyOiByZWNlaXZlcgoJZnJhbWVfZGlnIC0yIC8vIHJlY2VpdmVyOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDA4CgkvLyBhc3NldEFtb3VudDogYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gYW1vdW50OiB1aW50NjQKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDA4CgkvLyBub3RlOiBub3RlCglmcmFtZV9kaWcgLTMgLy8gbm90ZTogc3RyaW5nCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoqaWY1N19lbmQ6CgoqZm9yXzdfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czo5ODIKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzcKCipmb3JfN19lbmQ6CglyZXRzdWIKCi8vIHJlbmV3KHBheSl2b2lkCiphYmlfcm91dGVfcmVuZXc6CgkvLyBwYXltZW50OiBwYXkKCXR4biBHcm91cEluZGV4CglpbnRjIDEgLy8gMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50YyAxIC8vICBwYXkKCT09CgoJLy8gYXJndW1lbnQgMCAocGF5bWVudCkgZm9yIHJlbmV3IG11c3QgYmUgYSBwYXkgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGV4ZWN1dGUgcmVuZXcocGF5KXZvaWQKCWNhbGxzdWIgcmVuZXcKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHJlbmV3KHBheW1lbnQ6IFBheVR4bik6IHZvaWQKLy8KLy8gUmVuZXcgYWRkcyBtb3JlIHRpbWUgdG8gYW4gZXhpc3RpbmcgTkZEcyBleHBpcmF0aW9uLCBvciByZW5ld3MgaXQgaWYgZXhwaXJlZC4KLy8KLy8gQXMgcGFydCBvZiB2Mi0+djMgdXBncmFkZSwgdGhlIE5GRHMgYXJlIGNvbnZlcnRlZCBmcm9tIGxpZmV0aW1lIE5GRHMgdG8gcmVuZXdhbCBORkRzLiBUaGUgdjIgY29udHJhY3QgaXMgdXBncmFkZWQKLy8gdG8gdjMsIHRoZW4gcmVuZXcgaXMgY2FsbGVkIG9uIHRoZSAobm93IHYzKSBuZmQgdG8gdHVybiBpdCBpbnRvIGEgcmVuZXdhbCAobm90ZSB0aGUgaWYgY3VyRXhwaXJhdGlvbiA9PT0gMCBjaGVjaykKLy8KLy8gSWYgYWxyZWFkeSByZW5ld2FsLCB0aGVuIGl0IGV4dGVuZHMgdGhlIGN1cnJlbnQgZXhwaXJhdGlvbiB0aW1lIGJ5IHRoZSB0aW1lIHNwZWNpZmllZCAobWluaW11bSAxIHlyKSAoMzY1IC8gcHJpY2UgcGFpZCAqIG1pbnQgcHJpY2UpCi8vIEV4cGlyYXRpb25zIGNhbiBuZXZlciBiZSBtb3JlIHRoYW4gTkZEX01BWF9FWFBJUkFUSU9OX0RBWVMgZGF5cyBpbiB0aGUgZnV0dXJlLgovLwovLyBJRiB0aGUgTkZEIGlzIGV4cGlyZWQ6Ci8vIHggVGhlIGN1cnJlbnQgb3duZXIgY2FuIHRha2UgaXQgYmFjayBvdmVyIGF0IGJhc2UgcHJpY2UgLSBhbmQgTkZEIG1ldGFkYXRhIGRvZXNuJ3QgaGF2ZSB0byBiZSBjbGVhcmVkIC0gdGhleQovLyBnZXQgaXQgYmFjayBhcy1pcy4KLy8geCBJZiBub3QgY3VycmVudCBvd25lciwgdGhlbiB0aGUgcHJpY2UgZ29lcyBmcm9tIGhpZ2ggb2YgYmFzZSBwcmljZSAqIDEwLDAwMCBkb3duIHRvIGJhc2UgcHJpY2Ugb3ZlciAyNCBocnMgd2hlcmUKLy8gJ2J1eWVyJyBoYXMgdG8gcGF5IGF0IGxlYXN0IHRoYXQgcHJpY2UuICBUaGUgTkZEIE1VU1QgQUxSRUFEWSBIQVZFIElUUyBNRVRBREFUQSBDTEVBUkVEIQovLwovLyBAcGFyYW0ge1BheVR4bn0gcGF5bWVudCAtIFRoZSBwYXltZW50IHRyYW5zYWN0aW9uIGZyb20gd2hpY2ggdGhlIHJlbmV3YWwgcGVyaW9kIGlzIGRldGVybWluZWQuLgpyZW5ldzoKCXByb3RvIDEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXBuIDExCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAzMQoJLy8gdmVyaWZ5UGF5VHhuKHBheW1lbnQsIHsgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MgfSkKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoicGF5bWVudCIsImZpZWxkIjoicmVjZWl2ZXIiLCJleHBlY3RlZCI6InRoaXMuYXBwLmFkZHJlc3MifQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAzNAoJLy8gcHJpY2VJbmZvID0gdGhpcy5nZXRSZW5ld1ByaWNlRGF0YSh0aGlzLnR4bi5zZW5kZXIpCgl0eG4gU2VuZGVyCgljYWxsc3ViIGdldFJlbmV3UHJpY2VEYXRhCglmcmFtZV9idXJ5IDAgLy8gcHJpY2VJbmZvOiAodWludDY0LHVpbnQ2NCxib29sLGJvb2wsYm9vbCkKCgkvLyAqaWY1OF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwMzUKCS8vIGdsb2JhbHMub3Bjb2RlQnVkZ2V0IDwgMjAwCglnbG9iYWwgT3Bjb2RlQnVkZ2V0CglpbnRjIDE5IC8vIDIwMAoJPAoJYnogKmlmNThfZW5kCgoJLy8gKmlmNThfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAzNgoJLy8gaW5jcmVhc2VPcGNvZGVCdWRnZXQoKQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCWJ5dGVjIDE0IC8vICAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnRjIDEzIC8vICBEZWxldGVBcHBsaWNhdGlvbgoJaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KCWl0eG5fc3VibWl0CgoqaWY1OF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDM4CgkvLyBjb25zdHJhaW50RGF0YSA9IHNlbmRNZXRob2RDYWxsPHR5cGVvZiBORkRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM+KHsKCS8vICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQodGhpcy5yZWdpc3RyeUFwcElkKSwKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJYnl0ZWMgMzcgLy8gIG1ldGhvZCAiZ2V0Q29uc3RyYWludHMoKSh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KSIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTAzOQoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpCglpbnRjIDQgLy8gVE1QTF9yZWdpc3RyeUFwcElkCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIE51bUxvZ3MKCWludGMgMSAvLyAxCgktCglpdHhuYXMgTG9ncwoJZXh0cmFjdCA0IDAKCWZyYW1lX2J1cnkgMSAvLyBjb25zdHJhaW50RGF0YTogKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA0MQoJLy8gcmVxUHJpY2UgPSBwcmljZUluZm8ub25lWWVhclByaWNlCglmcmFtZV9kaWcgMCAvLyBwcmljZUluZm86ICh1aW50NjQsdWludDY0LGJvb2wsYm9vbCxib29sKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMCA4CglidG9pCglmcmFtZV9idXJ5IDIgLy8gcmVxUHJpY2U6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwNDIKCS8vIG1heEV4cFllYXJzID0gY29uc3RyYWludERhdGEubWF4WWVhcnNBbGxvd2VkCglmcmFtZV9kaWcgMSAvLyBjb25zdHJhaW50RGF0YTogKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDE2IDgKCWJ0b2kKCWZyYW1lX2J1cnkgMyAvLyBtYXhFeHBZZWFyczogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA0MwoJLy8gYXNzZXJ0KHJlcVByaWNlID4gMCkKCWZyYW1lX2RpZyAyIC8vIHJlcVByaWNlOiB1aW50NjQKCWludGMgMCAvLyAwCgk+Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDQ0CgkvLyBvcmlnT3duZXIgPSBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlKQoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2J1cnkgNCAvLyBvcmlnT3duZXI6IGFkZHJlc3MKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDQ2CgkvLyBjdXJFeHBpcmF0aW9uID0gdGhpcy5zYWZlR2xvYmFsSW50R2V0KE5GRF9LRVlfRVhQSVJBVElPTlRJTUUpCglieXRlYyAxNyAvLyAiaS5leHBpcmF0aW9uVGltZSIKCWNhbGxzdWIgc2FmZUdsb2JhbEludEdldAoJZnJhbWVfYnVyeSA1IC8vIGN1ckV4cGlyYXRpb246IHVpbnQ2NAoKCS8vICppZjU5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA0NwoJLy8gY3VyRXhwaXJhdGlvbiAhPT0gMCAmJiB0aGlzLmlzRXhwaXJlZCgpCglmcmFtZV9kaWcgNSAvLyBjdXJFeHBpcmF0aW9uOiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoJZHVwCglieiAqc2tpcF9hbmQxNgoJY2FsbHN1YiBpc0V4cGlyZWQKCSYmCgoqc2tpcF9hbmQxNjoKCWJ6ICppZjU5X2VuZAoKCS8vICppZjU5X2NvbnNlcXVlbnQKCS8vICppZjYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA1MgoJLy8gdGhpcy50eG4uc2VuZGVyICE9PSBvcmlnT3duZXIKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyA0IC8vIG9yaWdPd25lcjogYWRkcmVzcwoJIT0KCWJ6ICppZjYwX2VuZAoKCS8vICppZjYwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwNTMKCS8vIGFzc2VydCh0aGlzLmFwcC5hZGRyZXNzLnRvdGFsQm94ZXMgPT09IDAsICJjYW4ndCBjbGFpbSBleHBpcmVkIG5mZCB1bmxlc3MgYWxsIG1ldGFkYXRhIGlzIGNsZWFyZWQiKQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0VG90YWxCb3hlcwoJcG9wCglpbnRjIDAgLy8gMAoJPT0KCgkvLyBjYW4ndCBjbGFpbSBleHBpcmVkIG5mZCB1bmxlc3MgYWxsIG1ldGFkYXRhIGlzIGNsZWFyZWQKCWFzc2VydAoKKmlmNjBfZW5kOgoKKmlmNTlfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA1OQoJLy8gYXNzZXJ0KHBheW1lbnQuYW1vdW50ID49IHJlcVByaWNlLCAnbXVzdCBwYXkgYXQgbGVhc3QgbWluaW11bSByZW5ld2FsIHByaWNlJykKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZnJhbWVfZGlnIDIgLy8gcmVxUHJpY2U6IHVpbnQ2NAoJPj0KCgkvLyBtdXN0IHBheSBhdCBsZWFzdCBtaW5pbXVtIHJlbmV3YWwgcHJpY2UKCWFzc2VydAoKCS8vICppZjYxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2MAoJLy8gY3VyRXhwaXJhdGlvbiA9PT0gMAoJZnJhbWVfZGlnIDUgLy8gY3VyRXhwaXJhdGlvbjogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjYxX2Vsc2VpZjFfY29uZGl0aW9uCgoJLy8gKmlmNjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2MQoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gb3JpZ093bmVyKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIDQgLy8gb3JpZ093bmVyOiBhZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2MwoJLy8gY3VyRXhwaXJhdGlvbiA9IGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglmcmFtZV9idXJ5IDUgLy8gY3VyRXhwaXJhdGlvbjogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2NQoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04xX0FHRU5UKS5kZWxldGUoKQoJYnl0ZWMgNSAvLyAiaS5jb21taXNzaW9uMUFnZW50LmEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwNjYKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9DT01NSVNTSU9OMSkuZGVsZXRlKCkKCWJ5dGVjIDcgLy8gImkuY29tbWlzc2lvbjEiCglhcHBfZ2xvYmFsX2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwNjcKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9DT01NSVNTSU9OMl9BR0VOVCkuZGVsZXRlKCkKCWJ5dGVjIDE2IC8vICJpLmNvbW1pc3Npb24yQWdlbnQuYSIKCWFwcF9nbG9iYWxfZGVsCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2OAoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0NPTU1JU1NJT04yKS5kZWxldGUoKQoJYnl0ZWMgMjIgLy8gImkuY29tbWlzc2lvbjIiCglhcHBfZ2xvYmFsX2RlbAoJYiAqaWY2MV9lbmQKCippZjYxX2Vsc2VpZjFfY29uZGl0aW9uOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA2OQoJLy8gdGhpcy5pc0V4cGlyZWQoKQoJY2FsbHN1YiBpc0V4cGlyZWQKCWJ6ICppZjYxX2VuZAoKCS8vICppZjYxX2Vsc2VpZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA3MQoJLy8gY3VyRXhwaXJhdGlvbiA9IGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglmcmFtZV9idXJ5IDUgLy8gY3VyRXhwaXJhdGlvbjogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA3MwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKS52YWx1ZSA9IHJhd0J5dGVzKHBheW1lbnQuc2VuZGVyKQoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwNzQKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMRVIpLnZhbHVlID0gcmF3Qnl0ZXMocGF5bWVudC5zZW5kZXIpCglieXRlYyAxMCAvLyAiaS5zZWxsZXIuYSIKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIFNlbmRlcgoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDc1CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfUkVTRVJWRURfT1dORVIpLmRlbGV0ZSgpCglieXRlYyA4IC8vICJpLnJlc2VydmVkT3duZXIuYSIKCWFwcF9nbG9iYWxfZGVsCgoJLy8gKmlmNjJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDc2CgkvLyB0aGlzLmlzRm9yU2FsZSgpCgljYWxsc3ViIGlzRm9yU2FsZQoJYnogKmlmNjJfZW5kCgoJLy8gKmlmNjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA3OAoJLy8gdGhpcy5uZmRfc2FsZUNhbmNlbGxlZC5sb2coeyBhcHBJZDogdGhpcy5hcHAuaWQsIG5hbWU6IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9OQU1FKS52YWx1ZSB9KQoJYnl0ZWMgMzYgLy8gIG5mZF9zYWxlQ2FuY2VsbGVkKHVpbnQ2NCxzdHJpbmcpCglieXRlYyAwIC8vICBpbml0aWFsIGhlYWQKCWJ5dGVjIDAgLy8gIGluaXRpYWwgdGFpbAoJYnl0ZWMgNDEgLy8gIGluaXRpYWwgaGVhZCBvZmZzZXQKCXR4bmEgQXBwbGljYXRpb25zIDAKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWJ5dGVjIDQgLy8gImkubmFtZSIKCWFwcF9nbG9iYWxfZ2V0CglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJY29uY2F0Cglsb2cKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDc5CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfU0VMTF9BTU9VTlQpLmRlbGV0ZSgpCglieXRlYyA2IC8vICJpLnNlbGxhbXQiCglhcHBfZ2xvYmFsX2RlbAoKKmlmNjJfZW5kOgoKKmlmNjFfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA4MwoJLy8gdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX0VYUElSQVRJT05USU1FKS52YWx1ZSA9IGl0b2IoCgkvLyAgICAgICAgICAgICB0aGlzLmNhbGNFeHBpcmF0aW9uKHJlcVByaWNlLCBwYXltZW50LmFtb3VudCwgY3VyRXhwaXJhdGlvbiwgbWF4RXhwWWVhcnMpLAoJLy8gICAgICAgICApCglieXRlYyAxNyAvLyAiaS5leHBpcmF0aW9uVGltZSIKCWZyYW1lX2RpZyAzIC8vIG1heEV4cFllYXJzOiB1aW50NjQKCWZyYW1lX2RpZyA1IC8vIGN1ckV4cGlyYXRpb246IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgMiAvLyByZXFQcmljZTogdWludDY0CgljYWxsc3ViIGNhbGNFeHBpcmF0aW9uCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwODYKCS8vIHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9USU1FQ0hBTkdFRCkudmFsdWUgPSBpdG9iKGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wKQoJYnl0ZWMgMiAvLyAiaS50aW1lQ2hhbmdlZCIKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTA4OQoJLy8gcmVuZXdBbXQgPSBwYXltZW50LmFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9idXJ5IDYgLy8gcmVuZXdBbXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwOTAKCS8vIGdyb3NzVG9UcmVhc3VyeSA9IHJlbmV3QW10CglmcmFtZV9kaWcgNiAvLyByZW5ld0FtdDogdWludDY0CglmcmFtZV9idXJ5IDcgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDkyCgkvLyBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3MgPSBnbG9iYWxzLnplcm9BZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCWZyYW1lX2J1cnkgOSAvLyBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3M6IGFkZHJlc3MKCgkvLyAqaWY2M19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEwOTcKCS8vIHRoaXMuc2FmZUdsb2JhbEludEdldChORkRfS0VZX1BBUkVOVF9JRCkgIT09IDAKCWJ5dGVjIDI3IC8vICJpLnBhcmVudEFwcElEIgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjYzX2Vsc2UKCgkvLyAqaWY2M19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDk4CgkvLyBwYXJlbnRBcHBJZCA9IEFwcElELmZyb21VaW50NjQodGhpcy5zYWZlR2xvYmFsSW50R2V0KE5GRF9LRVlfUEFSRU5UX0lEKSkKCWJ5dGVjIDI3IC8vICJpLnBhcmVudEFwcElEIgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglmcmFtZV9idXJ5IDEwIC8vIHBhcmVudEFwcElkOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMDk5CgkvLyBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3MgPSBBZGRyZXNzLmZyb21CeXRlcyhwYXJlbnRBcHBJZC5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKSBhcyBBZGRyZXNzKQoJZnJhbWVfZGlnIDEwIC8vIHBhcmVudEFwcElkOiB1aW50NjQKCWJ5dGVjIDEgLy8gImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBwYXJlbnRBcHBJZC5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKQoJYXNzZXJ0CglmcmFtZV9idXJ5IDkgLy8gc2VnbWVudENvbW1pc3Npb25BZGRyZXNzOiBhZGRyZXNzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTEwNAoJLy8gZXh0cmFEYXlzID0gKDM2NSAqIHJlbmV3QW10KSAvIHJlcVByaWNlCglpbnRjIDggLy8gMzY1CglmcmFtZV9kaWcgNiAvLyByZW5ld0FtdDogdWludDY0CgkqCglmcmFtZV9kaWcgMiAvLyByZXFQcmljZTogdWludDY0CgkvCglmcmFtZV9idXJ5IDExIC8vIGV4dHJhRGF5czogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTEwNgoJLy8gZ3Jvc3NUb1RyZWFzdXJ5ID0gKGV4dHJhRGF5cyAqIGNvbnN0cmFpbnREYXRhLnNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ28pIC8gMzY1CglmcmFtZV9kaWcgMTEgLy8gZXh0cmFEYXlzOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGNvbnN0cmFpbnREYXRhOiAodWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgOCA4CglidG9pCgkqCglpbnRjIDggLy8gMzY1CgkvCglmcmFtZV9idXJ5IDcgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCgkvLyAqaWY2NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExMDcKCS8vIGdyb3NzVG9UcmVhc3VyeSA8IGNvbnN0cmFpbnREYXRhLnNlZ21lbnRQbGF0Zm9ybUNvc3RJbkFsZ28KCWZyYW1lX2RpZyA3IC8vIGdyb3NzVG9UcmVhc3VyeTogdWludDY0CglmcmFtZV9kaWcgMSAvLyBjb25zdHJhaW50RGF0YTogKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDggOAoJYnRvaQoJPAoJYnogKmlmNjRfZW5kCgoJLy8gKmlmNjRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTEwOAoJLy8gZ3Jvc3NUb1RyZWFzdXJ5ID0gY29uc3RyYWludERhdGEuc2VnbWVudFBsYXRmb3JtQ29zdEluQWxnbwoJZnJhbWVfZGlnIDEgLy8gY29uc3RyYWludERhdGE6ICh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWZyYW1lX2J1cnkgNyAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoKKmlmNjRfZW5kOgoJLy8gKmlmNjVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTEwCgkvLyBncm9zc1RvVHJlYXN1cnkgPj0gcmVuZXdBbXQKCWZyYW1lX2RpZyA3IC8vIGdyb3NzVG9UcmVhc3VyeTogdWludDY0CglmcmFtZV9kaWcgNiAvLyByZW5ld0FtdDogdWludDY0Cgk+PQoJYnogKmlmNjVfZW5kCgoJLy8gKmlmNjVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTExMQoJLy8gZ3Jvc3NUb1RyZWFzdXJ5ID0gcmVuZXdBbXQKCWZyYW1lX2RpZyA2IC8vIHJlbmV3QW10OiB1aW50NjQKCWZyYW1lX2J1cnkgNyAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoKKmlmNjVfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTExNAoJLy8gc2VnbWVudENvbW1pc3Npb25Ub1BheSA9IHJlbmV3QW10IC0gZ3Jvc3NUb1RyZWFzdXJ5CglmcmFtZV9kaWcgNiAvLyByZW5ld0FtdDogdWludDY0CglmcmFtZV9kaWcgNyAvLyBncm9zc1RvVHJlYXN1cnk6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSA4IC8vIHNlZ21lbnRDb21taXNzaW9uVG9QYXk6IHVpbnQ2NAoJYiAqaWY2M19lbmQKCippZjYzX2Vsc2U6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTE3CgkvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgOCAvLyBzZWdtZW50Q29tbWlzc2lvblRvUGF5OiB1aW50NjQKCippZjYzX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExMTkKCS8vIHRoaXMuZG9QYXlvdXRzKAoJLy8gICAgICAgICAgICAgZ3Jvc3NUb1RyZWFzdXJ5LAoJLy8gICAgICAgICAgICAgY29uc3RyYWludERhdGEudHJlYXN1cnlBZGRyZXNzLAoJLy8gICAgICAgICAgICAgMCwKCS8vICAgICAgICAgICAgIHNlZ21lbnRDb21taXNzaW9uVG9QYXksCgkvLyAgICAgICAgICAgICBzZWdtZW50Q29tbWlzc2lvbkFkZHJlc3MsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyA5IC8vIHNlZ21lbnRDb21taXNzaW9uQWRkcmVzczogYWRkcmVzcwoJZnJhbWVfZGlnIDggLy8gc2VnbWVudENvbW1pc3Npb25Ub1BheTogdWludDY0CglpbnRjIDAgLy8gMAoJZnJhbWVfZGlnIDEgLy8gY29uc3RyYWludERhdGE6ICh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAyNCAzMgoJZnJhbWVfZGlnIDcgLy8gZ3Jvc3NUb1RyZWFzdXJ5OiB1aW50NjQKCWNhbGxzdWIgZG9QYXlvdXRzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTEyNgoJLy8gdGhpcy5uZmRfcmVuZXdlZC5sb2coewoJLy8gICAgICAgICAgICAgYXBwSWQ6IHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgbmFtZTogdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgb3JpZ093bmVyOiBvcmlnT3duZXIsCgkvLyAgICAgICAgICAgICBidXllcjogcGF5bWVudC5zZW5kZXIsCgkvLyAgICAgICAgICAgICBwcmljZU9uZVllYXI6IHJlcVByaWNlLAoJLy8gICAgICAgICAgICAgcmVuZXdBbW91bnQ6IHBheW1lbnQuYW1vdW50LAoJLy8gICAgICAgICAgICAgZXhwVGltZTogYnRvaSh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfRVhQSVJBVElPTlRJTUUpLnZhbHVlKSwKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweDE0YTc2YTNlIC8vIG5mZF9yZW5ld2VkKHVpbnQ2NCxzdHJpbmcsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZWMgMCAvLyAgaW5pdGlhbCBoZWFkCglieXRlYyAwIC8vICBpbml0aWFsIHRhaWwKCXB1c2hieXRlcyAweDAwNjIgLy8gaW5pdGlhbCBoZWFkIG9mZnNldAoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJYnl0ZWMgNCAvLyAiaS5uYW1lIgoJYXBwX2dsb2JhbF9nZXQKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDQgLy8gb3JpZ093bmVyOiBhZGRyZXNzCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTEgLy8gcGF5bWVudDogUGF5VHhuCglndHhucyBTZW5kZXIKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAyIC8vIHJlcVByaWNlOiB1aW50NjQKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJYnl0ZWMgMTcgLy8gImkuZXhwaXJhdGlvblRpbWUiCglhcHBfZ2xvYmFsX2dldAoJYnRvaQoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyBzZXRQcmltYXJ5QWRkcmVzcyhzdHJpbmcsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfc2V0UHJpbWFyeUFkZHJlc3M6CgkvLyBhZGRyZXNzOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGFkZHJlc3MpIGZvciBzZXRQcmltYXJ5QWRkcmVzcyBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZmllbGROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBzZXRQcmltYXJ5QWRkcmVzcyhzdHJpbmcsYWRkcmVzcyl2b2lkCgljYWxsc3ViIHNldFByaW1hcnlBZGRyZXNzCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBzZXRQcmltYXJ5QWRkcmVzcyhmaWVsZE5hbWU6IHN0cmluZywgYWRkcmVzczogQWRkcmVzcyk6IHZvaWQKc2V0UHJpbWFyeUFkZHJlc3M6Cglwcm90byAyIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTM5CgkvLyB0aGlzLmFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIGFzc2VydE93bmVyQ2FsbGVkTm90Rm9yU2FsZU9yRXhwaXJlZAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNDEKCS8vIGFzc2VydChmaWVsZE5hbWUgPT09IE5GRF9GSUVMRF9DQV9WRVJJRklFRF9TRVQpCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBzdHJpbmcKCXB1c2hieXRlcyAidi5jYUFsZ28uMC5hcyIKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTQyCgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNDMKCS8vIHRoaXMuZmluZEFkZHJBbmRTZXRGaXJzdChmaWVsZE5hbWUsIGFkZHJlc3MpCglmcmFtZV9kaWcgLTIgLy8gYWRkcmVzczogQWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkTmFtZTogc3RyaW5nCgljYWxsc3ViIGZpbmRBZGRyQW5kU2V0Rmlyc3QKCXJldHN1YgoKLy8gcmVnaXN0cnlBZGRpbmdWZXJpZmllZEFkZHJlc3Moc3RyaW5nLHN0cmluZylib29sCiphYmlfcm91dGVfcmVnaXN0cnlBZGRpbmdWZXJpZmllZEFkZHJlc3M6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDExIC8vIDB4MTUxZjdjNzUKCgkvLyBmaWVsZFNldE5hbWU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyBmaWVsZEJlaW5nVmVyaWZpZWQ6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIHJlZ2lzdHJ5QWRkaW5nVmVyaWZpZWRBZGRyZXNzKHN0cmluZyxzdHJpbmcpYm9vbAoJY2FsbHN1YiByZWdpc3RyeUFkZGluZ1ZlcmlmaWVkQWRkcmVzcwoJYnl0ZWMgMjkgLy8gMHgwMAoJaW50YyAwIC8vIDAKCXVuY292ZXIgMgoJc2V0Yml0Cgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gcmVnaXN0cnlBZGRpbmdWZXJpZmllZEFkZHJlc3MoZmllbGRCZWluZ1ZlcmlmaWVkOiBzdHJpbmcsIGZpZWxkU2V0TmFtZTogc3RyaW5nKTogYm9vbGVhbgovLwovLyBBcHByb3ZlZCBjYWxsIGZyb20gcmVnaXN0cnkgaW5zdHJ1Y3RpbmcgdXMgdG8gbW92ZSB0aGUgc3BlY2lmaWVkIHUuY2F2Lnh4IGZpZWxkIGFuZCBhZGQgdG8gdGhlIHNwZWNpZmllZAovLyB2ZXJpZmllZCBmaWVsZC4KLy8KLy8gQHBhcmFtIGZpZWxkQmVpbmdWZXJpZmllZCAtIHt1c2VyLWRlZmluZWQgZmllbGQgdG8gJ3ZlcmlmeScgLSBieSBhZGRpbmcgdG8gc3BlY2lmaWVkIHZlcmlmaWVkIHNldAovLyBpZTogdS5jYXYuYWxnby5hIC0gdXNlci1kZWZpbmVkIHByZS12ZXJpZnl9IC0gTVVTVCBTVEFSVCB3aXRoIHUuY2F2LiAoISkKLy8gZ2V0cyAnYWRkZWQnIHRvICdzZXQnIGluIG5leHQgYXJnIC0gbXVzdCBiZSBmaXhlZC1zaXplZCBieXRlcwovLyBAcGFyYW0gZmllbGRTZXROYW1lIC0ge2ZpZWxkIHNldCBuYW1lIC0gaWU6IHYuY2FBbGdvLjAuYXMsIHYuY2FFdGguMC5hc30gKG11c3QgQkUgdi5jYVsuLi5dLmFzKQovLyBAcmV0dXJucyB0cnVlIGlmIGFkZGVkIG9yIGFscmVhZHkgcHJlc2VudCwgZmFsc2Ugb3RoZXJ3aXNlCnJlZ2lzdHJ5QWRkaW5nVmVyaWZpZWRBZGRyZXNzOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTU3CgkvLyBhc3NlcnQoZ2xvYmFscy5jYWxsZXJBcHBsaWNhdGlvbklEID09PSBBcHBJRC5mcm9tVWludDY0KHRoaXMucmVnaXN0cnlBcHBJZCksICdjYWxsZXIgbXVzdCBiZSBORkQgcmVnaXN0cnkhJykKCWdsb2JhbCBDYWxsZXJBcHBsaWNhdGlvbklECglpbnRjIDQgLy8gVE1QTF9yZWdpc3RyeUFwcElkCgk9PQoKCS8vIGNhbGxlciBtdXN0IGJlIE5GRCByZWdpc3RyeSEKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNTgKCS8vIHRoaXMubm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIG5vdEZvclNhbGVPckV4cGlyZWQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTU5CgkvLyBhc3NlcnQoZXh0cmFjdDMoZmllbGRCZWluZ1ZlcmlmaWVkLCAwLCA2KSA9PT0gJ3UuY2F2LicsICdmaWVsZCBiZWluZyB2ZXJpZmllZCBNVVNUIFNUQVJUIHdpdGggdS5jYXYnKQoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkQmVpbmdWZXJpZmllZDogc3RyaW5nCglleHRyYWN0IDAgNgoJcHVzaGJ5dGVzIDB4NzUyZTYzNjE3NjJlIC8vICJ1LmNhdi4iCgk9PQoKCS8vIGZpZWxkIGJlaW5nIHZlcmlmaWVkIE1VU1QgU1RBUlQgd2l0aCB1LmNhdgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTE2MAoJLy8gYXNzZXJ0KGV4dHJhY3QzKGZpZWxkU2V0TmFtZSwgMCwgNCkgPT09ICd2LmNhJywgJ2Rlc3RpbmF0aW9uIGZpZWxkIE1VU1QgU1RBUlQgd2l0aCB2LmNhWy4uLi5dJykKCWZyYW1lX2RpZyAtMiAvLyBmaWVsZFNldE5hbWU6IHN0cmluZwoJZXh0cmFjdCAwIDQKCWJ5dGVjIDM4IC8vICAidi5jYSIKCT09CgoJLy8gZGVzdGluYXRpb24gZmllbGQgTVVTVCBTVEFSVCB3aXRoIHYuY2FbLi4uLl0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNjEKCS8vIGFzc2VydChleHRyYWN0MyhmaWVsZFNldE5hbWUsIGxlbihmaWVsZFNldE5hbWUpIC0gMywgMykgPT09ICcuYXMnLCAnZGVzdGluYXRpb24gZmllbGQgbXVzdCBlbmQgRU5EIHdpdGggLmFzJykKCWZyYW1lX2RpZyAtMiAvLyBmaWVsZFNldE5hbWU6IHN0cmluZwoJZnJhbWVfZGlnIC0yIC8vIGZpZWxkU2V0TmFtZTogc3RyaW5nCglsZW4KCWludGMgNiAvLyAzCgktCglpbnRjIDYgLy8gMwoJZXh0cmFjdDMKCWJ5dGVjIDM5IC8vICAiLmFzIgoJPT0KCgkvLyBkZXN0aW5hdGlvbiBmaWVsZCBtdXN0IGVuZCBFTkQgd2l0aCAuYXMKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNjIKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIHRoaXMuYm94ZXMoZmllbGRCZWluZ1ZlcmlmaWVkKS5leGlzdHMsCgkvLyAgICAgICAgICAgICAncmVmZXJlbmNlZCBmaWVsZCB0byBhZGQgYXMgdmVyaWZpZWQgYWRkcmVzcyBtdXN0IGhhdmUgdmFsdWUgaW4gYm94IHN0b3JhZ2UnLAoJLy8gICAgICAgICApCglmcmFtZV9kaWcgLTEgLy8gZmllbGRCZWluZ1ZlcmlmaWVkOiBzdHJpbmcKCWJveF9sZW4KCXN3YXAKCXBvcAoKCS8vIHJlZmVyZW5jZWQgZmllbGQgdG8gYWRkIGFzIHZlcmlmaWVkIGFkZHJlc3MgbXVzdCBoYXZlIHZhbHVlIGluIGJveCBzdG9yYWdlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTY2CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNjgKCS8vIGZpZWxkVmFsdWUgPSB0aGlzLmJveGVzKGZpZWxkQmVpbmdWZXJpZmllZCkudmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEJlaW5nVmVyaWZpZWQ6IHN0cmluZwoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhmaWVsZEJlaW5nVmVyaWZpZWQpLnZhbHVlCglhc3NlcnQKCWZyYW1lX2J1cnkgMCAvLyBmaWVsZFZhbHVlOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTY5CgkvLyB0aGlzLmJveGVzKGZpZWxkQmVpbmdWZXJpZmllZCkuZGVsZXRlKCkKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEJlaW5nVmVyaWZpZWQ6IHN0cmluZwoJYm94X2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExNzEKCS8vIHRoaXMubmZkX2FkZHJlc3NMaW5rZWQubG9nKHsKCS8vICAgICAgICAgICAgIGFwcElkOiB0aGlzLmFwcC5pZCwKCS8vICAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9OQU1FKS52YWx1ZSwKCS8vICAgICAgICAgICAgIGFkZHJlc3M6IEFkZHJlc3MuZnJvbUJ5dGVzKGZpZWxkVmFsdWUpLAoJLy8gICAgICAgICB9KQoJcHVzaGJ5dGVzIDB4Y2Y5ZDFlMjQgLy8gbmZkX2FkZHJlc3NMaW5rZWQodWludDY0LHN0cmluZyxhZGRyZXNzKQoJYnl0ZWMgMCAvLyAgaW5pdGlhbCBoZWFkCglieXRlYyAwIC8vICBpbml0aWFsIHRhaWwKCWJ5dGVjIDQyIC8vICBpbml0aWFsIGhlYWQgb2Zmc2V0Cgl0eG5hIEFwcGxpY2F0aW9ucyAwCglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglieXRlYyA0IC8vICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldAoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMCAvLyBmaWVsZFZhbHVlOiBieXRlW10KCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJY29uY2F0Cglsb2cKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTc3CgkvLyByZXR1cm4gdGhpcy5hZGRCeXRlc1RvU2V0KGZpZWxkU2V0TmFtZSwgZmllbGRWYWx1ZSkKCWZyYW1lX2RpZyAwIC8vIGZpZWxkVmFsdWU6IGJ5dGVbXQoJZnJhbWVfZGlnIC0yIC8vIGZpZWxkU2V0TmFtZTogc3RyaW5nCgljYWxsc3ViIGFkZEJ5dGVzVG9TZXQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gcmVnaXN0cnlSZW1vdmluZ1ZlcmlmaWVkQWRkcmVzcyhzdHJpbmcsYWRkcmVzcyxhZGRyZXNzKWJvb2wKKmFiaV9yb3V0ZV9yZWdpc3RyeVJlbW92aW5nVmVyaWZpZWRBZGRyZXNzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAxMSAvLyAweDE1MWY3Yzc1CgoJLy8gbWJyUmVmdW5kRGVzdDogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChtYnJSZWZ1bmREZXN0KSBmb3IgcmVnaXN0cnlSZW1vdmluZ1ZlcmlmaWVkQWRkcmVzcyBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gYWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAxIChhZGRyZXNzKSBmb3IgcmVnaXN0cnlSZW1vdmluZ1ZlcmlmaWVkQWRkcmVzcyBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZmllbGRCZWluZ0NoYW5nZWQ6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIHJlZ2lzdHJ5UmVtb3ZpbmdWZXJpZmllZEFkZHJlc3Moc3RyaW5nLGFkZHJlc3MsYWRkcmVzcylib29sCgljYWxsc3ViIHJlZ2lzdHJ5UmVtb3ZpbmdWZXJpZmllZEFkZHJlc3MKCWJ5dGVjIDI5IC8vIDB4MDAKCWludGMgMCAvLyAwCgl1bmNvdmVyIDIKCXNldGJpdAoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHJlZ2lzdHJ5UmVtb3ZpbmdWZXJpZmllZEFkZHJlc3MoZmllbGRCZWluZ0NoYW5nZWQ6IHN0cmluZywgYWRkcmVzczogQWRkcmVzcywgbWJyUmVmdW5kRGVzdDogQWRkcmVzcyk6IGJvb2xlYW4KLy8KLy8gQXBwcm92ZWQgY2FsbCBmcm9tIHJlZ2lzdHJ5IGluc3RydWN0aW5nIHVzIHRvIFJFTU9WRSBhbiBhZGRyZXNzIGZyb20gdGhlIHNwZWNpZmllZCB2ZXJpZmllZCBhZGRyZXNzIHNldAovLwovLyBAcGFyYW0ge3N0cmluZ30gZmllbGRCZWluZ0NoYW5nZWQgLSBUaGUgZmllbGQgYmVpbmcgY2hhbmdlZCBpbiB0aGUgYWRkcmVzcyByZWdpc3RyeS4KLy8gQHBhcmFtIHtBZGRyZXNzfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBmaWVsZC4KLy8gQHBhcmFtIHtBZGRyZXNzfSBtYnJSZWZ1bmREZXN0IC0gdGhlIGFkZHJlc3MgdG8gc2VuZCByZWNsYWltZWQgTUJSIChpZiBhbnkpCi8vIEByZXR1cm4ge2Jvb2xlYW59IC0gdHJ1ZSBpZiB2YWxpZCByZW1vdmVkCnJlZ2lzdHJ5UmVtb3ZpbmdWZXJpZmllZEFkZHJlc3M6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTE4OQoJLy8gYXNzZXJ0KGdsb2JhbHMuY2FsbGVyQXBwbGljYXRpb25JRCA9PT0gQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpLCAnY2FsbGVyIG11c3QgYmUgTkZEIHJlZ2lzdHJ5IScpCglnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAoJaW50YyA0IC8vIFRNUExfcmVnaXN0cnlBcHBJZAoJPT0KCgkvLyBjYWxsZXIgbXVzdCBiZSBORkQgcmVnaXN0cnkhCglhc3NlcnQKCgkvLyAqaWY2Nl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExOTEKCS8vICF0aGlzLmlzRXhwaXJlZCgpCgljYWxsc3ViIGlzRXhwaXJlZAoJIQoJYnogKmlmNjZfZW5kCgoJLy8gKmlmNjZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTE5MgoJLy8gYXNzZXJ0KCF0aGlzLmlzRm9yU2FsZSgpLCAiY2FuJ3QgYmUgZm9yIHNhbGUiKQoJY2FsbHN1YiBpc0ZvclNhbGUKCSEKCgkvLyBjYW4ndCBiZSBmb3Igc2FsZQoJYXNzZXJ0CgoqaWY2Nl9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTk0CgkvLyBhc3NlcnQoZXh0cmFjdDMoZmllbGRCZWluZ0NoYW5nZWQsIDAsIDQpID09PSAndi5jYScsICd2ZXJpZmllZCBmaWVsZCBNVVNUIFNUQVJUIHdpdGggdi5jYVsuLi4uXScpCglmcmFtZV9kaWcgLTEgLy8gZmllbGRCZWluZ0NoYW5nZWQ6IHN0cmluZwoJZXh0cmFjdCAwIDQKCWJ5dGVjIDM4IC8vICAidi5jYSIKCT09CgoJLy8gdmVyaWZpZWQgZmllbGQgTVVTVCBTVEFSVCB3aXRoIHYuY2FbLi4uLl0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjExOTUKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIGV4dHJhY3QzKGZpZWxkQmVpbmdDaGFuZ2VkLCBsZW4oZmllbGRCZWluZ0NoYW5nZWQpIC0gMywgMykgPT09ICcuYXMnLAoJLy8gICAgICAgICAgICAgJ3ZlcmlmaWVkIGZpZWxkIG11c3QgZW5kIEVORCB3aXRoIC5hcycsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEJlaW5nQ2hhbmdlZDogc3RyaW5nCglmcmFtZV9kaWcgLTEgLy8gZmllbGRCZWluZ0NoYW5nZWQ6IHN0cmluZwoJbGVuCglpbnRjIDYgLy8gMwoJLQoJaW50YyA2IC8vIDMKCWV4dHJhY3QzCglieXRlYyAzOSAvLyAgIi5hcyIKCT09CgoJLy8gdmVyaWZpZWQgZmllbGQgbXVzdCBlbmQgRU5EIHdpdGggLmFzCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMTk5CgkvLyB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfVElNRUNIQU5HRUQpLnZhbHVlID0gaXRvYihnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWJ5dGVjIDIgLy8gImkudGltZUNoYW5nZWQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyMDEKCS8vIGV4aXN0aW5nU2l6ZSA9IHRoaXMuYm94ZXMoZmllbGRCZWluZ0NoYW5nZWQpLnNpemUKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEJlaW5nQ2hhbmdlZDogc3RyaW5nCglib3hfbGVuCgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGZpZWxkQmVpbmdDaGFuZ2VkKS5zaXplCglhc3NlcnQKCWZyYW1lX2J1cnkgMCAvLyBleGlzdGluZ1NpemU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyMDIKCS8vIHJlbW92ZWQgPSB0aGlzLnJlbW92ZUFkZHJGcm9tU2V0KGZpZWxkQmVpbmdDaGFuZ2VkLCBhZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZEJlaW5nQ2hhbmdlZDogc3RyaW5nCgljYWxsc3ViIHJlbW92ZUFkZHJGcm9tU2V0CglmcmFtZV9idXJ5IDEgLy8gcmVtb3ZlZDogYm9vbAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyMDQKCS8vIHRoaXMubmZkX2FkZHJlc3NVbmxpbmtlZC5sb2coewoJLy8gICAgICAgICAgICAgYXBwSWQ6IHRoaXMuYXBwLmlkLAoJLy8gICAgICAgICAgICAgbmFtZTogdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLAoJLy8gICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcywKCS8vICAgICAgICAgfSkKCXB1c2hieXRlcyAweGE0ZDNiOWE3IC8vIG5mZF9hZGRyZXNzVW5saW5rZWQodWludDY0LHN0cmluZyxhZGRyZXNzKQoJYnl0ZWMgMCAvLyAgaW5pdGlhbCBoZWFkCglieXRlYyAwIC8vICBpbml0aWFsIHRhaWwKCWJ5dGVjIDQyIC8vICBpbml0aWFsIGhlYWQgb2Zmc2V0Cgl0eG5hIEFwcGxpY2F0aW9ucyAwCglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglieXRlYyA0IC8vICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldAoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTIgLy8gYWRkcmVzczogQWRkcmVzcwoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCgljb25jYXQKCWxvZwoKCS8vICppZjY3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxMAoJLy8gIXRoaXMuYm94ZXMoZmllbGRCZWluZ0NoYW5nZWQpLmV4aXN0cwoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkQmVpbmdDaGFuZ2VkOiBzdHJpbmcKCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYnogKmlmNjdfZW5kCgoJLy8gKmlmNjdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxMgoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgICAgICAgICAgIGFtb3VudDogU0NCT1hfUEVSQk9YICsgU0NCT1hfUEVSQllURSAqIChmaWVsZEJlaW5nQ2hhbmdlZC5sZW5ndGggKyBleGlzdGluZ1NpemUpLAoJLy8gICAgICAgICAgICAgICAgIHJlY2VpdmVyOiBtYnJSZWZ1bmREZXN0LAoJLy8gICAgICAgICAgICAgICAgIG5vdGU6ICdib3hSZWZ1bmQnLAoJLy8gICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxMwoJLy8gYW1vdW50OiBTQ0JPWF9QRVJCT1ggKyBTQ0JPWF9QRVJCWVRFICogKGZpZWxkQmVpbmdDaGFuZ2VkLmxlbmd0aCArIGV4aXN0aW5nU2l6ZSkKCWludGMgMTIgLy8gMjUwMAoJaW50YyA5IC8vIDQwMAoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkQmVpbmdDaGFuZ2VkOiBzdHJpbmcKCWxlbgoJZnJhbWVfZGlnIDAgLy8gZXhpc3RpbmdTaXplOiB1aW50NjQKCSsKCSoKCSsKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxNAoJLy8gcmVjZWl2ZXI6IG1iclJlZnVuZERlc3QKCWZyYW1lX2RpZyAtMyAvLyBtYnJSZWZ1bmREZXN0OiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxNQoJLy8gbm90ZTogJ2JveFJlZnVuZCcKCWJ5dGVjIDMxIC8vICAiYm94UmVmdW5kIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmNjdfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIxOQoJLy8gcmV0dXJuIHJlbW92ZWQKCWZyYW1lX2RpZyAxIC8vIHJlbW92ZWQ6IGJvb2wKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxCglyZXRzdWIKCi8vIGdldFJlbmV3UHJpY2VEYXRhKGNhbGxlcjogQWRkcmVzcyk6IFByaWNlSW5mbwovLwovLyBSZXRyaWV2ZXMgdGhlIHJlbmV3IHByaWNlIGRhdGEgZm9yIGEgZ2l2ZW4gc2VuZGVyIGFkZHJlc3MuCi8vCi8vIEBwYXJhbSBjYWxsZXIgLSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VuZGVyLgovLyBAcmV0dXJucyB7UHJpY2VJbmZvfQpnZXRSZW5ld1ByaWNlRGF0YToKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyMzAKCS8vIHJldHVybiBzZW5kTWV0aG9kQ2FsbDx0eXBlb2YgTkZEUmVnaXN0cnkucHJvdG90eXBlLmdldFByaWNlPih7CgkvLyAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KHRoaXMucmVnaXN0cnlBcHBJZCksCgkvLyAgICAgICAgICAgICBtZXRob2RBcmdzOiBbdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLCBjYWxsZXJdLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglwdXNoYnl0ZXMgMHhmZmMyMzAzYyAvLyBtZXRob2QgImdldFByaWNlKHN0cmluZyxhZGRyZXNzKSh1aW50NjQsdWludDY0LGJvb2wsYm9vbCxib29sKSIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTIzMQoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnJlZ2lzdHJ5QXBwSWQpCglpbnRjIDQgLy8gVE1QTF9yZWdpc3RyeUFwcElkCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjMyCgkvLyBtZXRob2RBcmdzOiBbdGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX05BTUUpLnZhbHVlLCBjYWxsZXJdCglieXRlYyA0IC8vICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldAoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgLTEgLy8gY2FsbGVyOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gTnVtTG9ncwoJaW50YyAxIC8vIDEKCS0KCWl0eG5hcyBMb2dzCglleHRyYWN0IDQgMAoJcmV0c3ViCgovLyB2YXVsdE9wdEluRnJvbUFyZ3MoKTogdm9pZAp2YXVsdE9wdEluRnJvbUFyZ3M6Cglwcm90byAwIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI0MwoJLy8gdGhpcy5ub3RGb3JTYWxlT3JFeHBpcmVkKCkKCWNhbGxzdWIgbm90Rm9yU2FsZU9yRXhwaXJlZAoKCS8vICppZjY4X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI0NwoJLy8gdGhpcy5pc1ZhdWx0QXV0b09wdEluTG9ja2VkKCkKCWNhbGxzdWIgaXNWYXVsdEF1dG9PcHRJbkxvY2tlZAoJYnogKmlmNjhfZW5kCgoJLy8gKmlmNjhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI0OAoJLy8gYXNzZXJ0KHJhd0J5dGVzKHRoaXMudHhuLnNlbmRlcikgPT09IHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikudmFsdWUsICdzZW5kZXIgbXVzdCBiZSBvd25lcicpCgl0eG4gU2VuZGVyCglieXRlYyAxIC8vICJpLm93bmVyLmEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyBzZW5kZXIgbXVzdCBiZSBvd25lcgoJYXNzZXJ0CgoqaWY2OF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjUxCgkvLyBhc3NlcnQodGhpcy50eG4uZ3JvdXBJbmRleCA+IDAsICdwYXJ0IG9mIG9wdC1pbiBmb3IgbmV3IGFzc2V0LCBtdXN0IGhhdmUgcHJpb3IgdHhuIHBheWluZyBNQlInKQoJdHhuIEdyb3VwSW5kZXgKCWludGMgMCAvLyAwCgk+CgoJLy8gcGFydCBvZiBvcHQtaW4gZm9yIG5ldyBhc3NldCwgbXVzdCBoYXZlIHByaW9yIHR4biBwYXlpbmcgTUJSCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjUzCgkvLyB2ZXJpZnlQYXlUeG4odGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMV0sIHsKCS8vICAgICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgICAgICAgYW1vdW50OiAxMDBfMDAwICogKHRoaXMudHhuLm51bUFwcEFyZ3MgLSAxKSwKCS8vICAgICAgICAgfSkKCXR4biBHcm91cEluZGV4CglpbnRjIDEgLy8gMQoJLQoJc3RvcmUgMjQ4IC8vIHZlcmlmeVR4biBpbmRleAoKCS8vIHZlcmlmeSBwYXkKCWxvYWQgMjQ4IC8vIHZlcmlmeVR4biBpbmRleAoJZ3R4bnMgVHlwZUVudW0KCWludGMgMSAvLyAgcGF5Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoidGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMV0iLCJmaWVsZCI6InR5cGVFbnVtIiwiZXhwZWN0ZWQiOiJwYXkifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHJlY2VpdmVyCglsb2FkIDI0OCAvLyB2ZXJpZnlUeG4gaW5kZXgKCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InRoaXMudHhuR3JvdXBbdGhpcy50eG4uZ3JvdXBJbmRleCAtIDFdIiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50Cglsb2FkIDI0OCAvLyB2ZXJpZnlUeG4gaW5kZXgKCWd0eG5zIEFtb3VudAoJaW50YyAxNiAvLyAxMDBfMDAwCgl0eG4gTnVtQXBwQXJncwoJaW50YyAxIC8vIDEKCS0KCSoKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJ0aGlzLnR4bkdyb3VwW3RoaXMudHhuLmdyb3VwSW5kZXggLSAxXSIsImZpZWxkIjoiYW1vdW50IiwiZXhwZWN0ZWQiOiIxMDBfMDAwICogKHRoaXMudHhuLm51bUFwcEFyZ3MgLSAxKSJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjU3CgkvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAxOyBpIDwgdGhpcy50eG4ubnVtQXBwQXJnczsgaSArPSAxKQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgMCAvLyBpOiB1aW50NjQKCipmb3JfODoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNTcKCS8vIGkgPCB0aGlzLnR4bi5udW1BcHBBcmdzCglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCXR4biBOdW1BcHBBcmdzCgk8CglieiAqZm9yXzhfZW5kCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI1OAoJLy8gYXNzZXRJZCA9IEFzc2V0SUQuZnJvbVVpbnQ2NChidG9pKHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbaV0pKQoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0Cgl0eG5hcyBBcHBsaWNhdGlvbkFyZ3MKCWJ0b2kKCWZyYW1lX2J1cnkgMSAvLyBhc3NldElkOiB1aW50NjQKCgkvLyAqaWY2OV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNjAKCS8vICF0aGlzLmFwcC5hZGRyZXNzLmlzT3B0ZWRJblRvQXNzZXQoYXNzZXRJZCkKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglmcmFtZV9kaWcgMSAvLyBhc3NldElkOiB1aW50NjQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJc3dhcAoJcG9wCgkhCglieiAqaWY2OV9lbmQKCgkvLyAqaWY2OV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjYxCgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgICAgICAgICAgICAgIHhmZXJBc3NldDogYXNzZXRJZCwKCS8vICAgICAgICAgICAgICAgICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgICAgICAgICAgICAgYXNzZXRBbW91bnQ6IDAsCgkvLyAgICAgICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMTAgLy8gIGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI2MgoJLy8geGZlckFzc2V0OiBhc3NldElkCglmcmFtZV9kaWcgMSAvLyBhc3NldElkOiB1aW50NjQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI2MwoJLy8gYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNjQKCS8vIGFzc2V0QW1vdW50OiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjY5X2VuZDoKCipmb3JfOF9jb250aW51ZToKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNTcKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAwIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzgKCipmb3JfOF9lbmQ6CglyZXRzdWIKCi8vIHNhZmVHbG9iYWxCeXRlR2V0KGtleTogYnl0ZXMpOiBieXRlcwpzYWZlR2xvYmFsQnl0ZUdldDoKCXByb3RvIDEgMQoKCS8vICppZjcwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI3MQoJLy8gIXRoaXMuZ2xvYmFsU3RhdGUoa2V5KS5leGlzdHMKCXR4bmEgQXBwbGljYXRpb25zIDAKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglieiAqaWY3MF9lbmQKCgkvLyAqaWY3MF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjcyCgkvLyByZXR1cm4gJycKCWJ5dGVjIDAgLy8gICIiCglyZXRzdWIKCippZjcwX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyNzQKCS8vIHJldHVybiB0aGlzLmdsb2JhbFN0YXRlKGtleSkudmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglhcHBfZ2xvYmFsX2dldAoJcmV0c3ViCgovLyBzYWZlR2xvYmFsQnl0ZUdldEV4KGFwcElkOiB1aW50NjQsIGtleTogYnl0ZXMpOiBieXRlcwpzYWZlR2xvYmFsQnl0ZUdldEV4OgoJcHJvdG8gMiAxCgoJLy8gKmlmNzFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjc4CgkvLyAhQXBwSUQuZnJvbVVpbnQ2NChhcHBJZCkuZ2xvYmFsU3RhdGVFeGlzdHMoa2V5KQoJZnJhbWVfZGlnIC0xIC8vIGFwcElkOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBrZXk6IGJ5dGVzCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglieiAqaWY3MV9lbmQKCgkvLyAqaWY3MV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMjc5CgkvLyByZXR1cm4gJycKCWJ5dGVjIDAgLy8gICIiCglyZXRzdWIKCippZjcxX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyODEKCS8vIHJldHVybiBBcHBJRC5mcm9tVWludDY0KGFwcElkKS5nbG9iYWxTdGF0ZShrZXkpIGFzIGJ5dGVzCglmcmFtZV9kaWcgLTEgLy8gYXBwSWQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIGtleTogYnl0ZXMKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KGFwcElkKS5nbG9iYWxTdGF0ZShrZXkpCglhc3NlcnQKCXJldHN1YgoKLy8gc2FmZUdsb2JhbEludEdldChrZXk6IGJ5dGVzKTogdWludDY0CnNhZmVHbG9iYWxJbnRHZXQ6Cglwcm90byAxIDEKCgkvLyAqaWY3Ml9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyODUKCS8vICF0aGlzLmdsb2JhbFN0YXRlKGtleSkuZXhpc3RzCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYnogKmlmNzJfZW5kCgoJLy8gKmlmNzJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI4NgoJLy8gcmV0dXJuIDAKCWludGMgMCAvLyAwCglyZXRzdWIKCippZjcyX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEyODgKCS8vIHJldHVybiBidG9pKHRoaXMuZ2xvYmFsU3RhdGUoa2V5KS52YWx1ZSkKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglhcHBfZ2xvYmFsX2dldAoJYnRvaQoJcmV0c3ViCgovLyBpc0N1cnJlbnRUeG5Db250cmFjdEF1dGhvcml0eSgpOiBib29sZWFuCmlzQ3VycmVudFR4bkNvbnRyYWN0QXV0aG9yaXR5OgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTI5NAoJLy8gcmV0dXJuIHRoaXMudHhuLnNlbmRlci5hc3NldEJhbGFuY2UodGhpcy5hZG1pbkFzYUlkKSA9PT0gMQoJdHhuIFNlbmRlcgoJaW50YyAyMCAvLyBUTVBMX2FkbWluQXNhSWQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglpbnRjIDEgLy8gMQoJPT0KCXJldHN1YgoKLy8gaXNGaWVsZERlbGV0ZUFsbG93ZWQoZmllbGROYW1lOiBieXRlcywgYWRtaW5SaWdodHM6IGJvb2xlYW4pOiBib29sZWFuCmlzRmllbGREZWxldGVBbGxvd2VkOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzEyCgkvLyB0cnVzdFR5cGUgPSBleHRyYWN0MyhmaWVsZE5hbWUsIDAsIDIpCglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBieXRlcwoJZXh0cmFjdCAwIDIKCWZyYW1lX2J1cnkgMCAvLyB0cnVzdFR5cGU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzMTQKCS8vIGFzc2VydCghdGhpcy5pc0ludGVybmFsRmllbGQodHJ1c3RUeXBlKSwgJ2ludGVybmFsIGZpZWxkcyBjYW4gbmV2ZXIgYmUgZGVsZXRlZCcpCglmcmFtZV9kaWcgMCAvLyB0cnVzdFR5cGU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ludGVybmFsRmllbGQKCSEKCgkvLyBpbnRlcm5hbCBmaWVsZHMgY2FuIG5ldmVyIGJlIGRlbGV0ZWQKCWFzc2VydAoKCS8vICppZjczX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTMxNwoJLy8gYWRtaW5SaWdodHMKCWZyYW1lX2RpZyAtMiAvLyBhZG1pblJpZ2h0czogYm9vbGVhbgoJYnogKmlmNzNfZW5kCgoJLy8gKmlmNzNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTMxOAoJLy8gcmV0dXJuIHRydWUKCWludGMgMSAvLyAxCgliICppc0ZpZWxkRGVsZXRlQWxsb3dlZCpyZXR1cm4KCippZjczX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzMjEKCS8vIGFzc2VydChsZW4odGhpcy5zYWZlR2xvYmFsQnl0ZUdldChORkRfS0VZX09XTkVSKSkgPT09IDMyLCAnbXVzdCBiZSBvd25lZCcpCglieXRlYyAxIC8vICJpLm93bmVyLmEiCgljYWxsc3ViIHNhZmVHbG9iYWxCeXRlR2V0CglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBtdXN0IGJlIG93bmVkCglhc3NlcnQKCgkvLyAqaWY3NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzMjMKCS8vICF0aGlzLmlzRXhwaXJlZCgpCgljYWxsc3ViIGlzRXhwaXJlZAoJIQoJYnogKmlmNzRfZW5kCgoJLy8gKmlmNzRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTMyNAoJLy8gYXNzZXJ0KCF0aGlzLmlzRm9yU2FsZSgpLCAiY2FuJ3QgYmUgZm9yIHNhbGUiKQoJY2FsbHN1YiBpc0ZvclNhbGUKCSEKCgkvLyBjYW4ndCBiZSBmb3Igc2FsZQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTMyNQoJLy8gdGhpcy5tdXN0QmVDYWxsZWRCeU93bmVyKCkKCWNhbGxzdWIgbXVzdEJlQ2FsbGVkQnlPd25lcgoKKmlmNzRfZW5kOgoJLy8gKmlmNzVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzI4CgkvLyB0aGlzLmlzVXNlckZpZWxkKHRydXN0VHlwZSkKCWZyYW1lX2RpZyAwIC8vIHRydXN0VHlwZTogYnl0ZVtdCgljYWxsc3ViIGlzVXNlckZpZWxkCglieiAqaWY3NV9lbmQKCgkvLyAqaWY3NV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzI5CgkvLyByZXR1cm4gdHJ1ZQoJaW50YyAxIC8vIDEKCWIgKmlzRmllbGREZWxldGVBbGxvd2VkKnJldHVybgoKKmlmNzVfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTMzMgoJLy8gcmV0dXJuIHRoaXMuaXNWZXJpZmllZEZpZWxkKHRydXN0VHlwZSkgJiYgIShleHRyYWN0MyhmaWVsZE5hbWUsIDAsIDgpID09PSAndi5jYUFsZ28nKQoJZnJhbWVfZGlnIDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCWNhbGxzdWIgaXNWZXJpZmllZEZpZWxkCglkdXAKCWJ6ICpza2lwX2FuZDE3CglmcmFtZV9kaWcgLTEgLy8gZmllbGROYW1lOiBieXRlcwoJZXh0cmFjdCAwIDgKCWJ5dGVjIDMzIC8vICAidi5jYUFsZ28iCgk9PQoJIQoJJiYKCipza2lwX2FuZDE3OgoKKmlzRmllbGREZWxldGVBbGxvd2VkKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBpc0ZpZWxkVXBkYXRlQWxsb3dlZChuYW1lOiBieXRlcywgdmFsdWU6IGJ5dGVzLCBhZG1pblJpZ2h0czogYm9vbGVhbik6IGJvb2xlYW4KaXNGaWVsZFVwZGF0ZUFsbG93ZWQ6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiAyCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM0OAoJLy8gdHJ1c3RUeXBlID0gZXh0cmFjdDMobmFtZSwgMCwgMikKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBieXRlcwoJZXh0cmFjdCAwIDIKCWZyYW1lX2J1cnkgMCAvLyB0cnVzdFR5cGU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzNTAKCS8vIGFzc2VydCghdGhpcy5pc0ludGVybmFsRmllbGQodHJ1c3RUeXBlKSwgJ2ludGVybmFsIGZpZWxkcyBjYW4gbmV2ZXIgYmUgdXBkYXRlZCcpCglmcmFtZV9kaWcgMCAvLyB0cnVzdFR5cGU6IGJ5dGVbXQoJY2FsbHN1YiBpc0ludGVybmFsRmllbGQKCSEKCgkvLyBpbnRlcm5hbCBmaWVsZHMgY2FuIG5ldmVyIGJlIHVwZGF0ZWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzNTEKCS8vIGlzVXNlckZpZWxkID0gdGhpcy5pc1VzZXJGaWVsZCh0cnVzdFR5cGUpCglmcmFtZV9kaWcgMCAvLyB0cnVzdFR5cGU6IGJ5dGVbXQoJY2FsbHN1YiBpc1VzZXJGaWVsZAoJZnJhbWVfYnVyeSAxIC8vIGlzVXNlckZpZWxkOiBib29sCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM1MgoJLy8gaXNWZXJpZmllZEZpZWxkID0gdGhpcy5pc1ZlcmlmaWVkRmllbGQodHJ1c3RUeXBlKQoJZnJhbWVfZGlnIDAgLy8gdHJ1c3RUeXBlOiBieXRlW10KCWNhbGxzdWIgaXNWZXJpZmllZEZpZWxkCglmcmFtZV9idXJ5IDIgLy8gaXNWZXJpZmllZEZpZWxkOiBib29sCgoJLy8gKmlmNzZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzU0CgkvLyBhZG1pblJpZ2h0cyAmJiAoaXNWZXJpZmllZEZpZWxkIHx8IChpc1VzZXJGaWVsZCAmJiBsZW4odmFsdWUpID09PSAwKSkKCWZyYW1lX2RpZyAtMyAvLyBhZG1pblJpZ2h0czogYm9vbGVhbgoJZHVwCglieiAqc2tpcF9hbmQxOAoJZnJhbWVfZGlnIDIgLy8gaXNWZXJpZmllZEZpZWxkOiBib29sCglkdXAKCWJueiAqc2tpcF9vcjMKCWZyYW1lX2RpZyAxIC8vIGlzVXNlckZpZWxkOiBib29sCglkdXAKCWJ6ICpza2lwX2FuZDE5CglmcmFtZV9kaWcgLTIgLy8gdmFsdWU6IGJ5dGVzCglsZW4KCWludGMgMCAvLyAwCgk9PQoJJiYKCipza2lwX2FuZDE5OgoJfHwKCipza2lwX29yMzoKCSYmCgoqc2tpcF9hbmQxODoKCWJ6ICppZjc2X2VuZAoKCS8vICppZjc2X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzNTUKCS8vIHJldHVybiB0cnVlCglpbnRjIDEgLy8gMQoJYiAqaXNGaWVsZFVwZGF0ZUFsbG93ZWQqcmV0dXJuCgoqaWY3Nl9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzU4CgkvLyBhc3NlcnQobGVuKHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXQoTkZEX0tFWV9PV05FUikpID09PSAzMiwgJ211c3QgYmUgb3duZWQnKQoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJbGVuCglpbnRjIDMgLy8gMzIKCT09CgoJLy8gbXVzdCBiZSBvd25lZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM1OQoJLy8gYXNzZXJ0KCF0aGlzLmlzRm9yU2FsZSgpLCAiY2FuJ3QgYmUgZm9yIHNhbGUiKQoJY2FsbHN1YiBpc0ZvclNhbGUKCSEKCgkvLyBjYW4ndCBiZSBmb3Igc2FsZQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM2MAoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gQWRkcmVzcy5mcm9tQnl0ZXModGhpcy5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKS52YWx1ZSksICdzZW5kZXIgbXVzdCBiZSBvd25lcicpCgl0eG4gU2VuZGVyCglieXRlYyAxIC8vICJpLm93bmVyLmEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyBzZW5kZXIgbXVzdCBiZSBvd25lcgoJYXNzZXJ0CgoJLy8gKmlmNzdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzYyCgkvLyBpc1VzZXJGaWVsZAoJZnJhbWVfZGlnIDEgLy8gaXNVc2VyRmllbGQ6IGJvb2wKCWJ6ICppZjc3X2VuZAoKCS8vICppZjc3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzNjMKCS8vIHJldHVybiB0cnVlCglpbnRjIDEgLy8gMQoJYiAqaXNGaWVsZFVwZGF0ZUFsbG93ZWQqcmV0dXJuCgoqaWY3N19lbmQ6CgkvLyAqaWY3OF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzNjYKCS8vIGxlbihuYW1lKSA+IDgKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBieXRlcwoJbGVuCglpbnRjIDUgLy8gOAoJPgoJYnogKmlmNzhfZW5kCgoJLy8gKmlmNzhfY29uc2VxdWVudAoJLy8gKmlmNzlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzY3CgkvLyBleHRyYWN0MyhuYW1lLCAwLCA4KSA9PT0gJ3YuY2FBbGdvJwoJZnJhbWVfZGlnIC0xIC8vIG5hbWU6IGJ5dGVzCglleHRyYWN0IDAgOAoJYnl0ZWMgMzMgLy8gICJ2LmNhQWxnbyIKCT09CglieiAqaWY3OV9lbmQKCgkvLyAqaWY3OV9jb25zZXF1ZW50CgkvLyB1cGRhdGluZyB2LmNhQWxnbyBmaWVsZCBpc24ndCBhbGxvd2VkIHZpYSByZWd1bGFyIGZpZWxkIHVwZGF0ZQoJZXJyCgoqaWY3OV9lbmQ6CgoqaWY3OF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzcyCgkvLyByZXR1cm4gaXNWZXJpZmllZEZpZWxkICYmIGxlbih2YWx1ZSkgPT09IDAKCWZyYW1lX2RpZyAyIC8vIGlzVmVyaWZpZWRGaWVsZDogYm9vbAoJZHVwCglieiAqc2tpcF9hbmQyMAoJZnJhbWVfZGlnIC0yIC8vIHZhbHVlOiBieXRlcwoJbGVuCglpbnRjIDAgLy8gMAoJPT0KCSYmCgoqc2tpcF9hbmQyMDoKCippc0ZpZWxkVXBkYXRlQWxsb3dlZCpyZXR1cm46CgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAyCglyZXRzdWIKCi8vIGlzSW50ZXJuYWxGaWVsZCh0cnVzdFR5cGU6IHN0cmluZyk6IGJvb2xlYW4KaXNJbnRlcm5hbEZpZWxkOgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM3NwoJLy8gcmV0dXJuIHRydXN0VHlwZSA9PT0gJ2kuJwoJZnJhbWVfZGlnIC0xIC8vIHRydXN0VHlwZTogc3RyaW5nCglwdXNoYnl0ZXMgMHg2OTJlIC8vICJpLiIKCT09CglyZXRzdWIKCi8vIGlzVXNlckZpZWxkKHRydXN0VHlwZTogc3RyaW5nKTogYm9vbGVhbgppc1VzZXJGaWVsZDoKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzODIKCS8vIHJldHVybiB0cnVzdFR5cGUgPT09ICd1LicKCWZyYW1lX2RpZyAtMSAvLyB0cnVzdFR5cGU6IHN0cmluZwoJcHVzaGJ5dGVzIDB4NzUyZSAvLyAidS4iCgk9PQoJcmV0c3ViCgovLyBpc1ZlcmlmaWVkRmllbGQodHJ1c3RUeXBlOiBzdHJpbmcpOiBib29sZWFuCmlzVmVyaWZpZWRGaWVsZDoKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzODcKCS8vIHJldHVybiB0cnVzdFR5cGUgPT09ICd2LicKCWZyYW1lX2RpZyAtMSAvLyB0cnVzdFR5cGU6IHN0cmluZwoJcHVzaGJ5dGVzIDB4NzYyZSAvLyAidi4iCgk9PQoJcmV0c3ViCgovLyBpc0ZvclNhbGUoKTogYm9vbGVhbgppc0ZvclNhbGU6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzkxCgkvLyByZXR1cm4gdGhpcy5zYWZlR2xvYmFsSW50R2V0KE5GRF9LRVlfU0VMTF9BTU9VTlQpICE9PSAwCglieXRlYyA2IC8vICJpLnNlbGxhbXQiCgljYWxsc3ViIHNhZmVHbG9iYWxJbnRHZXQKCWludGMgMCAvLyAwCgkhPQoJcmV0c3ViCgovLyBpc0V4cGlyZWQoKTogYm9vbGVhbgppc0V4cGlyZWQ6Cglwcm90byAwIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjEzOTYKCS8vIGV4cFRpbWUgPSB0aGlzLnNhZmVHbG9iYWxJbnRHZXQoTkZEX0tFWV9FWFBJUkFUSU9OVElNRSkKCWJ5dGVjIDE3IC8vICJpLmV4cGlyYXRpb25UaW1lIgoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0CglmcmFtZV9idXJ5IDAgLy8gZXhwVGltZTogdWludDY0CgoJLy8gKmlmODBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxMzk3CgkvLyBleHBUaW1lID09PSAwCglmcmFtZV9kaWcgMCAvLyBleHBUaW1lOiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmODBfZW5kCgoJLy8gKmlmODBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTM5OQoJLy8gcmV0dXJuIGZhbHNlCglpbnRjIDAgLy8gMAoJYiAqaXNFeHBpcmVkKnJldHVybgoKKmlmODBfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQwMQoJLy8gcmV0dXJuIGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wID4gZXhwVGltZQoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJZnJhbWVfZGlnIDAgLy8gZXhwVGltZTogdWludDY0Cgk+CgoqaXNFeHBpcmVkKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBpc1ZhdWx0QXV0b09wdEluTG9ja2VkKCk6IGJvb2xlYW4KaXNWYXVsdEF1dG9PcHRJbkxvY2tlZDoKCXByb3RvIDAgMQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0MTAKCS8vIHJldHVybiB0aGlzLnNhZmVHbG9iYWxCeXRlR2V0KE5GRF9LRVlfSVNWQVVMVE9QVElOTE9DS0VEKSA9PT0gJzEnCglieXRlYyAyMCAvLyAiaS52YXVsdE9wdEluTG9ja2VkIgoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldAoJYnl0ZWMgMTUgLy8gICIxIgoJPT0KCXJldHN1YgoKLy8gYXNzZXJ0T3duZXJDYWxsZWROb3RGb3JTYWxlT3JFeHBpcmVkKCk6IHZvaWQKYXNzZXJ0T3duZXJDYWxsZWROb3RGb3JTYWxlT3JFeHBpcmVkOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQxNAoJLy8gdGhpcy5tdXN0QmVDYWxsZWRCeU93bmVyKCkKCWNhbGxzdWIgbXVzdEJlQ2FsbGVkQnlPd25lcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0MTUKCS8vIHRoaXMubm90Rm9yU2FsZU9yRXhwaXJlZCgpCgljYWxsc3ViIG5vdEZvclNhbGVPckV4cGlyZWQKCXJldHN1YgoKLy8gbm90Rm9yU2FsZU9yRXhwaXJlZCgpOiB2b2lkCm5vdEZvclNhbGVPckV4cGlyZWQ6Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDE5CgkvLyBhc3NlcnQoIXRoaXMuaXNGb3JTYWxlKCksICJjYW4ndCBiZSBmb3Igc2FsZSIpCgljYWxsc3ViIGlzRm9yU2FsZQoJIQoKCS8vIGNhbid0IGJlIGZvciBzYWxlCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDIwCgkvLyBhc3NlcnQoIXRoaXMuaXNFeHBpcmVkKCksICJjYW4ndCBiZSBleHBpcmVkIikKCWNhbGxzdWIgaXNFeHBpcmVkCgkhCgoJLy8gY2FuJ3QgYmUgZXhwaXJlZAoJYXNzZXJ0CglyZXRzdWIKCi8vIG5vUGVyaW9kQmVmb3JlSW5kZXgobmFtZTogc3RyaW5nLCBzdG9wSW5kZXg6IHVpbnQ2NCk6IGJvb2xlYW4Kbm9QZXJpb2RCZWZvcmVJbmRleDoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQyNQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9wSW5kZXg7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDAgLy8gaTogdWludDY0CgoqZm9yXzk6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDI1CgkvLyBpIDwgc3RvcEluZGV4CglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBzdG9wSW5kZXg6IHVpbnQ2NAoJPAoJYnogKmZvcl85X2VuZAoKCS8vICppZjgxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQyNgoJLy8gZXh0cmFjdDMobmFtZSwgaSwgMSkgPT09ICcuJwoJZnJhbWVfZGlnIC0xIC8vIG5hbWU6IHN0cmluZwoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJZXh0cmFjdDMKCWJ5dGVjIDI4IC8vICAiLiIKCT09CglieiAqaWY4MV9lbmQKCgkvLyAqaWY4MV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDI3CgkvLyByZXR1cm4gZmFsc2UKCWludGMgMCAvLyAwCgliICpub1BlcmlvZEJlZm9yZUluZGV4KnJldHVybgoKKmlmODFfZW5kOgoKKmZvcl85X2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQyNQoJLy8gaSArPSAxCglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDAgLy8gaTogdWludDY0CgliICpmb3JfOQoKKmZvcl85X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0MzAKCS8vIHJldHVybiB0cnVlCglpbnRjIDEgLy8gMQoKKm5vUGVyaW9kQmVmb3JlSW5kZXgqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCi8vIGNhbGNFeHBpcmF0aW9uKHJlbmV3YWxQcmljZTogdWludDY0LCBhbXRQYWlkOiB1aW50NjQsIGN1clRpbWU6IHVpbnQ2NCwgbWF4WWVhcnNBbGxvd2VkOiB1aW50NjQpOiB1aW50NjQKLy8KLy8gQ2FsY3VsYXRlcyB0aGUgbmV3IGV4cGlyYXRpb24gdGltZSBiYXNlZCBvbiB0aGUgcmVuZXdhbCBwcmljZSwgYW1vdW50IHBhaWQsIGN1cnJlbnQgdGltZSwgYW5kIG1heGltdW0geWVhcnMgYWxsb3dlZC4KLy8KLy8gQHBhcmFtIHJlbmV3YWxQcmljZSAtIFRoZSBwcmljZSBmb3IgcmVuZXdpbmcgdGhlIGV4cGlyYXRpb24uCi8vIEBwYXJhbSBhbXRQYWlkIC0gVGhlIGFtb3VudCBwYWlkIGZvciB0aGUgcmVuZXdhbC4KLy8gQHBhcmFtIGN1clRpbWUgLSBUaGUgY3VycmVudCB0aW1lIGluIHVuaXggdGltZSBzZWNvbmRzLgovLyBAcGFyYW0gbWF4WWVhcnNBbGxvd2VkIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHllYXJzIGFsbG93ZWQgZm9yIHRoZSBleHBpcmF0aW9uLgovLwovLyBAcmV0dXJuIFRoZSBuZXcgZXhwaXJhdGlvbiB0aW1lIGluIHVuaXh0aW1lIHNlY29uZHMKY2FsY0V4cGlyYXRpb246Cglwcm90byA0IDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ0NAoJLy8gZXh0cmFTZWNvbmRzID0gKDM2NSAqIGFtdFBhaWQgKiBTRUNTX0lOX0RBWSkgLyByZW5ld2FsUHJpY2UKCWludGMgOCAvLyAzNjUKCWZyYW1lX2RpZyAtMiAvLyBhbXRQYWlkOiB1aW50NjQKCSoKCWludGMgMTQgLy8gODY0MDAKCSoKCWZyYW1lX2RpZyAtMSAvLyByZW5ld2FsUHJpY2U6IHVpbnQ2NAoJLwoJZnJhbWVfYnVyeSAwIC8vIGV4dHJhU2Vjb25kczogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ0NQoJLy8gbmV3RXhwaXJhdGlvbiA9IGN1clRpbWUgKyBleHRyYVNlY29uZHMKCWZyYW1lX2RpZyAtMyAvLyBjdXJUaW1lOiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIGV4dHJhU2Vjb25kczogdWludDY0CgkrCglmcmFtZV9idXJ5IDEgLy8gbmV3RXhwaXJhdGlvbjogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ0NwoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgbmV3RXhwaXJhdGlvbiA8PSBnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCArIDM2NSAqIG1heFllYXJzQWxsb3dlZCAqIFNFQ1NfSU5fREFZLAoJLy8gICAgICAgICAgICAgJ21heCBleHBpcmF0aW9uIGV4Y2VlZGVkIHBhcmFtZXRlcnMgZGVmaW5lZCBieSByZWdpc3RyeScsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAxIC8vIG5ld0V4cGlyYXRpb246IHVpbnQ2NAoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJaW50YyA4IC8vIDM2NQoJZnJhbWVfZGlnIC00IC8vIG1heFllYXJzQWxsb3dlZDogdWludDY0CgkqCglpbnRjIDE0IC8vIDg2NDAwCgkqCgkrCgk8PQoKCS8vIG1heCBleHBpcmF0aW9uIGV4Y2VlZGVkIHBhcmFtZXRlcnMgZGVmaW5lZCBieSByZWdpc3RyeQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ1MQoJLy8gcmV0dXJuIG5ld0V4cGlyYXRpb24KCWZyYW1lX2RpZyAxIC8vIG5ld0V4cGlyYXRpb246IHVpbnQ2NAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gcG93MTAoZGVjaW1hbHM6IHVpbnQ2NCk6IHVpbnQ2NApwb3cxMDoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDU1CgkvLyBleHBSZXN1bHQgPSBleHB3KDEwLCBkZWNpbWFscykKCWludGMgMTEgLy8gMTAKCWZyYW1lX2RpZyAtMSAvLyBkZWNpbWFsczogdWludDY0CglleHB3CglmcmFtZV9idXJ5IDAgLy8gZXhwUmVzdWx0IGxvdzogdWludDY0CglmcmFtZV9idXJ5IDEgLy8gZXhwUmVzdWx0IGhpZ2g6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0NTYKCS8vIHJldHVybiBleHBSZXN1bHQubG93CglmcmFtZV9kaWcgMCAvLyBleHBSZXN1bHQgbG93OiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxCglyZXRzdWIKCi8vIGNsYXdBc2FGcm9tVG8oZnJvbTogQWRkcmVzcywgdG86IEFkZHJlc3MpOiB2b2lkCmNsYXdBc2FGcm9tVG86Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ2MgoJLy8gZnJvbUJhbGFuY2UgPSBmcm9tLmFzc2V0QmFsYW5jZShBc3NldElELmZyb21VaW50NjQoYnRvaSh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQVNBSUQpLnZhbHVlKSkpCglmcmFtZV9kaWcgLTEgLy8gZnJvbTogQWRkcmVzcwoJYnl0ZWMgMTggLy8gImkuYXNhaWQiCglhcHBfZ2xvYmFsX2dldAoJYnRvaQoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWZyYW1lX2J1cnkgMCAvLyBmcm9tQmFsYW5jZTogdWludDY0CgoJLy8gKmlmODJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDY0CgkvLyBmcm9tQmFsYW5jZSAhPT0gMAoJZnJhbWVfZGlnIDAgLy8gZnJvbUJhbGFuY2U6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCSE9CglieiAqaWY4Ml9lbHNlCgoJLy8gKmlmODJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ2NQoJLy8gc2VuZEZyb20gPSBmcm9tCglmcmFtZV9kaWcgLTEgLy8gZnJvbTogQWRkcmVzcwoJZnJhbWVfYnVyeSAxIC8vIHNlbmRGcm9tOiBBZGRyZXNzCgliICppZjgyX2VuZAoKKmlmODJfZWxzZToKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0NjgKCS8vIHNlbmRGcm9tID0gdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2J1cnkgMSAvLyBzZW5kRnJvbTogQWRkcmVzcwoKKmlmODJfZW5kOgoJLy8gKmlmODNfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDcwCgkvLyBzZW5kRnJvbSA9PT0gdG8KCWZyYW1lX2RpZyAxIC8vIHNlbmRGcm9tOiBBZGRyZXNzCglmcmFtZV9kaWcgLTIgLy8gdG86IEFkZHJlc3MKCT09CglieiAqaWY4M19lbmQKCgkvLyAqaWY4M19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDcxCgkvLyByZXR1cm4KCXJldHN1YgoKKmlmODNfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ3MwoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgICAgICAgeGZlckFzc2V0OiBBc3NldElELmZyb21VaW50NjQoYnRvaSh0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfQVNBSUQpLnZhbHVlKSksCgkvLyAgICAgICAgICAgICBhc3NldEFtb3VudDogMSwKCS8vICAgICAgICAgICAgIHNlbmRlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgICAgIGFzc2V0U2VuZGVyOiBzZW5kRnJvbSwKCS8vICAgICAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRvLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxMCAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDc0CgkvLyB4ZmVyQXNzZXQ6IEFzc2V0SUQuZnJvbVVpbnQ2NChidG9pKHRoaXMuZ2xvYmFsU3RhdGUoTkZEX0tFWV9BU0FJRCkudmFsdWUpKQoJYnl0ZWMgMTggLy8gImkuYXNhaWQiCglhcHBfZ2xvYmFsX2dldAoJYnRvaQoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDc1CgkvLyBhc3NldEFtb3VudDogMQoJaW50YyAxIC8vIDEKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDc2CgkvLyBzZW5kZXI6IHRoaXMuYXBwLmFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIFNlbmRlcgoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0NzcKCS8vIGFzc2V0U2VuZGVyOiBzZW5kRnJvbQoJZnJhbWVfZGlnIDEgLy8gc2VuZEZyb206IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRTZW5kZXIKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDc4CgkvLyBhc3NldFJlY2VpdmVyOiB0bwoJZnJhbWVfZGlnIC0yIC8vIHRvOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIGZpbmRBZGRySW5CeXRlcyhieXRlc09mU2V0OiBieXRlcywgYWRkcmVzczogQWRkcmVzcyk6IGJvb2xlYW4KLy8KLy8gQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBpcyBwcmVzZW50IHdpdGhpbiB0aGUgZ2l2ZW4gc2V0IG9mIGJ5dGVzLgovLwovLyBAcGFyYW0ge2J5dGVzfSBieXRlc09mU2V0IC0gVGhlIHNldCBvZiBieXRlcyB0byBzZWFyY2ggdGhyb3VnaC4KLy8gQHBhcmFtIHtBZGRyZXNzfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gZmluZCB3aXRoaW4gdGhlIHNldCBvZiBieXRlcy4KLy8gQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgZm91bmQgaW4gdGhlIGJ5dGVzLCBvdGhlcndpc2UgZmFsc2UuCmZpbmRBZGRySW5CeXRlczoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXAKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDkwCgkvLyBsaW1pdCA9IGJ5dGVzT2ZTZXQubGVuZ3RoIC8gMzIKCWZyYW1lX2RpZyAtMSAvLyBieXRlc09mU2V0OiBieXRlcwoJbGVuCglpbnRjIDMgLy8gMzIKCS8KCWZyYW1lX2J1cnkgMCAvLyBsaW1pdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTQ5MQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsaW1pdDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCipmb3JfMTA6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDkxCgkvLyBpIDwgbGltaXQKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gbGltaXQ6IHVpbnQ2NAoJPAoJYnogKmZvcl8xMF9lbmQKCgkvLyAqaWY4NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE0OTIKCS8vIGV4dHJhY3QzKGJ5dGVzT2ZTZXQsIGkgKiAzMiwgMzIpID09PSByYXdCeXRlcyhhZGRyZXNzKQoJZnJhbWVfZGlnIC0xIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVzCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgMyAvLyAzMgoJKgoJaW50YyAzIC8vIDMyCglleHRyYWN0MwoJZnJhbWVfZGlnIC0yIC8vIGFkZHJlc3M6IEFkZHJlc3MKCT09CglieiAqaWY4NF9lbmQKCgkvLyAqaWY4NF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDkzCgkvLyByZXR1cm4gdHJ1ZQoJaW50YyAxIC8vIDEKCWIgKmZpbmRBZGRySW5CeXRlcypyZXR1cm4KCippZjg0X2VuZDoKCipmb3JfMTBfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDkxCgkvLyBpICs9IDEKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgKmZvcl8xMAoKKmZvcl8xMF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNDk2CgkvLyByZXR1cm4gZmFsc2UKCWludGMgMCAvLyAwCgoqZmluZEFkZHJJbkJ5dGVzKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gZmluZEFkZHJBbmRTZXRGaXJzdChrZXk6IGJ5dGVzLCBhZGRyZXNzOiBBZGRyZXNzKTogdm9pZApmaW5kQWRkckFuZFNldEZpcnN0OgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gNAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MDEKCS8vIGJ5dGVzT2ZTZXQgPSB0aGlzLmJveGVzKGtleSkudmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGtleSkudmFsdWUKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MDMKCS8vIGFzc2VydChhZGRyZXNzICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MDUKCS8vIGFzc2VydChieXRlc09mU2V0Lmxlbmd0aCA+PSA2NCwgImFkZHJlc3MgJ3NldCcgc2hvdWxkIGFscmVhZHkgaGF2ZSBhdCBsZWFzdCB0d28gdmFsdWVzIikKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJbGVuCglwdXNoaW50IDY0Cgk+PQoKCS8vIGFkZHJlc3MgJ3NldCcgc2hvdWxkIGFscmVhZHkgaGF2ZSBhdCBsZWFzdCB0d28gdmFsdWVzCglhc3NlcnQKCgkvLyAqaWY4NV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MDgKCS8vIGV4dHJhY3QzKGJ5dGVzT2ZTZXQsIDAsIDMyKSA9PT0gcmF3Qnl0ZXMoYWRkcmVzcykKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJZXh0cmFjdCAwIDMyCglmcmFtZV9kaWcgLTIgLy8gYWRkcmVzczogQWRkcmVzcwoJPT0KCWJ6ICppZjg1X2VuZAoKCS8vICppZjg1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MDkKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY4NV9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTEyCgkvLyBsaW1pdCA9IGJ5dGVzT2ZTZXQubGVuZ3RoIC8gMzIKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJbGVuCglpbnRjIDMgLy8gMzIKCS8KCWZyYW1lX2J1cnkgMSAvLyBsaW1pdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTUxMwoJLy8gZm91bmRTbG90ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMiAvLyBmb3VuZFNsb3Q6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MTUKCS8vIGZvciAobGV0IGkgPSAxOyBpIDwgbGltaXQ7IGkgKz0gMSkKCWludGMgMSAvLyAxCglmcmFtZV9idXJ5IDMgLy8gaTogdWludDY0CgoqZm9yXzExOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTUxNQoJLy8gaSA8IGxpbWl0CglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGxpbWl0OiB1aW50NjQKCTwKCWJ6ICpmb3JfMTFfZW5kCgoJLy8gKmlmODZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTE2CgkvLyBleHRyYWN0MyhieXRlc09mU2V0LCBpICogMzIsIDMyKSA9PT0gcmF3Qnl0ZXMoYWRkcmVzcykKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglpbnRjIDMgLy8gMzIKCSoKCWludGMgMyAvLyAzMgoJZXh0cmFjdDMKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCgk9PQoJYnogKmlmODZfZW5kCgoJLy8gKmlmODZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTUxNwoJLy8gZm91bmRTbG90ID0gaQoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglmcmFtZV9idXJ5IDIgLy8gZm91bmRTbG90OiB1aW50NjQKCWIgKmZvcl8xMV9lbmQKCippZjg2X2VuZDoKCipmb3JfMTFfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTE1CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMyAvLyBpOiB1aW50NjQKCWIgKmZvcl8xMQoKKmZvcl8xMV9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTIxCgkvLyBhc3NlcnQoZm91bmRTbG90ICE9PSAwLCAnYWRkcmVzcyBtdXN0IGJlIGZvdW5kIGluIHNldCBpbiBvcmRlciB0byBtb3ZlIGl0JykKCWZyYW1lX2RpZyAyIC8vIGZvdW5kU2xvdDogdWludDY0CglpbnRjIDAgLy8gMAoJIT0KCgkvLyBhZGRyZXNzIG11c3QgYmUgZm91bmQgaW4gc2V0IGluIG9yZGVyIHRvIG1vdmUgaXQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MjMKCS8vIGFkZHJlc3NBdEZyb250ID0gZXh0cmFjdDMoYnl0ZXNPZlNldCwgMCwgMzIpCglmcmFtZV9kaWcgMCAvLyBieXRlc09mU2V0OiBieXRlW10KCWV4dHJhY3QgMCAzMgoJZnJhbWVfYnVyeSA0IC8vIGFkZHJlc3NBdEZyb250OiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTI1CgkvLyBieXRlc09mU2V0ID0gcmVwbGFjZTMoYnl0ZXNPZlNldCwgMCwgYWRkcmVzcykKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCglyZXBsYWNlMwoJZnJhbWVfYnVyeSAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1MjcKCS8vIHRoaXMuYm94ZXMoa2V5KS52YWx1ZSA9IHJlcGxhY2UzKGJ5dGVzT2ZTZXQsIGZvdW5kU2xvdCAqIDMyLCBhZGRyZXNzQXRGcm9udCkKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglmcmFtZV9kaWcgMCAvLyBieXRlc09mU2V0OiBieXRlW10KCWZyYW1lX2RpZyAyIC8vIGZvdW5kU2xvdDogdWludDY0CglpbnRjIDMgLy8gMzIKCSoKCWZyYW1lX2RpZyA0IC8vIGFkZHJlc3NBdEZyb250OiBieXRlW10KCXJlcGxhY2UzCglib3hfcHV0CglyZXRzdWIKCi8vIGFkZEJ5dGVzVG9TZXQoa2V5OiBieXRlcywgYnl0ZXNWYWw6IGJ5dGVzKTogYm9vbGVhbgovLwovLyBBZGRzIGJ5dGVzIHRvIGEgc2V0IGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIGtleS4KLy8KLy8gQHBhcmFtIHtieXRlc30ga2V5IC0gVGhlIGtleSB0byBpZGVudGlmeSB0aGUgc2V0LgovLyBAcGFyYW0ge2J5dGVzfSBieXRlc1ZhbCAtIFRoZSBieXRlcyB0byBiZSBhZGRlZCB0byB0aGUgc2V0LgovLyBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBieXRlcyB3ZXJlIHN1Y2Nlc3NmdWxseSBhZGRlZCB0byB0aGUgc2V0LCBmYWxzZSBvdGhlcndpc2UuCmFkZEJ5dGVzVG9TZXQ6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiA1CgoJLy8gKmlmODdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTM4CgkvLyAhdGhpcy5ib3hlcyhrZXkpLmV4aXN0cwoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYnogKmlmODdfZW5kCgoJLy8gKmlmODdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0MAoJLy8gdGhpcy5ib3hlcyhrZXkpLnZhbHVlID0gYnl0ZXNWYWwKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglmcmFtZV9kaWcgLTIgLy8gYnl0ZXNWYWw6IGJ5dGVzCglib3hfcHV0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0MQoJLy8gcmV0dXJuIHRydWUKCWludGMgMSAvLyAxCgliICphZGRCeXRlc1RvU2V0KnJldHVybgoKKmlmODdfZW5kOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0MwoJLy8gc2l6ZU9mS2V5ID0gbGVuKGJ5dGVzVmFsKQoJZnJhbWVfZGlnIC0yIC8vIGJ5dGVzVmFsOiBieXRlcwoJbGVuCglmcmFtZV9idXJ5IDAgLy8gc2l6ZU9mS2V5OiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTQ0CgkvLyB6ZXJvS2V5ID0gYnplcm8oc2l6ZU9mS2V5KQoJZnJhbWVfZGlnIDAgLy8gc2l6ZU9mS2V5OiB1aW50NjQKCWJ6ZXJvCglmcmFtZV9idXJ5IDEgLy8gemVyb0tleTogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0NQoJLy8gYnl0ZXNPZlNldCA9IHRoaXMuYm94ZXMoa2V5KS52YWx1ZQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoa2V5KS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDIgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0NgoJLy8gbGltaXQgPSBieXRlc09mU2V0Lmxlbmd0aCAvIHNpemVPZktleQoJZnJhbWVfZGlnIDIgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglsZW4KCWZyYW1lX2RpZyAwIC8vIHNpemVPZktleTogdWludDY0CgkvCglmcmFtZV9idXJ5IDMgLy8gbGltaXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1NDgKCS8vIGFzc2VydChsZW4oYnl0ZXNWYWwpICUgc2l6ZU9mS2V5ID09PSAwLCAnZXhpc3Rpbmcgc2V0IG11c3QgYmUgbXVsdGlwbGUgb2Yga2V5IGJlaW5nIGFkZGVkJykKCWZyYW1lX2RpZyAtMiAvLyBieXRlc1ZhbDogYnl0ZXMKCWxlbgoJZnJhbWVfZGlnIDAgLy8gc2l6ZU9mS2V5OiB1aW50NjQKCSUKCWludGMgMCAvLyAwCgk9PQoKCS8vIGV4aXN0aW5nIHNldCBtdXN0IGJlIG11bHRpcGxlIG9mIGtleSBiZWluZyBhZGRlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0OQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsaW1pdDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNCAvLyBpOiB1aW50NjQKCipmb3JfMTI6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTQ5CgkvLyBpIDwgbGltaXQKCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDMgLy8gbGltaXQ6IHVpbnQ2NAoJPAoJYnogKmZvcl8xMl9lbmQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTUwCgkvLyBjdXJyZW50VmFsSW5TbG90ID0gZXh0cmFjdDMoYnl0ZXNPZlNldCwgaSAqIHNpemVPZktleSwgc2l6ZU9mS2V5KQoJZnJhbWVfZGlnIDIgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIHNpemVPZktleTogdWludDY0CgkqCglmcmFtZV9kaWcgMCAvLyBzaXplT2ZLZXk6IHVpbnQ2NAoJZXh0cmFjdDMKCWZyYW1lX2J1cnkgNSAvLyBjdXJyZW50VmFsSW5TbG90OiBieXRlW10KCgkvLyAqaWY4OF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1NTIKCS8vIGN1cnJlbnRWYWxJblNsb3QgPT09IHplcm9LZXkKCWZyYW1lX2RpZyA1IC8vIGN1cnJlbnRWYWxJblNsb3Q6IGJ5dGVbXQoJZnJhbWVfZGlnIDEgLy8gemVyb0tleTogYnl0ZVtdCgk9PQoJYnogKmlmODhfZW5kCgoJLy8gKmlmODhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU1NAoJLy8gdGhpcy5ib3hlcyhrZXkpLnJlcGxhY2UoaSAqIHNpemVPZktleSwgYnl0ZXNWYWwpCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJZnJhbWVfZGlnIDQgLy8gaTogdWludDY0CglmcmFtZV9kaWcgMCAvLyBzaXplT2ZLZXk6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIC0yIC8vIGJ5dGVzVmFsOiBieXRlcwoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTU1CgkvLyByZXR1cm4gdHJ1ZQoJaW50YyAxIC8vIDEKCWIgKmFkZEJ5dGVzVG9TZXQqcmV0dXJuCgoqaWY4OF9lbmQ6CgkvLyAqaWY4OV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1NTcKCS8vIGN1cnJlbnRWYWxJblNsb3QgPT09IGJ5dGVzVmFsCglmcmFtZV9kaWcgNSAvLyBjdXJyZW50VmFsSW5TbG90OiBieXRlW10KCWZyYW1lX2RpZyAtMiAvLyBieXRlc1ZhbDogYnl0ZXMKCT09CglieiAqaWY4OV9lbmQKCgkvLyAqaWY4OV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTU4CgkvLyByZXR1cm4gdHJ1ZQoJaW50YyAxIC8vIDEKCWIgKmFkZEJ5dGVzVG9TZXQqcmV0dXJuCgoqaWY4OV9lbmQ6CgoqZm9yXzEyX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU0OQoJLy8gaSArPSAxCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDQgLy8gaTogdWludDY0CgliICpmb3JfMTIKCipmb3JfMTJfZW5kOgoJLy8gKmlmOTBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTYyCgkvLyBieXRlc09mU2V0Lmxlbmd0aCA8IDEwMTAKCWZyYW1lX2RpZyAyIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJbGVuCglwdXNoaW50IDEwMTAKCTwKCWJ6ICppZjkwX2VuZAoKCS8vICppZjkwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1NjMKCS8vIHRoaXMuYm94ZXMoa2V5KS5kZWxldGUoKQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9kZWwKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTY0CgkvLyB0aGlzLmJveGVzKGtleSkudmFsdWUgPSBjb25jYXQoYnl0ZXNPZlNldCwgYnl0ZXNWYWwpCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJZnJhbWVfZGlnIDIgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglmcmFtZV9kaWcgLTIgLy8gYnl0ZXNWYWw6IGJ5dGVzCgljb25jYXQKCWJveF9wdXQKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTY1CgkvLyByZXR1cm4gdHJ1ZQoJaW50YyAxIC8vIDEKCWIgKmFkZEJ5dGVzVG9TZXQqcmV0dXJuCgoqaWY5MF9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTY4CgkvLyByZXR1cm4gZmFsc2UKCWludGMgMCAvLyAwCgoqYWRkQnl0ZXNUb1NldCpyZXR1cm46CgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiA1CglyZXRzdWIKCi8vIHJlbW92ZUFkZHJGcm9tU2V0KGtleTogYnl0ZXMsIGFkZHJlc3M6IEFkZHJlc3MpOiBib29sZWFuCi8vCi8vIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBhZGRyZXNzIGZyb20gdGhlIHNldCBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBrZXkuCi8vCi8vIEBwYXJhbSB7Ynl0ZXN9IGtleSAtIFRoZSBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBzZXQuCi8vIEBwYXJhbSB7QWRkcmVzc30gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIHJlbW92ZSBmcm9tIHRoZSBzZXQuCi8vIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyB3YXMgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZS4KcmVtb3ZlQWRkckZyb21TZXQ6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiA1CgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU3OQoJLy8gYnl0ZXNPZlNldCA9IHRoaXMuYm94ZXMoa2V5KS52YWx1ZQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoa2V5KS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDAgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU4MAoJLy8gbGltaXQgPSBieXRlc09mU2V0Lmxlbmd0aCAvIDMyCglmcmFtZV9kaWcgMCAvLyBieXRlc09mU2V0OiBieXRlW10KCWxlbgoJaW50YyAzIC8vIDMyCgkvCglmcmFtZV9idXJ5IDEgLy8gbGltaXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1ODIKCS8vIGFzc2VydChhZGRyZXNzICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1ODQKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXQ7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDIgLy8gaTogdWludDY0CgoqZm9yXzEzOgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU4NAoJLy8gaSA8IGxpbWl0CglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGxpbWl0OiB1aW50NjQKCTwKCWJ6ICpmb3JfMTNfZW5kCgoJLy8gKmlmOTFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTg1CgkvLyBleHRyYWN0MyhieXRlc09mU2V0LCBpICogMzIsIDMyKSA9PT0gcmF3Qnl0ZXMoYWRkcmVzcykKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDMgLy8gMzIKCSoKCWludGMgMyAvLyAzMgoJZXh0cmFjdDMKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCgk9PQoJYnogKmlmOTFfZW5kCgoJLy8gKmlmOTFfY29uc2VxdWVudAoJLy8gKmlmOTJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTg2CgkvLyBpID09PSBsaW1pdCAtIDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gbGltaXQ6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCS0KCT09CglieiAqaWY5Ml9lbmQKCgkvLyAqaWY5Ml9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTg3CgkvLyB0aGlzLmJveGVzKGtleSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglib3hfZGVsCgoJLy8gKmlmOTNfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTkwCgkvLyBpID4gMAoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJYnogKmlmOTNfZW5kCgoJLy8gKmlmOTNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU5MQoJLy8gdGhpcy5ib3hlcyhrZXkpLnZhbHVlID0gZXh0cmFjdDMoYnl0ZXNPZlNldCwgMCwgaSAqIDMyKQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDMyCgkqCglleHRyYWN0MwoJYm94X3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1OTMKCS8vIGFsbFplcm8gPSB0cnVlCglpbnRjIDEgLy8gMQoJZnJhbWVfYnVyeSAzIC8vIGFsbFplcm86IGJvb2wKCgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTk0CgkvLyB6ZXJvQWRkciA9IGdsb2JhbHMuemVyb0FkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJZnJhbWVfYnVyeSA0IC8vIHplcm9BZGRyOiBhZGRyZXNzCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU5NQoJLy8gZm9yIChsZXQgaiA9IDA7IGogPCBsaW1pdCAtIDE7IGogKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDUgLy8gajogdWludDY0CgoqZm9yXzE0OgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU5NQoJLy8gaiA8IGxpbWl0IC0gMQoJZnJhbWVfZGlnIDUgLy8gajogdWludDY0CglmcmFtZV9kaWcgMSAvLyBsaW1pdDogdWludDY0CglpbnRjIDEgLy8gMQoJLQoJPAoJYnogKmZvcl8xNF9lbmQKCgkvLyAqaWY5NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE1OTYKCS8vIGV4dHJhY3QzKGJ5dGVzT2ZTZXQsIGogKiAzMiwgMzIpICE9PSByYXdCeXRlcyh6ZXJvQWRkcikKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJZnJhbWVfZGlnIDUgLy8gajogdWludDY0CglpbnRjIDMgLy8gMzIKCSoKCWludGMgMyAvLyAzMgoJZXh0cmFjdDMKCWZyYW1lX2RpZyA0IC8vIHplcm9BZGRyOiBhZGRyZXNzCgkhPQoJYnogKmlmOTRfZW5kCgoJLy8gKmlmOTRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTU5NwoJLy8gYWxsWmVybyA9IGZhbHNlCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAzIC8vIGFsbFplcm86IGJvb2wKCWIgKmZvcl8xNF9lbmQKCippZjk0X2VuZDoKCipmb3JfMTRfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTk1CgkvLyBqICs9IDEKCWZyYW1lX2RpZyA1IC8vIGo6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgNSAvLyBqOiB1aW50NjQKCWIgKmZvcl8xNAoKKmZvcl8xNF9lbmQ6CgkvLyAqaWY5NV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE2MDEKCS8vIGFsbFplcm8KCWZyYW1lX2RpZyAzIC8vIGFsbFplcm86IGJvb2wKCWJ6ICppZjk1X2VuZAoKCS8vICppZjk1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE2MDIKCS8vIHRoaXMuYm94ZXMoa2V5KS5kZWxldGUoKQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9kZWwKCippZjk1X2VuZDoKCippZjkzX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE2MDUKCS8vIHJldHVybiB0cnVlCglpbnRjIDEgLy8gMQoJYiAqcmVtb3ZlQWRkckZyb21TZXQqcmV0dXJuCgoqaWY5Ml9lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNjA4CgkvLyB0aGlzLmJveGVzKGtleSkucmVwbGFjZShpICogMzIsIHJhd0J5dGVzKGdsb2JhbHMuemVyb0FkZHJlc3MpKQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDMyCgkqCglnbG9iYWwgWmVyb0FkZHJlc3MKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL05GREluc3RhbmNlLmFsZ28udHM6MTYwOQoJLy8gcmV0dXJuIHRydWUKCWludGMgMSAvLyAxCgliICpyZW1vdmVBZGRyRnJvbVNldCpyZXR1cm4KCippZjkxX2VuZDoKCipmb3JfMTNfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNTg0CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCWIgKmZvcl8xMwoKKmZvcl8xM19lbmQ6CgkvLyBjb250cmFjdHMvTkZESW5zdGFuY2UuYWxnby50czoxNjEyCgkvLyByZXR1cm4gZmFsc2UKCWludGMgMCAvLyAwCgoqcmVtb3ZlQWRkckZyb21TZXQqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNQoJcmV0c3ViCgovLyBtdXN0QmVDYWxsZWRCeU93bmVyKCk6IHZvaWQKbXVzdEJlQ2FsbGVkQnlPd25lcjoKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0cy9ORkRJbnN0YW5jZS5hbGdvLnRzOjE2MTcKCS8vIGFzc2VydChyYXdCeXRlcyh0aGlzLnR4bi5zZW5kZXIpID09PSB0aGlzLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLnZhbHVlLCAnc2VuZGVyIG11c3QgYmUgb3duZXInKQoJdHhuIFNlbmRlcgoJYnl0ZWMgMSAvLyAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXQKCT09CgoJLy8gc2VuZGVyIG11c3QgYmUgb3duZXIKCWFzc2VydAoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CglwdXNoYnl0ZXMgMHgwZGNhNTJjMSAvLyBtZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKHN0cmluZyxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYWRkcmVzcyl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjcmVhdGUgTm9PcAoJZXJyCgoqY2FsbF9Ob09wOgoJcHVzaGJ5dGVzIDB4MzE3MmNhOWQgLy8gbWV0aG9kICJnYXMoKXZvaWQiCglwdXNoYnl0ZXMgMHgwNmRmMmU1YiAvLyBtZXRob2QgIm1pbnRBc2Eoc3RyaW5nLHN0cmluZyl2b2lkIgoJcHVzaGJ5dGVzIDB4NTEzMmRmNzUgLy8gbWV0aG9kICJkZWxldGVGaWVsZHMoYnl0ZVtdW10pdm9pZCIKCXB1c2hieXRlcyAweDBkMjZjNTkxIC8vIG1ldGhvZCAidXBkYXRlU2VnbWVudENvdW50KHN0cmluZyx1aW50NjQpdm9pZCIKCXB1c2hieXRlcyAweDdjNWFlNDk1IC8vIG1ldGhvZCAiZ2V0RmllbGRVcGRhdGVDb3N0KGJ5dGVbXVtdKXVpbnQ2NCIKCXB1c2hieXRlcyAweDc4ZjQyNzExIC8vIG1ldGhvZCAidXBkYXRlRmllbGRzKGJ5dGVbXVtdKXZvaWQiCglwdXNoYnl0ZXMgMHg2YzEzZWRlNCAvLyBtZXRob2QgInJlYWRGaWVsZChieXRlW10pYnl0ZVtdIgoJcHVzaGJ5dGVzIDB4NTA3NmQ5Y2EgLy8gbWV0aG9kICJvZmZlckZvclNhbGUodWludDY0LGFkZHJlc3Mpdm9pZCIKCXB1c2hieXRlcyAweDk5ZjVkNTBkIC8vIG1ldGhvZCAiY2FuY2VsU2FsZSgpdm9pZCIKCXB1c2hieXRlcyAweDkxMzExMmVmIC8vIG1ldGhvZCAicG9zdE9mZmVyKHVpbnQ2NCxzdHJpbmcpdm9pZCIKCXB1c2hieXRlcyAweGQ4NTMzN2M0IC8vIG1ldGhvZCAibWludFBheW91dCh1aW50NjQsdWludDY0KSh1aW50NjQsYWRkcmVzcyx1aW50NjQsYWRkcmVzcyx1aW50NjQpIgoJcHVzaGJ5dGVzIDB4YTM5MmFlODIgLy8gbWV0aG9kICJwdXJjaGFzZShwYXkpdm9pZCIKCXB1c2hieXRlcyAweGQ0NDM5NTJhIC8vIG1ldGhvZCAiaXNBZGRyZXNzSW5GaWVsZChzdHJpbmcsYWRkcmVzcylib29sIgoJcHVzaGJ5dGVzIDB4NTBmNDkwYzIgLy8gbWV0aG9kICJnZXRSZW5ld1ByaWNlKCl1aW50NjQiCglwdXNoYnl0ZXMgMHg3NjJlODJkYSAvLyBtZXRob2QgInVwZGF0ZUhhc2goYnl0ZVtdKXZvaWQiCglwdXNoYnl0ZXMgMHg4ZWJjMmM4MyAvLyBtZXRob2QgImNvbnRyYWN0TG9jayhib29sKXZvaWQiCglwdXNoYnl0ZXMgMHhjZDUzNThhNiAvLyBtZXRob2QgInNlZ21lbnRMb2NrKGJvb2wsdWludDY0KXZvaWQiCglwdXNoYnl0ZXMgMHgzYTY1N2Q3NyAvLyBtZXRob2QgInZhdWx0T3B0SW5Mb2NrKGJvb2wpdm9pZCIKCXB1c2hieXRlcyAweDQxM2QxNTIzIC8vIG1ldGhvZCAidmF1bHRPcHRJbih1aW50NjRbXSl2b2lkIgoJcHVzaGJ5dGVzIDB4NjY4MjFjMWEgLy8gbWV0aG9kICJ2YXVsdFNlbmQodWludDY0LGFkZHJlc3Msc3RyaW5nLHVpbnQ2NCx1aW50NjRbXSl2b2lkIgoJcHVzaGJ5dGVzIDB4NzdmZDViNzQgLy8gbWV0aG9kICJyZW5ldyhwYXkpdm9pZCIKCXB1c2hieXRlcyAweDk3YjZkODZjIC8vIG1ldGhvZCAic2V0UHJpbWFyeUFkZHJlc3Moc3RyaW5nLGFkZHJlc3Mpdm9pZCIKCXB1c2hieXRlcyAweDg1Y2NlZDU3IC8vIG1ldGhvZCAicmVnaXN0cnlBZGRpbmdWZXJpZmllZEFkZHJlc3Moc3RyaW5nLHN0cmluZylib29sIgoJcHVzaGJ5dGVzIDB4YjE4OTBhNzUgLy8gbWV0aG9kICJyZWdpc3RyeVJlbW92aW5nVmVyaWZpZWRBZGRyZXNzKHN0cmluZyxhZGRyZXNzLGFkZHJlc3MpYm9vbCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfZ2FzICphYmlfcm91dGVfbWludEFzYSAqYWJpX3JvdXRlX2RlbGV0ZUZpZWxkcyAqYWJpX3JvdXRlX3VwZGF0ZVNlZ21lbnRDb3VudCAqYWJpX3JvdXRlX2dldEZpZWxkVXBkYXRlQ29zdCAqYWJpX3JvdXRlX3VwZGF0ZUZpZWxkcyAqYWJpX3JvdXRlX3JlYWRGaWVsZCAqYWJpX3JvdXRlX29mZmVyRm9yU2FsZSAqYWJpX3JvdXRlX2NhbmNlbFNhbGUgKmFiaV9yb3V0ZV9wb3N0T2ZmZXIgKmFiaV9yb3V0ZV9taW50UGF5b3V0ICphYmlfcm91dGVfcHVyY2hhc2UgKmFiaV9yb3V0ZV9pc0FkZHJlc3NJbkZpZWxkICphYmlfcm91dGVfZ2V0UmVuZXdQcmljZSAqYWJpX3JvdXRlX3VwZGF0ZUhhc2ggKmFiaV9yb3V0ZV9jb250cmFjdExvY2sgKmFiaV9yb3V0ZV9zZWdtZW50TG9jayAqYWJpX3JvdXRlX3ZhdWx0T3B0SW5Mb2NrICphYmlfcm91dGVfdmF1bHRPcHRJbiAqYWJpX3JvdXRlX3ZhdWx0U2VuZCAqYWJpX3JvdXRlX3JlbmV3ICphYmlfcm91dGVfc2V0UHJpbWFyeUFkZHJlc3MgKmFiaV9yb3V0ZV9yZWdpc3RyeUFkZGluZ1ZlcmlmaWVkQWRkcmVzcyAqYWJpX3JvdXRlX3JlZ2lzdHJ5UmVtb3ZpbmdWZXJpZmllZEFkZHJlc3MKCgkvLyAhISEhIFdBUk5JTkc6IG5vbi1BQkkgcm91dGluZwoJY2FsbHN1YiBvbkNhbGwKCWludGMgMSAvLyAxCglyZXR1cm4KCipjYWxsX1VwZGF0ZUFwcGxpY2F0aW9uOgoJcHVzaGJ5dGVzIDB4MTc0NzQwNWIgLy8gbWV0aG9kICJ1cGRhdGVBcHBsaWNhdGlvbihzdHJpbmcpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfdXBkYXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBVcGRhdGVBcHBsaWNhdGlvbgoJZXJyCgoqaW50VG9Bc2NpaToKCXByb3RvIDEgMQoJcHVzaGJ5dGVzIDB4MzAzMTMyMzMzNDM1MzYzNzM4MzkgLy8gIjAxMjM0NTY3ODkiCglmcmFtZV9kaWcgLTEgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJZXh0cmFjdDMKCXJldHN1YgoJCgoqaXRvYToKCXByb3RvIDEgMQoJZnJhbWVfZGlnIC0xIC8vIGk6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT09CglieiAqaXRvYV9pZl9lbmQKCWJ5dGVjIDIzIC8vIDB4MzAKCXJldHN1YgoKKml0b2FfaWZfZW5kOgoJZnJhbWVfZGlnIC0xIC8vIGk6IHVpbnQ2NAoJaW50YyAxMSAvLyAxMAoJLwoJaW50YyAwIC8vIDAKCT4KCWJ6ICppdG9hX3Rlcm5hcnlfZmFsc2UKCWZyYW1lX2RpZyAtMSAvLyBpOiB1aW50NjQKCWludGMgMTEgLy8gMTAKCS8KCWNhbGxzdWIgKml0b2EKCWIgKml0b2FfdGVybmFyeV9lbmQKCippdG9hX3Rlcm5hcnlfZmFsc2U6CglieXRlYyAwIC8vICAiIgoKKml0b2FfdGVybmFyeV9lbmQ6CglmcmFtZV9kaWcgLTEgLy8gaTogdWludDY0CglpbnRjIDExIC8vIDEwCgklCgljYWxsc3ViICppbnRUb0FzY2lpCgljb25jYXQKCXJldHN1YgoKKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQ6Cglwcm90byA0IDMKCWZyYW1lX2RpZyAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTEgLy8gZWxlbWVudAoJY29uY2F0CglmcmFtZV9kaWcgLTMgLy8gdHVwbGUgdGFpbAoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0CglyZXRzdWIKCipwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudDoKCXByb3RvIDQgMwoJZnJhbWVfZGlnIC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJY29uY2F0CglmcmFtZV9idXJ5IC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMSAvLyBlbGVtZW50CglkdXAKCWxlbgoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0CglidG9pCgkrCglpdG9iCglleHRyYWN0IDYgMgoJZnJhbWVfYnVyeSAtMiAvLyBoZWFkIG9mZnNldAoJZnJhbWVfZGlnIC0zIC8vIHR1cGxlIHRhaWwKCXN3YXAKCWNvbmNhdAoJZnJhbWVfYnVyeSAtMyAvLyB0dXBsZSB0YWlsCglmcmFtZV9kaWcgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0zIC8vIHR1cGxlIHRhaWwKCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJcmV0c3Vi","clear":"I3ByYWdtYSB2ZXJzaW9uIDEw"},"templateVariables":{"adminAsaId":{"type":"uint64"},"registryAppId":{"type":"uint64"}},"scratchVariables":{"adminAsaId":{"type":"uint64","slot":200},"registryAppId":{"type":"uint64","slot":201}}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


// Type definitions for ARC-56 structs

export type PayoutInfo = {
  amountToSeller: bigint,
  commissionAddress: string,
  amountToCommission: bigint,
  segmentRootOwner: string,
  amountToSegmentRoot: bigint
}


/**
 * Converts the ABI tuple representation of a PayoutInfo to the struct representation
 */
export function PayoutInfoFromTuple(abiTuple: [bigint, string, bigint, string, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.PayoutInfo, APP_SPEC.structs) as PayoutInfo
}

/**
 * Deploy-time template variables
 */
export type TemplateVariables = {
  adminAsaId: bigint,
  registryAppId: bigint,
}

/**
 * The argument types for the NfdInstance contract
 */
export type NfdInstanceArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void': {
      nfdName: string
      seller: string
      buyer: string
      purchaseAmount: bigint | number
      expTime: bigint | number
      commission1Addr: string
      commission1Pct: bigint | number
      commission2Addr: string
      commission2Pct: bigint | number
      segmentRootAppId: bigint | number
      segmentRootCommissionAddr: string
    }
    'updateApplication(string)void': {
      versionNum: string
    }
    'gas()void': Record<string, never>
    'mintAsa(string,string)void': {
      nfdName: string
      url: string
    }
    'deleteFields(byte[][])void': {
      fieldNames: Uint8Array[]
    }
    'updateSegmentCount(string,uint64)void': {
      childNfdName: string
      childNfdAppId: bigint | number
    }
    'getFieldUpdateCost(byte[][])uint64': {
      fieldAndVals: Uint8Array[]
    }
    'updateFields(byte[][])void': {
      fieldAndVals: Uint8Array[]
    }
    'readField(byte[])byte[]': {
      fieldName: Uint8Array
    }
    'offerForSale(uint64,address)void': {
      sellAmount: bigint | number
      reservedFor: string
    }
    'cancelSale()void': Record<string, never>
    'postOffer(uint64,string)void': {
      offer: bigint | number
      note: string
    }
    'mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)': {
      oneYearPrice: bigint | number
      segmentPlatformCostInAlgo: bigint | number
    }
    'purchase(pay)void': {
      payment: AppMethodCallTransactionArgument
    }
    'isAddressInField(string,address)bool': {
      fieldName: string
      address: string
    }
    'getRenewPrice()uint64': Record<string, never>
    'updateHash(byte[])void': {
      hash: Uint8Array
    }
    'contractLock(bool)void': {
      lock: boolean
    }
    'segmentLock(bool,uint64)void': {
      lock: boolean
      usdPrice: bigint | number
    }
    'vaultOptInLock(bool)void': {
      lock: boolean
    }
    'vaultOptIn(uint64[])void': {
      assets: bigint[] | number[]
    }
    'vaultSend(uint64,address,string,uint64,uint64[])void': {
      amount: bigint | number
      receiver: string
      note: string
      asset: bigint | number
      otherAssets: bigint[] | number[]
    }
    'renew(pay)void': {
      /**
       * The payment transaction from which the renewal period is determined..
       */
      payment: AppMethodCallTransactionArgument
    }
    'setPrimaryAddress(string,address)void': {
      fieldName: string
      address: string
    }
    'registryAddingVerifiedAddress(string,string)bool': {
      /**
      * - MUST START with u.cav. (!)
      gets 'added' to 'set' in next arg - must be fixed-sized bytes

       */
      fieldBeingVerified: string
      /**
       * (must BE v.ca[...].as)
       */
      fieldSetName: string
    }
    'registryRemovingVerifiedAddress(string,address,address)bool': {
      /**
       * The field being changed in the address registry.
       */
      fieldBeingChanged: string
      /**
       * The address to be removed from the field.
       */
      address: string
      /**
      * the address to send reclaimed MBR (if any)
      boolean - true if valid removed

       */
      mbrRefundDest: string
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void': [nfdName: string, seller: string, buyer: string, purchaseAmount: bigint | number, expTime: bigint | number, commission1Addr: string, commission1Pct: bigint | number, commission2Addr: string, commission2Pct: bigint | number, segmentRootAppId: bigint | number, segmentRootCommissionAddr: string]
    'updateApplication(string)void': [versionNum: string]
    'gas()void': []
    'mintAsa(string,string)void': [nfdName: string, url: string]
    'deleteFields(byte[][])void': [fieldNames: Uint8Array[]]
    'updateSegmentCount(string,uint64)void': [childNfdName: string, childNfdAppId: bigint | number]
    'getFieldUpdateCost(byte[][])uint64': [fieldAndVals: Uint8Array[]]
    'updateFields(byte[][])void': [fieldAndVals: Uint8Array[]]
    'readField(byte[])byte[]': [fieldName: Uint8Array]
    'offerForSale(uint64,address)void': [sellAmount: bigint | number, reservedFor: string]
    'cancelSale()void': []
    'postOffer(uint64,string)void': [offer: bigint | number, note: string]
    'mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)': [oneYearPrice: bigint | number, segmentPlatformCostInAlgo: bigint | number]
    'purchase(pay)void': [payment: AppMethodCallTransactionArgument]
    'isAddressInField(string,address)bool': [fieldName: string, address: string]
    'getRenewPrice()uint64': []
    'updateHash(byte[])void': [hash: Uint8Array]
    'contractLock(bool)void': [lock: boolean]
    'segmentLock(bool,uint64)void': [lock: boolean, usdPrice: bigint | number]
    'vaultOptInLock(bool)void': [lock: boolean]
    'vaultOptIn(uint64[])void': [assets: bigint[] | number[]]
    'vaultSend(uint64,address,string,uint64,uint64[])void': [amount: bigint | number, receiver: string, note: string, asset: bigint | number, otherAssets: bigint[] | number[]]
    'renew(pay)void': [payment: AppMethodCallTransactionArgument]
    'setPrimaryAddress(string,address)void': [fieldName: string, address: string]
    'registryAddingVerifiedAddress(string,string)bool': [fieldBeingVerified: string, fieldSetName: string]
    'registryRemovingVerifiedAddress(string,address,address)bool': [fieldBeingChanged: string, address: string, mbrRefundDest: string]
  }
}

/**
 * The return type for each method
 */
export type NfdInstanceReturns = {
  'createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void': void
  'updateApplication(string)void': void
  'gas()void': void
  'mintAsa(string,string)void': void
  'deleteFields(byte[][])void': void
  'updateSegmentCount(string,uint64)void': void
  'getFieldUpdateCost(byte[][])uint64': bigint
  'updateFields(byte[][])void': void
  'readField(byte[])byte[]': Uint8Array
  'offerForSale(uint64,address)void': void
  'cancelSale()void': void
  'postOffer(uint64,string)void': void
  'mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)': PayoutInfo
  'purchase(pay)void': void
  'isAddressInField(string,address)bool': boolean
  'getRenewPrice()uint64': bigint
  'updateHash(byte[])void': void
  'contractLock(bool)void': void
  'segmentLock(bool,uint64)void': void
  'vaultOptInLock(bool)void': void
  'vaultOptIn(uint64[])void': void
  'vaultSend(uint64,address,string,uint64,uint64[])void': void
  'renew(pay)void': void
  'setPrimaryAddress(string,address)void': void
  'registryAddingVerifiedAddress(string,string)bool': boolean
  'registryRemovingVerifiedAddress(string,address,address)bool': boolean
}

/**
 * Defines the types of available calls and state of the NfdInstance smart contract.
 */
export type NfdInstanceTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void' | 'createApplication', {
      argsObj: NfdInstanceArgs['obj']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void']
      argsTuple: NfdInstanceArgs['tuple']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void']
      returns: NfdInstanceReturns['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void']
    }>
    & Record<'updateApplication(string)void' | 'updateApplication', {
      argsObj: NfdInstanceArgs['obj']['updateApplication(string)void']
      argsTuple: NfdInstanceArgs['tuple']['updateApplication(string)void']
      returns: NfdInstanceReturns['updateApplication(string)void']
    }>
    & Record<'gas()void' | 'gas', {
      argsObj: NfdInstanceArgs['obj']['gas()void']
      argsTuple: NfdInstanceArgs['tuple']['gas()void']
      returns: NfdInstanceReturns['gas()void']
    }>
    & Record<'mintAsa(string,string)void' | 'mintAsa', {
      argsObj: NfdInstanceArgs['obj']['mintAsa(string,string)void']
      argsTuple: NfdInstanceArgs['tuple']['mintAsa(string,string)void']
      returns: NfdInstanceReturns['mintAsa(string,string)void']
    }>
    & Record<'deleteFields(byte[][])void' | 'deleteFields', {
      argsObj: NfdInstanceArgs['obj']['deleteFields(byte[][])void']
      argsTuple: NfdInstanceArgs['tuple']['deleteFields(byte[][])void']
      returns: NfdInstanceReturns['deleteFields(byte[][])void']
    }>
    & Record<'updateSegmentCount(string,uint64)void' | 'updateSegmentCount', {
      argsObj: NfdInstanceArgs['obj']['updateSegmentCount(string,uint64)void']
      argsTuple: NfdInstanceArgs['tuple']['updateSegmentCount(string,uint64)void']
      returns: NfdInstanceReturns['updateSegmentCount(string,uint64)void']
    }>
    & Record<'getFieldUpdateCost(byte[][])uint64' | 'getFieldUpdateCost', {
      argsObj: NfdInstanceArgs['obj']['getFieldUpdateCost(byte[][])uint64']
      argsTuple: NfdInstanceArgs['tuple']['getFieldUpdateCost(byte[][])uint64']
      returns: NfdInstanceReturns['getFieldUpdateCost(byte[][])uint64']
    }>
    & Record<'updateFields(byte[][])void' | 'updateFields', {
      argsObj: NfdInstanceArgs['obj']['updateFields(byte[][])void']
      argsTuple: NfdInstanceArgs['tuple']['updateFields(byte[][])void']
      returns: NfdInstanceReturns['updateFields(byte[][])void']
    }>
    & Record<'readField(byte[])byte[]' | 'readField', {
      argsObj: NfdInstanceArgs['obj']['readField(byte[])byte[]']
      argsTuple: NfdInstanceArgs['tuple']['readField(byte[])byte[]']
      returns: NfdInstanceReturns['readField(byte[])byte[]']
    }>
    & Record<'offerForSale(uint64,address)void' | 'offerForSale', {
      argsObj: NfdInstanceArgs['obj']['offerForSale(uint64,address)void']
      argsTuple: NfdInstanceArgs['tuple']['offerForSale(uint64,address)void']
      returns: NfdInstanceReturns['offerForSale(uint64,address)void']
    }>
    & Record<'cancelSale()void' | 'cancelSale', {
      argsObj: NfdInstanceArgs['obj']['cancelSale()void']
      argsTuple: NfdInstanceArgs['tuple']['cancelSale()void']
      returns: NfdInstanceReturns['cancelSale()void']
    }>
    & Record<'postOffer(uint64,string)void' | 'postOffer', {
      argsObj: NfdInstanceArgs['obj']['postOffer(uint64,string)void']
      argsTuple: NfdInstanceArgs['tuple']['postOffer(uint64,string)void']
      returns: NfdInstanceReturns['postOffer(uint64,string)void']
    }>
    & Record<'mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)' | 'mintPayout', {
      argsObj: NfdInstanceArgs['obj']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)']
      argsTuple: NfdInstanceArgs['tuple']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)']
      returns: NfdInstanceReturns['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)']
    }>
    & Record<'purchase(pay)void' | 'purchase', {
      argsObj: NfdInstanceArgs['obj']['purchase(pay)void']
      argsTuple: NfdInstanceArgs['tuple']['purchase(pay)void']
      returns: NfdInstanceReturns['purchase(pay)void']
    }>
    & Record<'isAddressInField(string,address)bool' | 'isAddressInField', {
      argsObj: NfdInstanceArgs['obj']['isAddressInField(string,address)bool']
      argsTuple: NfdInstanceArgs['tuple']['isAddressInField(string,address)bool']
      returns: NfdInstanceReturns['isAddressInField(string,address)bool']
    }>
    & Record<'getRenewPrice()uint64' | 'getRenewPrice', {
      argsObj: NfdInstanceArgs['obj']['getRenewPrice()uint64']
      argsTuple: NfdInstanceArgs['tuple']['getRenewPrice()uint64']
      returns: NfdInstanceReturns['getRenewPrice()uint64']
    }>
    & Record<'updateHash(byte[])void' | 'updateHash', {
      argsObj: NfdInstanceArgs['obj']['updateHash(byte[])void']
      argsTuple: NfdInstanceArgs['tuple']['updateHash(byte[])void']
      returns: NfdInstanceReturns['updateHash(byte[])void']
    }>
    & Record<'contractLock(bool)void' | 'contractLock', {
      argsObj: NfdInstanceArgs['obj']['contractLock(bool)void']
      argsTuple: NfdInstanceArgs['tuple']['contractLock(bool)void']
      returns: NfdInstanceReturns['contractLock(bool)void']
    }>
    & Record<'segmentLock(bool,uint64)void' | 'segmentLock', {
      argsObj: NfdInstanceArgs['obj']['segmentLock(bool,uint64)void']
      argsTuple: NfdInstanceArgs['tuple']['segmentLock(bool,uint64)void']
      returns: NfdInstanceReturns['segmentLock(bool,uint64)void']
    }>
    & Record<'vaultOptInLock(bool)void' | 'vaultOptInLock', {
      argsObj: NfdInstanceArgs['obj']['vaultOptInLock(bool)void']
      argsTuple: NfdInstanceArgs['tuple']['vaultOptInLock(bool)void']
      returns: NfdInstanceReturns['vaultOptInLock(bool)void']
    }>
    & Record<'vaultOptIn(uint64[])void' | 'vaultOptIn', {
      argsObj: NfdInstanceArgs['obj']['vaultOptIn(uint64[])void']
      argsTuple: NfdInstanceArgs['tuple']['vaultOptIn(uint64[])void']
      returns: NfdInstanceReturns['vaultOptIn(uint64[])void']
    }>
    & Record<'vaultSend(uint64,address,string,uint64,uint64[])void' | 'vaultSend', {
      argsObj: NfdInstanceArgs['obj']['vaultSend(uint64,address,string,uint64,uint64[])void']
      argsTuple: NfdInstanceArgs['tuple']['vaultSend(uint64,address,string,uint64,uint64[])void']
      returns: NfdInstanceReturns['vaultSend(uint64,address,string,uint64,uint64[])void']
    }>
    & Record<'renew(pay)void' | 'renew', {
      argsObj: NfdInstanceArgs['obj']['renew(pay)void']
      argsTuple: NfdInstanceArgs['tuple']['renew(pay)void']
      returns: NfdInstanceReturns['renew(pay)void']
    }>
    & Record<'setPrimaryAddress(string,address)void' | 'setPrimaryAddress', {
      argsObj: NfdInstanceArgs['obj']['setPrimaryAddress(string,address)void']
      argsTuple: NfdInstanceArgs['tuple']['setPrimaryAddress(string,address)void']
      returns: NfdInstanceReturns['setPrimaryAddress(string,address)void']
    }>
    & Record<'registryAddingVerifiedAddress(string,string)bool' | 'registryAddingVerifiedAddress', {
      argsObj: NfdInstanceArgs['obj']['registryAddingVerifiedAddress(string,string)bool']
      argsTuple: NfdInstanceArgs['tuple']['registryAddingVerifiedAddress(string,string)bool']
      /**
       * true if added or already present, false otherwise
       */
      returns: NfdInstanceReturns['registryAddingVerifiedAddress(string,string)bool']
    }>
    & Record<'registryRemovingVerifiedAddress(string,address,address)bool' | 'registryRemovingVerifiedAddress', {
      argsObj: NfdInstanceArgs['obj']['registryRemovingVerifiedAddress(string,address,address)bool']
      argsTuple: NfdInstanceArgs['tuple']['registryRemovingVerifiedAddress(string,address,address)bool']
      returns: NfdInstanceReturns['registryRemovingVerifiedAddress(string,address,address)bool']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {}
      maps: {
        globalState: Map<Uint8Array | string, Uint8Array>
      }
    }
    box: {
      keys: {}
      maps: {
        boxes: Map<Uint8Array | string, Uint8Array>
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type NfdInstanceSignatures = keyof NfdInstanceTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type NfdInstanceNonVoidMethodSignatures = keyof NfdInstanceTypes['methods'] extends infer T ? T extends keyof NfdInstanceTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the NfdInstance smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends NfdInstanceSignatures> = NfdInstanceTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the NfdInstance smart contract to the method's return type
 */
export type MethodReturn<TSignature extends NfdInstanceSignatures> = NfdInstanceTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = NfdInstanceTypes['state']['global']['keys']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = NfdInstanceTypes['state']['box']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type NfdInstanceCreateCallParams =
  | Expand<CallParams<NfdInstanceArgs['obj']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void'] | NfdInstanceArgs['tuple']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void']> & {method: 'createApplication'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
  | Expand<CallParams<NfdInstanceArgs['obj']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void'] | NfdInstanceArgs['tuple']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void']> & {method: 'createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines supported update method params for this smart contract
 */
export type NfdInstanceUpdateCallParams =
  | Expand<CallParams<NfdInstanceArgs['obj']['updateApplication(string)void'] | NfdInstanceArgs['tuple']['updateApplication(string)void']> & {method: 'updateApplication'}>
  | Expand<CallParams<NfdInstanceArgs['obj']['updateApplication(string)void'] | NfdInstanceArgs['tuple']['updateApplication(string)void']> & {method: 'updateApplication(string)void'}>
/**
 * Defines arguments required for the deploy method.
 */
export type NfdInstanceDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: NfdInstanceCreateCallParams
  /**
   * Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  updateParams?: NfdInstanceUpdateCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the NfdInstance smart contract
 */
export abstract class NfdInstanceParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod<TParams extends NfdInstanceCreateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'createApplication':
          case 'createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void':
            return NfdInstanceParamsFactory.create.createApplication(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs create ABI call params for the NFDInstance smart contract using the createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      createApplication(params: CallParams<NfdInstanceArgs['obj']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void'] | NfdInstanceArgs['tuple']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void']> & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC}): AppClientMethodCallParams & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC} {
        return {
          ...params,
          method: 'createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.nfdName, params.args.seller, params.args.buyer, params.args.purchaseAmount, params.args.expTime, params.args.commission1Addr, params.args.commission1Pct, params.args.commission2Addr, params.args.commission2Pct, params.args.segmentRootAppId, params.args.segmentRootCommissionAddr],
        }
      },
    }
  }

  /**
   * Gets available update ABI call param factories
   */
  static get update() {
    return {
      _resolveByMethod<TParams extends NfdInstanceUpdateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'updateApplication':
          case 'updateApplication(string)void':
            return NfdInstanceParamsFactory.update.updateApplication(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs update ABI call params for the NFDInstance smart contract using the updateApplication(string)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      updateApplication(params: CallParams<NfdInstanceArgs['obj']['updateApplication(string)void'] | NfdInstanceArgs['tuple']['updateApplication(string)void']> & AppClientCompilationParams): AppClientMethodCallParams & AppClientCompilationParams {
        return {
          ...params,
          method: 'updateApplication(string)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.versionNum],
        }
      },
    }
  }

  /**
   * Constructs a no op call for the gas()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static gas(params: CallParams<NfdInstanceArgs['obj']['gas()void'] | NfdInstanceArgs['tuple']['gas()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'gas()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the mintAsa(string,string)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mintAsa(params: CallParams<NfdInstanceArgs['obj']['mintAsa(string,string)void'] | NfdInstanceArgs['tuple']['mintAsa(string,string)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'mintAsa(string,string)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.nfdName, params.args.url],
    }
  }
  /**
   * Constructs a no op call for the deleteFields(byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deleteFields(params: CallParams<NfdInstanceArgs['obj']['deleteFields(byte[][])void'] | NfdInstanceArgs['tuple']['deleteFields(byte[][])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'deleteFields(byte[][])void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.fieldNames],
    }
  }
  /**
   * Constructs a no op call for the updateSegmentCount(string,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateSegmentCount(params: CallParams<NfdInstanceArgs['obj']['updateSegmentCount(string,uint64)void'] | NfdInstanceArgs['tuple']['updateSegmentCount(string,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateSegmentCount(string,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.childNfdName, params.args.childNfdAppId],
    }
  }
  /**
   * Constructs a no op call for the getFieldUpdateCost(byte[][])uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getFieldUpdateCost(params: CallParams<NfdInstanceArgs['obj']['getFieldUpdateCost(byte[][])uint64'] | NfdInstanceArgs['tuple']['getFieldUpdateCost(byte[][])uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getFieldUpdateCost(byte[][])uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.fieldAndVals],
    }
  }
  /**
   * Constructs a no op call for the updateFields(byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateFields(params: CallParams<NfdInstanceArgs['obj']['updateFields(byte[][])void'] | NfdInstanceArgs['tuple']['updateFields(byte[][])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateFields(byte[][])void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.fieldAndVals],
    }
  }
  /**
   * Constructs a no op call for the readField(byte[])byte[] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static readField(params: CallParams<NfdInstanceArgs['obj']['readField(byte[])byte[]'] | NfdInstanceArgs['tuple']['readField(byte[])byte[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'readField(byte[])byte[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.fieldName],
    }
  }
  /**
   * Constructs a no op call for the offerForSale(uint64,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static offerForSale(params: CallParams<NfdInstanceArgs['obj']['offerForSale(uint64,address)void'] | NfdInstanceArgs['tuple']['offerForSale(uint64,address)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'offerForSale(uint64,address)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.sellAmount, params.args.reservedFor],
    }
  }
  /**
   * Constructs a no op call for the cancelSale()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static cancelSale(params: CallParams<NfdInstanceArgs['obj']['cancelSale()void'] | NfdInstanceArgs['tuple']['cancelSale()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'cancelSale()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the postOffer(uint64,string)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static postOffer(params: CallParams<NfdInstanceArgs['obj']['postOffer(uint64,string)void'] | NfdInstanceArgs['tuple']['postOffer(uint64,string)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'postOffer(uint64,string)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.offer, params.args.note],
    }
  }
  /**
   * Constructs a no op call for the mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mintPayout(params: CallParams<NfdInstanceArgs['obj']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)'] | NfdInstanceArgs['tuple']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.oneYearPrice, params.args.segmentPlatformCostInAlgo],
    }
  }
  /**
   * Constructs a no op call for the purchase(pay)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static purchase(params: CallParams<NfdInstanceArgs['obj']['purchase(pay)void'] | NfdInstanceArgs['tuple']['purchase(pay)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'purchase(pay)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment],
    }
  }
  /**
   * Constructs a no op call for the isAddressInField(string,address)bool ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static isAddressInField(params: CallParams<NfdInstanceArgs['obj']['isAddressInField(string,address)bool'] | NfdInstanceArgs['tuple']['isAddressInField(string,address)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'isAddressInField(string,address)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.fieldName, params.args.address],
    }
  }
  /**
   * Constructs a no op call for the getRenewPrice()uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getRenewPrice(params: CallParams<NfdInstanceArgs['obj']['getRenewPrice()uint64'] | NfdInstanceArgs['tuple']['getRenewPrice()uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getRenewPrice()uint64' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the updateHash(byte[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateHash(params: CallParams<NfdInstanceArgs['obj']['updateHash(byte[])void'] | NfdInstanceArgs['tuple']['updateHash(byte[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateHash(byte[])void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.hash],
    }
  }
  /**
   * Constructs a no op call for the contractLock(bool)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static contractLock(params: CallParams<NfdInstanceArgs['obj']['contractLock(bool)void'] | NfdInstanceArgs['tuple']['contractLock(bool)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'contractLock(bool)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.lock],
    }
  }
  /**
   * Constructs a no op call for the segmentLock(bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static segmentLock(params: CallParams<NfdInstanceArgs['obj']['segmentLock(bool,uint64)void'] | NfdInstanceArgs['tuple']['segmentLock(bool,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'segmentLock(bool,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.lock, params.args.usdPrice],
    }
  }
  /**
   * Constructs a no op call for the vaultOptInLock(bool)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static vaultOptInLock(params: CallParams<NfdInstanceArgs['obj']['vaultOptInLock(bool)void'] | NfdInstanceArgs['tuple']['vaultOptInLock(bool)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'vaultOptInLock(bool)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.lock],
    }
  }
  /**
   * Constructs a no op call for the vaultOptIn(uint64[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static vaultOptIn(params: CallParams<NfdInstanceArgs['obj']['vaultOptIn(uint64[])void'] | NfdInstanceArgs['tuple']['vaultOptIn(uint64[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'vaultOptIn(uint64[])void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.assets],
    }
  }
  /**
   * Constructs a no op call for the vaultSend(uint64,address,string,uint64,uint64[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static vaultSend(params: CallParams<NfdInstanceArgs['obj']['vaultSend(uint64,address,string,uint64,uint64[])void'] | NfdInstanceArgs['tuple']['vaultSend(uint64,address,string,uint64,uint64[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'vaultSend(uint64,address,string,uint64,uint64[])void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.amount, params.args.receiver, params.args.note, params.args.asset, params.args.otherAssets],
    }
  }
  /**
   * Constructs a no op call for the renew(pay)void ABI method
   *
  * Renew adds more time to an existing NFDs expiration, or renews it if expired.
  
  
  As part of v2-v3 upgrade, the NFDs are converted from lifetime NFDs to renewal NFDs. The v2 contract is upgraded
  to v3, then renew is called on the (now v3) nfd to turn it into a renewal (note the if curExpiration === 0 check)
  
  
  If already renewal, then it extends the current expiration time by the time specified (minimum 1 yr) (365 / price paid * mint price)
  Expirations can never be more than NFD_MAX_EXPIRATION_DAYS days in the future.
  
  
  IF the NFD is expired:
     x The current owner can take it back over at base price - and NFD metadata doesn't have to be cleared - they
     get it back as-is.
     x If not current owner, then the price goes from high of base price * 10,000 down to base price over 24 hrs where
     'buyer' has to pay at least that price.  The NFD MUST ALREADY HAVE ITS METADATA CLEARED!

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static renew(params: CallParams<NfdInstanceArgs['obj']['renew(pay)void'] | NfdInstanceArgs['tuple']['renew(pay)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'renew(pay)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment],
    }
  }
  /**
   * Constructs a no op call for the setPrimaryAddress(string,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setPrimaryAddress(params: CallParams<NfdInstanceArgs['obj']['setPrimaryAddress(string,address)void'] | NfdInstanceArgs['tuple']['setPrimaryAddress(string,address)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'setPrimaryAddress(string,address)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.fieldName, params.args.address],
    }
  }
  /**
   * Constructs a no op call for the registryAddingVerifiedAddress(string,string)bool ABI method
   *
  * Approved call from registry instructing us to move the specified u.cav.xx field and add to the specified
  verified field.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static registryAddingVerifiedAddress(params: CallParams<NfdInstanceArgs['obj']['registryAddingVerifiedAddress(string,string)bool'] | NfdInstanceArgs['tuple']['registryAddingVerifiedAddress(string,string)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'registryAddingVerifiedAddress(string,string)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.fieldBeingVerified, params.args.fieldSetName],
    }
  }
  /**
   * Constructs a no op call for the registryRemovingVerifiedAddress(string,address,address)bool ABI method
   *
   * Approved call from registry instructing us to REMOVE an address from the specified verified address set
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static registryRemovingVerifiedAddress(params: CallParams<NfdInstanceArgs['obj']['registryRemovingVerifiedAddress(string,address,address)bool'] | NfdInstanceArgs['tuple']['registryRemovingVerifiedAddress(string,address,address)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'registryRemovingVerifiedAddress(string,address,address)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.fieldBeingChanged, params.args.address, params.args.mbrRefundDest],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the NFDInstance smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class NfdInstanceFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `NfdInstanceFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new NfdInstanceClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new NfdInstanceClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the NFDInstance smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: NfdInstanceDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
      createParams: params.createParams?.method ? NfdInstanceParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams as (NfdInstanceCreateCallParams & { args: Uint8Array[] }) : undefined,
      updateParams: params.updateParams?.method ? NfdInstanceParamsFactory.update._resolveByMethod(params.updateParams) : params.updateParams ? params.updateParams as (NfdInstanceUpdateCallParams & { args: Uint8Array[] }) : undefined,
    })
    return { result: result.result, appClient: new NfdInstanceClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NFDInstance smart contract using the createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      createApplication: (params: CallParams<NfdInstanceArgs['obj']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void'] | NfdInstanceArgs['tuple']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.params.create(NfdInstanceParamsFactory.create.createApplication(params))
      },
    },

    /**
     * Gets available deployUpdate methods
     */
    deployUpdate: {
      /**
       * Updates an existing instance of the NFDInstance smart contract using the updateApplication(string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployUpdate params
       */
      updateApplication: (params: CallParams<NfdInstanceArgs['obj']['updateApplication(string)void'] | NfdInstanceArgs['tuple']['updateApplication(string)void']> & AppClientCompilationParams) => {
        return this.appFactory.params.deployUpdate(NfdInstanceParamsFactory.update.updateApplication(params))
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NFDInstance smart contract using the createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      createApplication: (params: CallParams<NfdInstanceArgs['obj']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void'] | NfdInstanceArgs['tuple']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.createTransaction.create(NfdInstanceParamsFactory.create.createApplication(params))
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NFDInstance smart contract using an ABI method call using the createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      createApplication: async (params: CallParams<NfdInstanceArgs['obj']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void'] | NfdInstanceArgs['tuple']['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void']> & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        const result = await this.appFactory.send.create(NfdInstanceParamsFactory.create.createApplication(params))
        return { result: { ...result.result, return: result.result.return as unknown as (undefined | NfdInstanceReturns['createApplication(string,address,address,uint64,uint64,address,uint64,address,uint64,uint64,address)void']) }, appClient: new NfdInstanceClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the NFDInstance smart contract
 */
export class NfdInstanceClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `NfdInstanceClient`
   *
   * @param appClient An `AppClient` instance which has been created with the NfdInstance app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `NfdInstanceClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }

  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends NfdInstanceNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }

  /**
   * Returns a new `NfdInstanceClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<NfdInstanceClient> {
    return new NfdInstanceClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `NfdInstanceClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<NfdInstanceClient> {
    return new NfdInstanceClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the NFDInstance smart contract using the `updateApplication(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update params
       */
      updateApplication: (params: CallParams<NfdInstanceArgs['obj']['updateApplication(string)void'] | NfdInstanceArgs['tuple']['updateApplication(string)void']> & AppClientCompilationParams) => {
        return this.appClient.params.update(NfdInstanceParamsFactory.update.updateApplication(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the NFDInstance smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `gas()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    gas: (params: CallParams<NfdInstanceArgs['obj']['gas()void'] | NfdInstanceArgs['tuple']['gas()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.gas(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `mintAsa(string,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mintAsa: (params: CallParams<NfdInstanceArgs['obj']['mintAsa(string,string)void'] | NfdInstanceArgs['tuple']['mintAsa(string,string)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.mintAsa(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `deleteFields(byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    deleteFields: (params: CallParams<NfdInstanceArgs['obj']['deleteFields(byte[][])void'] | NfdInstanceArgs['tuple']['deleteFields(byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.deleteFields(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `updateSegmentCount(string,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateSegmentCount: (params: CallParams<NfdInstanceArgs['obj']['updateSegmentCount(string,uint64)void'] | NfdInstanceArgs['tuple']['updateSegmentCount(string,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.updateSegmentCount(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `getFieldUpdateCost(byte[][])uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getFieldUpdateCost: (params: CallParams<NfdInstanceArgs['obj']['getFieldUpdateCost(byte[][])uint64'] | NfdInstanceArgs['tuple']['getFieldUpdateCost(byte[][])uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.getFieldUpdateCost(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `updateFields(byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateFields: (params: CallParams<NfdInstanceArgs['obj']['updateFields(byte[][])void'] | NfdInstanceArgs['tuple']['updateFields(byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.updateFields(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `readField(byte[])byte[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    readField: (params: CallParams<NfdInstanceArgs['obj']['readField(byte[])byte[]'] | NfdInstanceArgs['tuple']['readField(byte[])byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.readField(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `offerForSale(uint64,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    offerForSale: (params: CallParams<NfdInstanceArgs['obj']['offerForSale(uint64,address)void'] | NfdInstanceArgs['tuple']['offerForSale(uint64,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.offerForSale(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `cancelSale()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    cancelSale: (params: CallParams<NfdInstanceArgs['obj']['cancelSale()void'] | NfdInstanceArgs['tuple']['cancelSale()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.cancelSale(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `postOffer(uint64,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    postOffer: (params: CallParams<NfdInstanceArgs['obj']['postOffer(uint64,string)void'] | NfdInstanceArgs['tuple']['postOffer(uint64,string)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.postOffer(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mintPayout: (params: CallParams<NfdInstanceArgs['obj']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)'] | NfdInstanceArgs['tuple']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.mintPayout(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `purchase(pay)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    purchase: (params: CallParams<NfdInstanceArgs['obj']['purchase(pay)void'] | NfdInstanceArgs['tuple']['purchase(pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.purchase(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `isAddressInField(string,address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    isAddressInField: (params: CallParams<NfdInstanceArgs['obj']['isAddressInField(string,address)bool'] | NfdInstanceArgs['tuple']['isAddressInField(string,address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.isAddressInField(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `getRenewPrice()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getRenewPrice: (params: CallParams<NfdInstanceArgs['obj']['getRenewPrice()uint64'] | NfdInstanceArgs['tuple']['getRenewPrice()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.getRenewPrice(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `updateHash(byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateHash: (params: CallParams<NfdInstanceArgs['obj']['updateHash(byte[])void'] | NfdInstanceArgs['tuple']['updateHash(byte[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.updateHash(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `contractLock(bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    contractLock: (params: CallParams<NfdInstanceArgs['obj']['contractLock(bool)void'] | NfdInstanceArgs['tuple']['contractLock(bool)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.contractLock(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `segmentLock(bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    segmentLock: (params: CallParams<NfdInstanceArgs['obj']['segmentLock(bool,uint64)void'] | NfdInstanceArgs['tuple']['segmentLock(bool,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.segmentLock(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `vaultOptInLock(bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    vaultOptInLock: (params: CallParams<NfdInstanceArgs['obj']['vaultOptInLock(bool)void'] | NfdInstanceArgs['tuple']['vaultOptInLock(bool)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.vaultOptInLock(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `vaultOptIn(uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    vaultOptIn: (params: CallParams<NfdInstanceArgs['obj']['vaultOptIn(uint64[])void'] | NfdInstanceArgs['tuple']['vaultOptIn(uint64[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.vaultOptIn(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `vaultSend(uint64,address,string,uint64,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    vaultSend: (params: CallParams<NfdInstanceArgs['obj']['vaultSend(uint64,address,string,uint64,uint64[])void'] | NfdInstanceArgs['tuple']['vaultSend(uint64,address,string,uint64,uint64[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.vaultSend(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `renew(pay)void` ABI method.
     *
    * Renew adds more time to an existing NFDs expiration, or renews it if expired.
    
    
    As part of v2-v3 upgrade, the NFDs are converted from lifetime NFDs to renewal NFDs. The v2 contract is upgraded
    to v3, then renew is called on the (now v3) nfd to turn it into a renewal (note the if curExpiration === 0 check)
    
    
    If already renewal, then it extends the current expiration time by the time specified (minimum 1 yr) (365 / price paid * mint price)
    Expirations can never be more than NFD_MAX_EXPIRATION_DAYS days in the future.
    
    
    IF the NFD is expired:
       x The current owner can take it back over at base price - and NFD metadata doesn't have to be cleared - they
       get it back as-is.
       x If not current owner, then the price goes from high of base price * 10,000 down to base price over 24 hrs where
       'buyer' has to pay at least that price.  The NFD MUST ALREADY HAVE ITS METADATA CLEARED!

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    renew: (params: CallParams<NfdInstanceArgs['obj']['renew(pay)void'] | NfdInstanceArgs['tuple']['renew(pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.renew(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `setPrimaryAddress(string,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setPrimaryAddress: (params: CallParams<NfdInstanceArgs['obj']['setPrimaryAddress(string,address)void'] | NfdInstanceArgs['tuple']['setPrimaryAddress(string,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.setPrimaryAddress(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `registryAddingVerifiedAddress(string,string)bool` ABI method.
     *
    * Approved call from registry instructing us to move the specified u.cav.xx field and add to the specified
    verified field.

     *
     * @param params The params for the smart contract call
     * @returns The call params: true if added or already present, false otherwise
     */
    registryAddingVerifiedAddress: (params: CallParams<NfdInstanceArgs['obj']['registryAddingVerifiedAddress(string,string)bool'] | NfdInstanceArgs['tuple']['registryAddingVerifiedAddress(string,string)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.registryAddingVerifiedAddress(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `registryRemovingVerifiedAddress(string,address,address)bool` ABI method.
     *
     * Approved call from registry instructing us to REMOVE an address from the specified verified address set
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    registryRemovingVerifiedAddress: (params: CallParams<NfdInstanceArgs['obj']['registryRemovingVerifiedAddress(string,address,address)bool'] | NfdInstanceArgs['tuple']['registryRemovingVerifiedAddress(string,address,address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NfdInstanceParamsFactory.registryRemovingVerifiedAddress(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the NFDInstance smart contract using the `updateApplication(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update transaction
       */
      updateApplication: (params: CallParams<NfdInstanceArgs['obj']['updateApplication(string)void'] | NfdInstanceArgs['tuple']['updateApplication(string)void']> & AppClientCompilationParams) => {
        return this.appClient.createTransaction.update(NfdInstanceParamsFactory.update.updateApplication(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the NFDInstance smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `gas()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    gas: (params: CallParams<NfdInstanceArgs['obj']['gas()void'] | NfdInstanceArgs['tuple']['gas()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.gas(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `mintAsa(string,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mintAsa: (params: CallParams<NfdInstanceArgs['obj']['mintAsa(string,string)void'] | NfdInstanceArgs['tuple']['mintAsa(string,string)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.mintAsa(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `deleteFields(byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    deleteFields: (params: CallParams<NfdInstanceArgs['obj']['deleteFields(byte[][])void'] | NfdInstanceArgs['tuple']['deleteFields(byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.deleteFields(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `updateSegmentCount(string,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateSegmentCount: (params: CallParams<NfdInstanceArgs['obj']['updateSegmentCount(string,uint64)void'] | NfdInstanceArgs['tuple']['updateSegmentCount(string,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.updateSegmentCount(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `getFieldUpdateCost(byte[][])uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getFieldUpdateCost: (params: CallParams<NfdInstanceArgs['obj']['getFieldUpdateCost(byte[][])uint64'] | NfdInstanceArgs['tuple']['getFieldUpdateCost(byte[][])uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.getFieldUpdateCost(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `updateFields(byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateFields: (params: CallParams<NfdInstanceArgs['obj']['updateFields(byte[][])void'] | NfdInstanceArgs['tuple']['updateFields(byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.updateFields(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `readField(byte[])byte[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    readField: (params: CallParams<NfdInstanceArgs['obj']['readField(byte[])byte[]'] | NfdInstanceArgs['tuple']['readField(byte[])byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.readField(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `offerForSale(uint64,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    offerForSale: (params: CallParams<NfdInstanceArgs['obj']['offerForSale(uint64,address)void'] | NfdInstanceArgs['tuple']['offerForSale(uint64,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.offerForSale(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `cancelSale()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    cancelSale: (params: CallParams<NfdInstanceArgs['obj']['cancelSale()void'] | NfdInstanceArgs['tuple']['cancelSale()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.cancelSale(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `postOffer(uint64,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    postOffer: (params: CallParams<NfdInstanceArgs['obj']['postOffer(uint64,string)void'] | NfdInstanceArgs['tuple']['postOffer(uint64,string)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.postOffer(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mintPayout: (params: CallParams<NfdInstanceArgs['obj']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)'] | NfdInstanceArgs['tuple']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.mintPayout(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `purchase(pay)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    purchase: (params: CallParams<NfdInstanceArgs['obj']['purchase(pay)void'] | NfdInstanceArgs['tuple']['purchase(pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.purchase(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `isAddressInField(string,address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    isAddressInField: (params: CallParams<NfdInstanceArgs['obj']['isAddressInField(string,address)bool'] | NfdInstanceArgs['tuple']['isAddressInField(string,address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.isAddressInField(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `getRenewPrice()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getRenewPrice: (params: CallParams<NfdInstanceArgs['obj']['getRenewPrice()uint64'] | NfdInstanceArgs['tuple']['getRenewPrice()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.getRenewPrice(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `updateHash(byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateHash: (params: CallParams<NfdInstanceArgs['obj']['updateHash(byte[])void'] | NfdInstanceArgs['tuple']['updateHash(byte[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.updateHash(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `contractLock(bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    contractLock: (params: CallParams<NfdInstanceArgs['obj']['contractLock(bool)void'] | NfdInstanceArgs['tuple']['contractLock(bool)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.contractLock(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `segmentLock(bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    segmentLock: (params: CallParams<NfdInstanceArgs['obj']['segmentLock(bool,uint64)void'] | NfdInstanceArgs['tuple']['segmentLock(bool,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.segmentLock(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `vaultOptInLock(bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    vaultOptInLock: (params: CallParams<NfdInstanceArgs['obj']['vaultOptInLock(bool)void'] | NfdInstanceArgs['tuple']['vaultOptInLock(bool)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.vaultOptInLock(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `vaultOptIn(uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    vaultOptIn: (params: CallParams<NfdInstanceArgs['obj']['vaultOptIn(uint64[])void'] | NfdInstanceArgs['tuple']['vaultOptIn(uint64[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.vaultOptIn(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `vaultSend(uint64,address,string,uint64,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    vaultSend: (params: CallParams<NfdInstanceArgs['obj']['vaultSend(uint64,address,string,uint64,uint64[])void'] | NfdInstanceArgs['tuple']['vaultSend(uint64,address,string,uint64,uint64[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.vaultSend(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `renew(pay)void` ABI method.
     *
    * Renew adds more time to an existing NFDs expiration, or renews it if expired.
    
    
    As part of v2-v3 upgrade, the NFDs are converted from lifetime NFDs to renewal NFDs. The v2 contract is upgraded
    to v3, then renew is called on the (now v3) nfd to turn it into a renewal (note the if curExpiration === 0 check)
    
    
    If already renewal, then it extends the current expiration time by the time specified (minimum 1 yr) (365 / price paid * mint price)
    Expirations can never be more than NFD_MAX_EXPIRATION_DAYS days in the future.
    
    
    IF the NFD is expired:
       x The current owner can take it back over at base price - and NFD metadata doesn't have to be cleared - they
       get it back as-is.
       x If not current owner, then the price goes from high of base price * 10,000 down to base price over 24 hrs where
       'buyer' has to pay at least that price.  The NFD MUST ALREADY HAVE ITS METADATA CLEARED!

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    renew: (params: CallParams<NfdInstanceArgs['obj']['renew(pay)void'] | NfdInstanceArgs['tuple']['renew(pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.renew(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `setPrimaryAddress(string,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setPrimaryAddress: (params: CallParams<NfdInstanceArgs['obj']['setPrimaryAddress(string,address)void'] | NfdInstanceArgs['tuple']['setPrimaryAddress(string,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.setPrimaryAddress(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `registryAddingVerifiedAddress(string,string)bool` ABI method.
     *
    * Approved call from registry instructing us to move the specified u.cav.xx field and add to the specified
    verified field.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: true if added or already present, false otherwise
     */
    registryAddingVerifiedAddress: (params: CallParams<NfdInstanceArgs['obj']['registryAddingVerifiedAddress(string,string)bool'] | NfdInstanceArgs['tuple']['registryAddingVerifiedAddress(string,string)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.registryAddingVerifiedAddress(params))
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `registryRemovingVerifiedAddress(string,address,address)bool` ABI method.
     *
     * Approved call from registry instructing us to REMOVE an address from the specified verified address set
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    registryRemovingVerifiedAddress: (params: CallParams<NfdInstanceArgs['obj']['registryRemovingVerifiedAddress(string,address,address)bool'] | NfdInstanceArgs['tuple']['registryRemovingVerifiedAddress(string,address,address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NfdInstanceParamsFactory.registryRemovingVerifiedAddress(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the NFDInstance smart contract using the `updateApplication(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update result
       */
      updateApplication: async (params: CallParams<NfdInstanceArgs['obj']['updateApplication(string)void'] | NfdInstanceArgs['tuple']['updateApplication(string)void']> & AppClientCompilationParams & SendParams) => {
        const result = await this.appClient.send.update(NfdInstanceParamsFactory.update.updateApplication(params))
        return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['updateApplication(string)void'])}
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the NFDInstance smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `gas()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    gas: async (params: CallParams<NfdInstanceArgs['obj']['gas()void'] | NfdInstanceArgs['tuple']['gas()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.gas(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['gas()void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `mintAsa(string,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mintAsa: async (params: CallParams<NfdInstanceArgs['obj']['mintAsa(string,string)void'] | NfdInstanceArgs['tuple']['mintAsa(string,string)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.mintAsa(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['mintAsa(string,string)void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `deleteFields(byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    deleteFields: async (params: CallParams<NfdInstanceArgs['obj']['deleteFields(byte[][])void'] | NfdInstanceArgs['tuple']['deleteFields(byte[][])void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.deleteFields(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['deleteFields(byte[][])void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `updateSegmentCount(string,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateSegmentCount: async (params: CallParams<NfdInstanceArgs['obj']['updateSegmentCount(string,uint64)void'] | NfdInstanceArgs['tuple']['updateSegmentCount(string,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.updateSegmentCount(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['updateSegmentCount(string,uint64)void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `getFieldUpdateCost(byte[][])uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getFieldUpdateCost: async (params: CallParams<NfdInstanceArgs['obj']['getFieldUpdateCost(byte[][])uint64'] | NfdInstanceArgs['tuple']['getFieldUpdateCost(byte[][])uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.getFieldUpdateCost(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['getFieldUpdateCost(byte[][])uint64'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `updateFields(byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateFields: async (params: CallParams<NfdInstanceArgs['obj']['updateFields(byte[][])void'] | NfdInstanceArgs['tuple']['updateFields(byte[][])void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.updateFields(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['updateFields(byte[][])void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `readField(byte[])byte[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    readField: async (params: CallParams<NfdInstanceArgs['obj']['readField(byte[])byte[]'] | NfdInstanceArgs['tuple']['readField(byte[])byte[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.readField(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['readField(byte[])byte[]'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `offerForSale(uint64,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    offerForSale: async (params: CallParams<NfdInstanceArgs['obj']['offerForSale(uint64,address)void'] | NfdInstanceArgs['tuple']['offerForSale(uint64,address)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.offerForSale(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['offerForSale(uint64,address)void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `cancelSale()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    cancelSale: async (params: CallParams<NfdInstanceArgs['obj']['cancelSale()void'] | NfdInstanceArgs['tuple']['cancelSale()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.cancelSale(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['cancelSale()void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `postOffer(uint64,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    postOffer: async (params: CallParams<NfdInstanceArgs['obj']['postOffer(uint64,string)void'] | NfdInstanceArgs['tuple']['postOffer(uint64,string)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.postOffer(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['postOffer(uint64,string)void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mintPayout: async (params: CallParams<NfdInstanceArgs['obj']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)'] | NfdInstanceArgs['tuple']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.mintPayout(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `purchase(pay)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    purchase: async (params: CallParams<NfdInstanceArgs['obj']['purchase(pay)void'] | NfdInstanceArgs['tuple']['purchase(pay)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.purchase(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['purchase(pay)void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `isAddressInField(string,address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    isAddressInField: async (params: CallParams<NfdInstanceArgs['obj']['isAddressInField(string,address)bool'] | NfdInstanceArgs['tuple']['isAddressInField(string,address)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.isAddressInField(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['isAddressInField(string,address)bool'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `getRenewPrice()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getRenewPrice: async (params: CallParams<NfdInstanceArgs['obj']['getRenewPrice()uint64'] | NfdInstanceArgs['tuple']['getRenewPrice()uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.getRenewPrice(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['getRenewPrice()uint64'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `updateHash(byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateHash: async (params: CallParams<NfdInstanceArgs['obj']['updateHash(byte[])void'] | NfdInstanceArgs['tuple']['updateHash(byte[])void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.updateHash(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['updateHash(byte[])void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `contractLock(bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    contractLock: async (params: CallParams<NfdInstanceArgs['obj']['contractLock(bool)void'] | NfdInstanceArgs['tuple']['contractLock(bool)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.contractLock(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['contractLock(bool)void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `segmentLock(bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    segmentLock: async (params: CallParams<NfdInstanceArgs['obj']['segmentLock(bool,uint64)void'] | NfdInstanceArgs['tuple']['segmentLock(bool,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.segmentLock(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['segmentLock(bool,uint64)void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `vaultOptInLock(bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    vaultOptInLock: async (params: CallParams<NfdInstanceArgs['obj']['vaultOptInLock(bool)void'] | NfdInstanceArgs['tuple']['vaultOptInLock(bool)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.vaultOptInLock(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['vaultOptInLock(bool)void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `vaultOptIn(uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    vaultOptIn: async (params: CallParams<NfdInstanceArgs['obj']['vaultOptIn(uint64[])void'] | NfdInstanceArgs['tuple']['vaultOptIn(uint64[])void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.vaultOptIn(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['vaultOptIn(uint64[])void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `vaultSend(uint64,address,string,uint64,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    vaultSend: async (params: CallParams<NfdInstanceArgs['obj']['vaultSend(uint64,address,string,uint64,uint64[])void'] | NfdInstanceArgs['tuple']['vaultSend(uint64,address,string,uint64,uint64[])void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.vaultSend(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['vaultSend(uint64,address,string,uint64,uint64[])void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `renew(pay)void` ABI method.
     *
    * Renew adds more time to an existing NFDs expiration, or renews it if expired.
    
    
    As part of v2-v3 upgrade, the NFDs are converted from lifetime NFDs to renewal NFDs. The v2 contract is upgraded
    to v3, then renew is called on the (now v3) nfd to turn it into a renewal (note the if curExpiration === 0 check)
    
    
    If already renewal, then it extends the current expiration time by the time specified (minimum 1 yr) (365 / price paid * mint price)
    Expirations can never be more than NFD_MAX_EXPIRATION_DAYS days in the future.
    
    
    IF the NFD is expired:
       x The current owner can take it back over at base price - and NFD metadata doesn't have to be cleared - they
       get it back as-is.
       x If not current owner, then the price goes from high of base price * 10,000 down to base price over 24 hrs where
       'buyer' has to pay at least that price.  The NFD MUST ALREADY HAVE ITS METADATA CLEARED!

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    renew: async (params: CallParams<NfdInstanceArgs['obj']['renew(pay)void'] | NfdInstanceArgs['tuple']['renew(pay)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.renew(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['renew(pay)void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `setPrimaryAddress(string,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setPrimaryAddress: async (params: CallParams<NfdInstanceArgs['obj']['setPrimaryAddress(string,address)void'] | NfdInstanceArgs['tuple']['setPrimaryAddress(string,address)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.setPrimaryAddress(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['setPrimaryAddress(string,address)void'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `registryAddingVerifiedAddress(string,string)bool` ABI method.
     *
    * Approved call from registry instructing us to move the specified u.cav.xx field and add to the specified
    verified field.

     *
     * @param params The params for the smart contract call
     * @returns The call result: true if added or already present, false otherwise
     */
    registryAddingVerifiedAddress: async (params: CallParams<NfdInstanceArgs['obj']['registryAddingVerifiedAddress(string,string)bool'] | NfdInstanceArgs['tuple']['registryAddingVerifiedAddress(string,string)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.registryAddingVerifiedAddress(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['registryAddingVerifiedAddress(string,string)bool'])}
    },

    /**
     * Makes a call to the NFDInstance smart contract using the `registryRemovingVerifiedAddress(string,address,address)bool` ABI method.
     *
     * Approved call from registry instructing us to REMOVE an address from the specified verified address set
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    registryRemovingVerifiedAddress: async (params: CallParams<NfdInstanceArgs['obj']['registryRemovingVerifiedAddress(string,address,address)bool'] | NfdInstanceArgs['tuple']['registryRemovingVerifiedAddress(string,address,address)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NfdInstanceParamsFactory.registryRemovingVerifiedAddress(params))
      return {...result, return: result.return as unknown as (undefined | NfdInstanceReturns['registryRemovingVerifiedAddress(string,address,address)bool'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new NfdInstanceClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the NFDInstance smart contract using the `getFieldUpdateCost(byte[][])uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getFieldUpdateCost(params: CallParams<NfdInstanceArgs['obj']['getFieldUpdateCost(byte[][])uint64'] | NfdInstanceArgs['tuple']['getFieldUpdateCost(byte[][])uint64']>) {
    const result = await this.appClient.send.call(NfdInstanceParamsFactory.getFieldUpdateCost(params))
    return result.return as unknown as NfdInstanceReturns['getFieldUpdateCost(byte[][])uint64']
  }

  /**
   * Makes a readonly (simulated) call to the NFDInstance smart contract using the `readField(byte[])byte[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async readField(params: CallParams<NfdInstanceArgs['obj']['readField(byte[])byte[]'] | NfdInstanceArgs['tuple']['readField(byte[])byte[]']>) {
    const result = await this.appClient.send.call(NfdInstanceParamsFactory.readField(params))
    return result.return as unknown as NfdInstanceReturns['readField(byte[])byte[]']
  }

  /**
   * Makes a readonly (simulated) call to the NFDInstance smart contract using the `isAddressInField(string,address)bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async isAddressInField(params: CallParams<NfdInstanceArgs['obj']['isAddressInField(string,address)bool'] | NfdInstanceArgs['tuple']['isAddressInField(string,address)bool']>) {
    const result = await this.appClient.send.call(NfdInstanceParamsFactory.isAddressInField(params))
    return result.return as unknown as NfdInstanceReturns['isAddressInField(string,address)bool']
  }

  /**
   * Makes a readonly (simulated) call to the NFDInstance smart contract using the `getRenewPrice()uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getRenewPrice(params: CallParams<NfdInstanceArgs['obj']['getRenewPrice()uint64'] | NfdInstanceArgs['tuple']['getRenewPrice()uint64']> = {args: []}) {
    const result = await this.appClient.send.call(NfdInstanceParamsFactory.getRenewPrice(params))
    return result.return as unknown as NfdInstanceReturns['getRenewPrice()uint64']
  }

  /**
   * Methods to access state for the current NFDInstance app
   */
  state = {
    /**
     * Methods to access global state for the current NFDInstance app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
        }
      },
      /**
       * Get values from the globalState map in global state
       */
      globalState: {
        /**
         * Get all current values of the globalState map in global state
         */
        getMap: async (): Promise<Map<Uint8Array, Uint8Array>> => { return (await this.appClient.state.global.getMap("globalState")) as Map<Uint8Array, Uint8Array> },
        /**
         * Get a current value of the globalState map by key from global state
         */
        value: async (key: Uint8Array | string): Promise<Uint8Array | undefined> => { return await this.appClient.state.global.getMapValue("globalState", key) as Uint8Array | undefined },
      },
    },
    /**
     * Methods to access box state for the current NFDInstance app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
        }
      },
      /**
       * Get values from the boxes map in box state
       */
      boxes: {
        /**
         * Get all current values of the boxes map in box state
         */
        getMap: async (): Promise<Map<Uint8Array, Uint8Array>> => { return (await this.appClient.state.box.getMap("boxes")) as Map<Uint8Array, Uint8Array> },
        /**
         * Get a current value of the boxes map by key from box state
         */
        value: async (key: Uint8Array | string): Promise<Uint8Array | undefined> => { return await this.appClient.state.box.getMapValue("boxes", key) as Uint8Array | undefined },
      },
    },
  }

  public newGroup(): NfdInstanceComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a gas()void method call against the NFDInstance contract
       */
      gas(params: CallParams<NfdInstanceArgs['obj']['gas()void'] | NfdInstanceArgs['tuple']['gas()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.gas(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a mintAsa(string,string)void method call against the NFDInstance contract
       */
      mintAsa(params: CallParams<NfdInstanceArgs['obj']['mintAsa(string,string)void'] | NfdInstanceArgs['tuple']['mintAsa(string,string)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mintAsa(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a deleteFields(byte[][])void method call against the NFDInstance contract
       */
      deleteFields(params: CallParams<NfdInstanceArgs['obj']['deleteFields(byte[][])void'] | NfdInstanceArgs['tuple']['deleteFields(byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deleteFields(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a updateSegmentCount(string,uint64)void method call against the NFDInstance contract
       */
      updateSegmentCount(params: CallParams<NfdInstanceArgs['obj']['updateSegmentCount(string,uint64)void'] | NfdInstanceArgs['tuple']['updateSegmentCount(string,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateSegmentCount(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a getFieldUpdateCost(byte[][])uint64 method call against the NFDInstance contract
       */
      getFieldUpdateCost(params: CallParams<NfdInstanceArgs['obj']['getFieldUpdateCost(byte[][])uint64'] | NfdInstanceArgs['tuple']['getFieldUpdateCost(byte[][])uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getFieldUpdateCost(params)))
        resultMappers.push((v) => client.decodeReturnValue('getFieldUpdateCost(byte[][])uint64', v))
        return this
      },
      /**
       * Add a updateFields(byte[][])void method call against the NFDInstance contract
       */
      updateFields(params: CallParams<NfdInstanceArgs['obj']['updateFields(byte[][])void'] | NfdInstanceArgs['tuple']['updateFields(byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateFields(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a readField(byte[])byte[] method call against the NFDInstance contract
       */
      readField(params: CallParams<NfdInstanceArgs['obj']['readField(byte[])byte[]'] | NfdInstanceArgs['tuple']['readField(byte[])byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.readField(params)))
        resultMappers.push((v) => client.decodeReturnValue('readField(byte[])byte[]', v))
        return this
      },
      /**
       * Add a offerForSale(uint64,address)void method call against the NFDInstance contract
       */
      offerForSale(params: CallParams<NfdInstanceArgs['obj']['offerForSale(uint64,address)void'] | NfdInstanceArgs['tuple']['offerForSale(uint64,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.offerForSale(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a cancelSale()void method call against the NFDInstance contract
       */
      cancelSale(params: CallParams<NfdInstanceArgs['obj']['cancelSale()void'] | NfdInstanceArgs['tuple']['cancelSale()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.cancelSale(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a postOffer(uint64,string)void method call against the NFDInstance contract
       */
      postOffer(params: CallParams<NfdInstanceArgs['obj']['postOffer(uint64,string)void'] | NfdInstanceArgs['tuple']['postOffer(uint64,string)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.postOffer(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64) method call against the NFDInstance contract
       */
      mintPayout(params: CallParams<NfdInstanceArgs['obj']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)'] | NfdInstanceArgs['tuple']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mintPayout(params)))
        resultMappers.push((v) => client.decodeReturnValue('mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)', v))
        return this
      },
      /**
       * Add a purchase(pay)void method call against the NFDInstance contract
       */
      purchase(params: CallParams<NfdInstanceArgs['obj']['purchase(pay)void'] | NfdInstanceArgs['tuple']['purchase(pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.purchase(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a isAddressInField(string,address)bool method call against the NFDInstance contract
       */
      isAddressInField(params: CallParams<NfdInstanceArgs['obj']['isAddressInField(string,address)bool'] | NfdInstanceArgs['tuple']['isAddressInField(string,address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.isAddressInField(params)))
        resultMappers.push((v) => client.decodeReturnValue('isAddressInField(string,address)bool', v))
        return this
      },
      /**
       * Add a getRenewPrice()uint64 method call against the NFDInstance contract
       */
      getRenewPrice(params: CallParams<NfdInstanceArgs['obj']['getRenewPrice()uint64'] | NfdInstanceArgs['tuple']['getRenewPrice()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getRenewPrice(params)))
        resultMappers.push((v) => client.decodeReturnValue('getRenewPrice()uint64', v))
        return this
      },
      /**
       * Add a updateHash(byte[])void method call against the NFDInstance contract
       */
      updateHash(params: CallParams<NfdInstanceArgs['obj']['updateHash(byte[])void'] | NfdInstanceArgs['tuple']['updateHash(byte[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateHash(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a contractLock(bool)void method call against the NFDInstance contract
       */
      contractLock(params: CallParams<NfdInstanceArgs['obj']['contractLock(bool)void'] | NfdInstanceArgs['tuple']['contractLock(bool)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.contractLock(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a segmentLock(bool,uint64)void method call against the NFDInstance contract
       */
      segmentLock(params: CallParams<NfdInstanceArgs['obj']['segmentLock(bool,uint64)void'] | NfdInstanceArgs['tuple']['segmentLock(bool,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.segmentLock(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a vaultOptInLock(bool)void method call against the NFDInstance contract
       */
      vaultOptInLock(params: CallParams<NfdInstanceArgs['obj']['vaultOptInLock(bool)void'] | NfdInstanceArgs['tuple']['vaultOptInLock(bool)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.vaultOptInLock(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a vaultOptIn(uint64[])void method call against the NFDInstance contract
       */
      vaultOptIn(params: CallParams<NfdInstanceArgs['obj']['vaultOptIn(uint64[])void'] | NfdInstanceArgs['tuple']['vaultOptIn(uint64[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.vaultOptIn(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a vaultSend(uint64,address,string,uint64,uint64[])void method call against the NFDInstance contract
       */
      vaultSend(params: CallParams<NfdInstanceArgs['obj']['vaultSend(uint64,address,string,uint64,uint64[])void'] | NfdInstanceArgs['tuple']['vaultSend(uint64,address,string,uint64,uint64[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.vaultSend(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a renew(pay)void method call against the NFDInstance contract
       */
      renew(params: CallParams<NfdInstanceArgs['obj']['renew(pay)void'] | NfdInstanceArgs['tuple']['renew(pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.renew(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a setPrimaryAddress(string,address)void method call against the NFDInstance contract
       */
      setPrimaryAddress(params: CallParams<NfdInstanceArgs['obj']['setPrimaryAddress(string,address)void'] | NfdInstanceArgs['tuple']['setPrimaryAddress(string,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setPrimaryAddress(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a registryAddingVerifiedAddress(string,string)bool method call against the NFDInstance contract
       */
      registryAddingVerifiedAddress(params: CallParams<NfdInstanceArgs['obj']['registryAddingVerifiedAddress(string,string)bool'] | NfdInstanceArgs['tuple']['registryAddingVerifiedAddress(string,string)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.registryAddingVerifiedAddress(params)))
        resultMappers.push((v) => client.decodeReturnValue('registryAddingVerifiedAddress(string,string)bool', v))
        return this
      },
      /**
       * Add a registryRemovingVerifiedAddress(string,address,address)bool method call against the NFDInstance contract
       */
      registryRemovingVerifiedAddress(params: CallParams<NfdInstanceArgs['obj']['registryRemovingVerifiedAddress(string,address,address)bool'] | NfdInstanceArgs['tuple']['registryRemovingVerifiedAddress(string,address,address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.registryRemovingVerifiedAddress(params)))
        resultMappers.push((v) => client.decodeReturnValue('registryRemovingVerifiedAddress(string,address,address)bool', v))
        return this
      },
      get update() {
        return {
          updateApplication: (params: CallParams<NfdInstanceArgs['obj']['updateApplication(string)void'] | NfdInstanceArgs['tuple']['updateApplication(string)void']> & AppClientCompilationParams) => {
            promiseChain = promiseChain.then(async () => composer.addAppUpdateMethodCall(await client.params.update.updateApplication(params)))
            resultMappers.push(undefined)
            return this
          },
        }
      },
      /**
       * Add a clear state call to the NFDInstance contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as NfdInstanceComposer
  }
}
export type NfdInstanceComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the gas()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  gas(params?: CallParams<NfdInstanceArgs['obj']['gas()void'] | NfdInstanceArgs['tuple']['gas()void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['gas()void'] | undefined]>

  /**
   * Calls the mintAsa(string,string)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mintAsa(params?: CallParams<NfdInstanceArgs['obj']['mintAsa(string,string)void'] | NfdInstanceArgs['tuple']['mintAsa(string,string)void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['mintAsa(string,string)void'] | undefined]>

  /**
   * Calls the deleteFields(byte[][])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  deleteFields(params?: CallParams<NfdInstanceArgs['obj']['deleteFields(byte[][])void'] | NfdInstanceArgs['tuple']['deleteFields(byte[][])void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['deleteFields(byte[][])void'] | undefined]>

  /**
   * Calls the updateSegmentCount(string,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateSegmentCount(params?: CallParams<NfdInstanceArgs['obj']['updateSegmentCount(string,uint64)void'] | NfdInstanceArgs['tuple']['updateSegmentCount(string,uint64)void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['updateSegmentCount(string,uint64)void'] | undefined]>

  /**
   * Calls the getFieldUpdateCost(byte[][])uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getFieldUpdateCost(params?: CallParams<NfdInstanceArgs['obj']['getFieldUpdateCost(byte[][])uint64'] | NfdInstanceArgs['tuple']['getFieldUpdateCost(byte[][])uint64']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['getFieldUpdateCost(byte[][])uint64'] | undefined]>

  /**
   * Calls the updateFields(byte[][])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateFields(params?: CallParams<NfdInstanceArgs['obj']['updateFields(byte[][])void'] | NfdInstanceArgs['tuple']['updateFields(byte[][])void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['updateFields(byte[][])void'] | undefined]>

  /**
   * Calls the readField(byte[])byte[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  readField(params?: CallParams<NfdInstanceArgs['obj']['readField(byte[])byte[]'] | NfdInstanceArgs['tuple']['readField(byte[])byte[]']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['readField(byte[])byte[]'] | undefined]>

  /**
   * Calls the offerForSale(uint64,address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  offerForSale(params?: CallParams<NfdInstanceArgs['obj']['offerForSale(uint64,address)void'] | NfdInstanceArgs['tuple']['offerForSale(uint64,address)void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['offerForSale(uint64,address)void'] | undefined]>

  /**
   * Calls the cancelSale()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  cancelSale(params?: CallParams<NfdInstanceArgs['obj']['cancelSale()void'] | NfdInstanceArgs['tuple']['cancelSale()void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['cancelSale()void'] | undefined]>

  /**
   * Calls the postOffer(uint64,string)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  postOffer(params?: CallParams<NfdInstanceArgs['obj']['postOffer(uint64,string)void'] | NfdInstanceArgs['tuple']['postOffer(uint64,string)void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['postOffer(uint64,string)void'] | undefined]>

  /**
   * Calls the mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mintPayout(params?: CallParams<NfdInstanceArgs['obj']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)'] | NfdInstanceArgs['tuple']['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['mintPayout(uint64,uint64)(uint64,address,uint64,address,uint64)'] | undefined]>

  /**
   * Calls the purchase(pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  purchase(params?: CallParams<NfdInstanceArgs['obj']['purchase(pay)void'] | NfdInstanceArgs['tuple']['purchase(pay)void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['purchase(pay)void'] | undefined]>

  /**
   * Calls the isAddressInField(string,address)bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isAddressInField(params?: CallParams<NfdInstanceArgs['obj']['isAddressInField(string,address)bool'] | NfdInstanceArgs['tuple']['isAddressInField(string,address)bool']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['isAddressInField(string,address)bool'] | undefined]>

  /**
   * Calls the getRenewPrice()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getRenewPrice(params?: CallParams<NfdInstanceArgs['obj']['getRenewPrice()uint64'] | NfdInstanceArgs['tuple']['getRenewPrice()uint64']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['getRenewPrice()uint64'] | undefined]>

  /**
   * Calls the updateHash(byte[])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateHash(params?: CallParams<NfdInstanceArgs['obj']['updateHash(byte[])void'] | NfdInstanceArgs['tuple']['updateHash(byte[])void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['updateHash(byte[])void'] | undefined]>

  /**
   * Calls the contractLock(bool)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractLock(params?: CallParams<NfdInstanceArgs['obj']['contractLock(bool)void'] | NfdInstanceArgs['tuple']['contractLock(bool)void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['contractLock(bool)void'] | undefined]>

  /**
   * Calls the segmentLock(bool,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  segmentLock(params?: CallParams<NfdInstanceArgs['obj']['segmentLock(bool,uint64)void'] | NfdInstanceArgs['tuple']['segmentLock(bool,uint64)void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['segmentLock(bool,uint64)void'] | undefined]>

  /**
   * Calls the vaultOptInLock(bool)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  vaultOptInLock(params?: CallParams<NfdInstanceArgs['obj']['vaultOptInLock(bool)void'] | NfdInstanceArgs['tuple']['vaultOptInLock(bool)void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['vaultOptInLock(bool)void'] | undefined]>

  /**
   * Calls the vaultOptIn(uint64[])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  vaultOptIn(params?: CallParams<NfdInstanceArgs['obj']['vaultOptIn(uint64[])void'] | NfdInstanceArgs['tuple']['vaultOptIn(uint64[])void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['vaultOptIn(uint64[])void'] | undefined]>

  /**
   * Calls the vaultSend(uint64,address,string,uint64,uint64[])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  vaultSend(params?: CallParams<NfdInstanceArgs['obj']['vaultSend(uint64,address,string,uint64,uint64[])void'] | NfdInstanceArgs['tuple']['vaultSend(uint64,address,string,uint64,uint64[])void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['vaultSend(uint64,address,string,uint64,uint64[])void'] | undefined]>

  /**
   * Calls the renew(pay)void ABI method.
   *
  * Renew adds more time to an existing NFDs expiration, or renews it if expired.
  
  
  As part of v2-v3 upgrade, the NFDs are converted from lifetime NFDs to renewal NFDs. The v2 contract is upgraded
  to v3, then renew is called on the (now v3) nfd to turn it into a renewal (note the if curExpiration === 0 check)
  
  
  If already renewal, then it extends the current expiration time by the time specified (minimum 1 yr) (365 / price paid * mint price)
  Expirations can never be more than NFD_MAX_EXPIRATION_DAYS days in the future.
  
  
  IF the NFD is expired:
     x The current owner can take it back over at base price - and NFD metadata doesn't have to be cleared - they
     get it back as-is.
     x If not current owner, then the price goes from high of base price * 10,000 down to base price over 24 hrs where
     'buyer' has to pay at least that price.  The NFD MUST ALREADY HAVE ITS METADATA CLEARED!

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  renew(params?: CallParams<NfdInstanceArgs['obj']['renew(pay)void'] | NfdInstanceArgs['tuple']['renew(pay)void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['renew(pay)void'] | undefined]>

  /**
   * Calls the setPrimaryAddress(string,address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setPrimaryAddress(params?: CallParams<NfdInstanceArgs['obj']['setPrimaryAddress(string,address)void'] | NfdInstanceArgs['tuple']['setPrimaryAddress(string,address)void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['setPrimaryAddress(string,address)void'] | undefined]>

  /**
   * Calls the registryAddingVerifiedAddress(string,string)bool ABI method.
   *
  * Approved call from registry instructing us to move the specified u.cav.xx field and add to the specified
  verified field.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  registryAddingVerifiedAddress(params?: CallParams<NfdInstanceArgs['obj']['registryAddingVerifiedAddress(string,string)bool'] | NfdInstanceArgs['tuple']['registryAddingVerifiedAddress(string,string)bool']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['registryAddingVerifiedAddress(string,string)bool'] | undefined]>

  /**
   * Calls the registryRemovingVerifiedAddress(string,address,address)bool ABI method.
   *
   * Approved call from registry instructing us to REMOVE an address from the specified verified address set
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  registryRemovingVerifiedAddress(params?: CallParams<NfdInstanceArgs['obj']['registryRemovingVerifiedAddress(string,address,address)bool'] | NfdInstanceArgs['tuple']['registryRemovingVerifiedAddress(string,address,address)bool']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['registryRemovingVerifiedAddress(string,address,address)bool'] | undefined]>

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the NFDInstance smart contract using the updateApplication(string)void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateApplication(params?: CallParams<NfdInstanceArgs['obj']['updateApplication(string)void'] | NfdInstanceArgs['tuple']['updateApplication(string)void']>): NfdInstanceComposer<[...TReturns, NfdInstanceReturns['updateApplication(string)void'] | undefined]>
  }

  /**
   * Makes a clear_state call to an existing instance of the NFDInstance smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): NfdInstanceComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): NfdInstanceComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<NfdInstanceComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<NfdInstanceComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<NfdInstanceComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<NfdInstanceComposerResults<TReturns>>
}
export type NfdInstanceComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

